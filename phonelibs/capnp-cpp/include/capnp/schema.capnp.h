// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: schema.capnp

#ifndef CAPNP_INCLUDED_a93fc509624c72d9_
#define CAPNP_INCLUDED_a93fc509624c72d9_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 6001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(e682ab4cf923a417);
CAPNP_DECLARE_SCHEMA(b9521bccf10fa3b1);
CAPNP_DECLARE_SCHEMA(debf55bbfa0fc242);
CAPNP_DECLARE_SCHEMA(9ea0b19b37fb4435);
CAPNP_DECLARE_SCHEMA(b54ab3364333f598);
CAPNP_DECLARE_SCHEMA(e82753cff0c2218f);
CAPNP_DECLARE_SCHEMA(b18aa5ac7a0d9420);
CAPNP_DECLARE_SCHEMA(ec1619d4400a0290);
CAPNP_DECLARE_SCHEMA(9aad50a41f4af45f);
CAPNP_DECLARE_SCHEMA(97b14cbe7cfec712);
CAPNP_DECLARE_SCHEMA(c42305476bb4746f);
CAPNP_DECLARE_SCHEMA(cafccddb68db1d11);
CAPNP_DECLARE_SCHEMA(bb90d5c287870be6);
CAPNP_DECLARE_SCHEMA(978a7cebdc549a4d);
CAPNP_DECLARE_SCHEMA(a9962a9ed0a4d7f8);
CAPNP_DECLARE_SCHEMA(9500cce23b334d80);
CAPNP_DECLARE_SCHEMA(d07378ede1f9cc60);
CAPNP_DECLARE_SCHEMA(87e739250a60ea97);
CAPNP_DECLARE_SCHEMA(9e0e78711a7f87a9);
CAPNP_DECLARE_SCHEMA(ac3a6f60ef4cc6d3);
CAPNP_DECLARE_SCHEMA(ed8bca69f7fb0cbf);
CAPNP_DECLARE_SCHEMA(c2573fe8a23e49f1);
CAPNP_DECLARE_SCHEMA(8e3b5f79fe593656);
CAPNP_DECLARE_SCHEMA(9dd1f724f4614a85);
CAPNP_DECLARE_SCHEMA(baefc9120c56e274);
CAPNP_DECLARE_SCHEMA(903455f06065422b);
CAPNP_DECLARE_SCHEMA(abd73485a9636bc9);
CAPNP_DECLARE_SCHEMA(c863cd16969ee7fc);
CAPNP_DECLARE_SCHEMA(ce23dcd2d7b00c9b);
CAPNP_DECLARE_SCHEMA(f1c8950dab257542);
CAPNP_DECLARE_SCHEMA(d1958f7dba521926);
enum class ElementSize_d1958f7dba521926: uint16_t {
  EMPTY,
  BIT,
  BYTE,
  TWO_BYTES,
  FOUR_BYTES,
  EIGHT_BYTES,
  POINTER,
  INLINE_COMPOSITE,
};
CAPNP_DECLARE_ENUM(ElementSize, d1958f7dba521926);
CAPNP_DECLARE_SCHEMA(d85d305b7d839963);
CAPNP_DECLARE_SCHEMA(bfc546f6210ad7ce);
CAPNP_DECLARE_SCHEMA(cfea0eb02e810062);
CAPNP_DECLARE_SCHEMA(ae504193122357e5);

}  // namespace schemas
}  // namespace capnp

namespace capnp {
namespace schema {

struct Node {
  Node() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    FILE,
    STRUCT,
    ENUM,
    INTERFACE,
    CONST,
    ANNOTATION,
  };
  struct Parameter;
  struct NestedNode;
  struct Struct;
  struct Enum;
  struct Interface;
  struct Const;
  struct Annotation;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e682ab4cf923a417, 5, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Node::Parameter {
  Parameter() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b9521bccf10fa3b1, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Node::NestedNode {
  NestedNode() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(debf55bbfa0fc242, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Node::Struct {
  Struct() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ea0b19b37fb4435, 5, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Node::Enum {
  Enum() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b54ab3364333f598, 5, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Node::Interface {
  Interface() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e82753cff0c2218f, 5, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Node::Const {
  Const() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b18aa5ac7a0d9420, 5, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Node::Annotation {
  Annotation() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ec1619d4400a0290, 5, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Field {
  Field() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    SLOT,
    GROUP,
  };
  static constexpr  ::uint16_t NO_DISCRIMINANT = 65535u;
  struct Slot;
  struct Group;
  struct Ordinal;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9aad50a41f4af45f, 3, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Field::Slot {
  Slot() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c42305476bb4746f, 3, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Field::Group {
  Group() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cafccddb68db1d11, 3, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Field::Ordinal {
  Ordinal() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    IMPLICIT,
    EXPLICIT,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bb90d5c287870be6, 3, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Enumerant {
  Enumerant() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(978a7cebdc549a4d, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Superclass {
  Superclass() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a9962a9ed0a4d7f8, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Method {
  Method() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9500cce23b334d80, 3, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Type {
  Type() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    VOID,
    BOOL,
    INT8,
    INT16,
    INT32,
    INT64,
    UINT8,
    UINT16,
    UINT32,
    UINT64,
    FLOAT32,
    FLOAT64,
    TEXT,
    DATA,
    LIST,
    ENUM,
    STRUCT,
    INTERFACE,
    ANY_POINTER,
  };
  struct List;
  struct Enum;
  struct Struct;
  struct Interface;
  struct AnyPointer;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d07378ede1f9cc60, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Type::List {
  List() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(87e739250a60ea97, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Type::Enum {
  Enum() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9e0e78711a7f87a9, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Type::Struct {
  Struct() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ac3a6f60ef4cc6d3, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Type::Interface {
  Interface() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ed8bca69f7fb0cbf, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Type::AnyPointer {
  AnyPointer() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNCONSTRAINED,
    PARAMETER,
    IMPLICIT_METHOD_PARAMETER,
  };
  struct Unconstrained;
  struct Parameter;
  struct ImplicitMethodParameter;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c2573fe8a23e49f1, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Type::AnyPointer::Unconstrained {
  Unconstrained() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    ANY_KIND,
    STRUCT,
    LIST,
    CAPABILITY,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8e3b5f79fe593656, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Type::AnyPointer::Parameter {
  Parameter() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9dd1f724f4614a85, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Type::AnyPointer::ImplicitMethodParameter {
  ImplicitMethodParameter() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(baefc9120c56e274, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Brand {
  Brand() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Scope;
  struct Binding;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(903455f06065422b, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Brand::Scope {
  Scope() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    BIND,
    INHERIT,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(abd73485a9636bc9, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Brand::Binding {
  Binding() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNBOUND,
    TYPE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c863cd16969ee7fc, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Value {
  Value() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    VOID,
    BOOL,
    INT8,
    INT16,
    INT32,
    INT64,
    UINT8,
    UINT16,
    UINT32,
    UINT64,
    FLOAT32,
    FLOAT64,
    TEXT,
    DATA,
    LIST,
    ENUM,
    STRUCT,
    INTERFACE,
    ANY_POINTER,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ce23dcd2d7b00c9b, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Annotation {
  Annotation() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f1c8950dab257542, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

typedef ::capnp::schemas::ElementSize_d1958f7dba521926 ElementSize;

struct CapnpVersion {
  CapnpVersion() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d85d305b7d839963, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CodeGeneratorRequest {
  CodeGeneratorRequest() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct RequestedFile;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bfc546f6210ad7ce, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CodeGeneratorRequest::RequestedFile {
  RequestedFile() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Import;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cfea0eb02e810062, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CodeGeneratorRequest::RequestedFile::Import {
  Import() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ae504193122357e5, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Node::Reader {
public:
  typedef Node Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::uint64_t getId() const;

  inline bool hasDisplayName() const;
  inline  ::capnp::Text::Reader getDisplayName() const;

  inline  ::uint32_t getDisplayNamePrefixLength() const;

  inline  ::uint64_t getScopeId() const;

  inline bool hasNestedNodes() const;
  inline  ::capnp::List< ::capnp::schema::Node::NestedNode>::Reader getNestedNodes() const;

  inline bool hasAnnotations() const;
  inline  ::capnp::List< ::capnp::schema::Annotation>::Reader getAnnotations() const;

  inline bool isFile() const;
  inline  ::capnp::Void getFile() const;

  inline bool isStruct() const;
  inline typename Struct::Reader getStruct() const;

  inline bool isEnum() const;
  inline typename Enum::Reader getEnum() const;

  inline bool isInterface() const;
  inline typename Interface::Reader getInterface() const;

  inline bool isConst() const;
  inline typename Const::Reader getConst() const;

  inline bool isAnnotation() const;
  inline typename Annotation::Reader getAnnotation() const;

  inline bool hasParameters() const;
  inline  ::capnp::List< ::capnp::schema::Node::Parameter>::Reader getParameters() const;

  inline bool getIsGeneric() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Node::Builder {
public:
  typedef Node Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline bool hasDisplayName();
  inline  ::capnp::Text::Builder getDisplayName();
  inline void setDisplayName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initDisplayName(unsigned int size);
  inline void adoptDisplayName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownDisplayName();

  inline  ::uint32_t getDisplayNamePrefixLength();
  inline void setDisplayNamePrefixLength( ::uint32_t value);

  inline  ::uint64_t getScopeId();
  inline void setScopeId( ::uint64_t value);

  inline bool hasNestedNodes();
  inline  ::capnp::List< ::capnp::schema::Node::NestedNode>::Builder getNestedNodes();
  inline void setNestedNodes( ::capnp::List< ::capnp::schema::Node::NestedNode>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Node::NestedNode>::Builder initNestedNodes(unsigned int size);
  inline void adoptNestedNodes(::capnp::Orphan< ::capnp::List< ::capnp::schema::Node::NestedNode>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Node::NestedNode>> disownNestedNodes();

  inline bool hasAnnotations();
  inline  ::capnp::List< ::capnp::schema::Annotation>::Builder getAnnotations();
  inline void setAnnotations( ::capnp::List< ::capnp::schema::Annotation>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Annotation>::Builder initAnnotations(unsigned int size);
  inline void adoptAnnotations(::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>> disownAnnotations();

  inline bool isFile();
  inline  ::capnp::Void getFile();
  inline void setFile( ::capnp::Void value = ::capnp::VOID);

  inline bool isStruct();
  inline typename Struct::Builder getStruct();
  inline typename Struct::Builder initStruct();

  inline bool isEnum();
  inline typename Enum::Builder getEnum();
  inline typename Enum::Builder initEnum();

  inline bool isInterface();
  inline typename Interface::Builder getInterface();
  inline typename Interface::Builder initInterface();

  inline bool isConst();
  inline typename Const::Builder getConst();
  inline typename Const::Builder initConst();

  inline bool isAnnotation();
  inline typename Annotation::Builder getAnnotation();
  inline typename Annotation::Builder initAnnotation();

  inline bool hasParameters();
  inline  ::capnp::List< ::capnp::schema::Node::Parameter>::Builder getParameters();
  inline void setParameters( ::capnp::List< ::capnp::schema::Node::Parameter>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Node::Parameter>::Builder initParameters(unsigned int size);
  inline void adoptParameters(::capnp::Orphan< ::capnp::List< ::capnp::schema::Node::Parameter>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Node::Parameter>> disownParameters();

  inline bool getIsGeneric();
  inline void setIsGeneric(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Node::Pipeline {
public:
  typedef Node Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Node::Parameter::Reader {
public:
  typedef Parameter Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Node::Parameter::Builder {
public:
  typedef Parameter Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Node::Parameter::Pipeline {
public:
  typedef Parameter Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Node::NestedNode::Reader {
public:
  typedef NestedNode Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::uint64_t getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Node::NestedNode::Builder {
public:
  typedef NestedNode Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Node::NestedNode::Pipeline {
public:
  typedef NestedNode Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Node::Struct::Reader {
public:
  typedef Struct Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getDataWordCount() const;

  inline  ::uint16_t getPointerCount() const;

  inline  ::capnp::schema::ElementSize getPreferredListEncoding() const;

  inline bool getIsGroup() const;

  inline  ::uint16_t getDiscriminantCount() const;

  inline  ::uint32_t getDiscriminantOffset() const;

  inline bool hasFields() const;
  inline  ::capnp::List< ::capnp::schema::Field>::Reader getFields() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Node::Struct::Builder {
public:
  typedef Struct Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getDataWordCount();
  inline void setDataWordCount( ::uint16_t value);

  inline  ::uint16_t getPointerCount();
  inline void setPointerCount( ::uint16_t value);

  inline  ::capnp::schema::ElementSize getPreferredListEncoding();
  inline void setPreferredListEncoding( ::capnp::schema::ElementSize value);

  inline bool getIsGroup();
  inline void setIsGroup(bool value);

  inline  ::uint16_t getDiscriminantCount();
  inline void setDiscriminantCount( ::uint16_t value);

  inline  ::uint32_t getDiscriminantOffset();
  inline void setDiscriminantOffset( ::uint32_t value);

  inline bool hasFields();
  inline  ::capnp::List< ::capnp::schema::Field>::Builder getFields();
  inline void setFields( ::capnp::List< ::capnp::schema::Field>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Field>::Builder initFields(unsigned int size);
  inline void adoptFields(::capnp::Orphan< ::capnp::List< ::capnp::schema::Field>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Field>> disownFields();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Node::Struct::Pipeline {
public:
  typedef Struct Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Node::Enum::Reader {
public:
  typedef Enum Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEnumerants() const;
  inline  ::capnp::List< ::capnp::schema::Enumerant>::Reader getEnumerants() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Node::Enum::Builder {
public:
  typedef Enum Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEnumerants();
  inline  ::capnp::List< ::capnp::schema::Enumerant>::Builder getEnumerants();
  inline void setEnumerants( ::capnp::List< ::capnp::schema::Enumerant>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Enumerant>::Builder initEnumerants(unsigned int size);
  inline void adoptEnumerants(::capnp::Orphan< ::capnp::List< ::capnp::schema::Enumerant>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Enumerant>> disownEnumerants();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Node::Enum::Pipeline {
public:
  typedef Enum Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Node::Interface::Reader {
public:
  typedef Interface Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMethods() const;
  inline  ::capnp::List< ::capnp::schema::Method>::Reader getMethods() const;

  inline bool hasSuperclasses() const;
  inline  ::capnp::List< ::capnp::schema::Superclass>::Reader getSuperclasses() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Node::Interface::Builder {
public:
  typedef Interface Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMethods();
  inline  ::capnp::List< ::capnp::schema::Method>::Builder getMethods();
  inline void setMethods( ::capnp::List< ::capnp::schema::Method>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Method>::Builder initMethods(unsigned int size);
  inline void adoptMethods(::capnp::Orphan< ::capnp::List< ::capnp::schema::Method>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Method>> disownMethods();

  inline bool hasSuperclasses();
  inline  ::capnp::List< ::capnp::schema::Superclass>::Builder getSuperclasses();
  inline void setSuperclasses( ::capnp::List< ::capnp::schema::Superclass>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Superclass>::Builder initSuperclasses(unsigned int size);
  inline void adoptSuperclasses(::capnp::Orphan< ::capnp::List< ::capnp::schema::Superclass>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Superclass>> disownSuperclasses();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Node::Interface::Pipeline {
public:
  typedef Interface Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Node::Const::Reader {
public:
  typedef Const Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasType() const;
  inline  ::capnp::schema::Type::Reader getType() const;

  inline bool hasValue() const;
  inline  ::capnp::schema::Value::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Node::Const::Builder {
public:
  typedef Const Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasType();
  inline  ::capnp::schema::Type::Builder getType();
  inline void setType( ::capnp::schema::Type::Reader value);
  inline  ::capnp::schema::Type::Builder initType();
  inline void adoptType(::capnp::Orphan< ::capnp::schema::Type>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Type> disownType();

  inline bool hasValue();
  inline  ::capnp::schema::Value::Builder getValue();
  inline void setValue( ::capnp::schema::Value::Reader value);
  inline  ::capnp::schema::Value::Builder initValue();
  inline void adoptValue(::capnp::Orphan< ::capnp::schema::Value>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Value> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Node::Const::Pipeline {
public:
  typedef Const Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::schema::Type::Pipeline getType();
  inline  ::capnp::schema::Value::Pipeline getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Node::Annotation::Reader {
public:
  typedef Annotation Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasType() const;
  inline  ::capnp::schema::Type::Reader getType() const;

  inline bool getTargetsFile() const;

  inline bool getTargetsConst() const;

  inline bool getTargetsEnum() const;

  inline bool getTargetsEnumerant() const;

  inline bool getTargetsStruct() const;

  inline bool getTargetsField() const;

  inline bool getTargetsUnion() const;

  inline bool getTargetsGroup() const;

  inline bool getTargetsInterface() const;

  inline bool getTargetsMethod() const;

  inline bool getTargetsParam() const;

  inline bool getTargetsAnnotation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Node::Annotation::Builder {
public:
  typedef Annotation Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasType();
  inline  ::capnp::schema::Type::Builder getType();
  inline void setType( ::capnp::schema::Type::Reader value);
  inline  ::capnp::schema::Type::Builder initType();
  inline void adoptType(::capnp::Orphan< ::capnp::schema::Type>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Type> disownType();

  inline bool getTargetsFile();
  inline void setTargetsFile(bool value);

  inline bool getTargetsConst();
  inline void setTargetsConst(bool value);

  inline bool getTargetsEnum();
  inline void setTargetsEnum(bool value);

  inline bool getTargetsEnumerant();
  inline void setTargetsEnumerant(bool value);

  inline bool getTargetsStruct();
  inline void setTargetsStruct(bool value);

  inline bool getTargetsField();
  inline void setTargetsField(bool value);

  inline bool getTargetsUnion();
  inline void setTargetsUnion(bool value);

  inline bool getTargetsGroup();
  inline void setTargetsGroup(bool value);

  inline bool getTargetsInterface();
  inline void setTargetsInterface(bool value);

  inline bool getTargetsMethod();
  inline void setTargetsMethod(bool value);

  inline bool getTargetsParam();
  inline void setTargetsParam(bool value);

  inline bool getTargetsAnnotation();
  inline void setTargetsAnnotation(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Node::Annotation::Pipeline {
public:
  typedef Annotation Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::schema::Type::Pipeline getType();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Field::Reader {
public:
  typedef Field Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::uint16_t getCodeOrder() const;

  inline bool hasAnnotations() const;
  inline  ::capnp::List< ::capnp::schema::Annotation>::Reader getAnnotations() const;

  inline  ::uint16_t getDiscriminantValue() const;

  inline bool isSlot() const;
  inline typename Slot::Reader getSlot() const;

  inline bool isGroup() const;
  inline typename Group::Reader getGroup() const;

  inline typename Ordinal::Reader getOrdinal() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Field::Builder {
public:
  typedef Field Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::uint16_t getCodeOrder();
  inline void setCodeOrder( ::uint16_t value);

  inline bool hasAnnotations();
  inline  ::capnp::List< ::capnp::schema::Annotation>::Builder getAnnotations();
  inline void setAnnotations( ::capnp::List< ::capnp::schema::Annotation>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Annotation>::Builder initAnnotations(unsigned int size);
  inline void adoptAnnotations(::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>> disownAnnotations();

  inline  ::uint16_t getDiscriminantValue();
  inline void setDiscriminantValue( ::uint16_t value);

  inline bool isSlot();
  inline typename Slot::Builder getSlot();
  inline typename Slot::Builder initSlot();

  inline bool isGroup();
  inline typename Group::Builder getGroup();
  inline typename Group::Builder initGroup();

  inline typename Ordinal::Builder getOrdinal();
  inline typename Ordinal::Builder initOrdinal();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Field::Pipeline {
public:
  typedef Field Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Ordinal::Pipeline getOrdinal();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Field::Slot::Reader {
public:
  typedef Slot Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getOffset() const;

  inline bool hasType() const;
  inline  ::capnp::schema::Type::Reader getType() const;

  inline bool hasDefaultValue() const;
  inline  ::capnp::schema::Value::Reader getDefaultValue() const;

  inline bool getHadExplicitDefault() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Field::Slot::Builder {
public:
  typedef Slot Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getOffset();
  inline void setOffset( ::uint32_t value);

  inline bool hasType();
  inline  ::capnp::schema::Type::Builder getType();
  inline void setType( ::capnp::schema::Type::Reader value);
  inline  ::capnp::schema::Type::Builder initType();
  inline void adoptType(::capnp::Orphan< ::capnp::schema::Type>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Type> disownType();

  inline bool hasDefaultValue();
  inline  ::capnp::schema::Value::Builder getDefaultValue();
  inline void setDefaultValue( ::capnp::schema::Value::Reader value);
  inline  ::capnp::schema::Value::Builder initDefaultValue();
  inline void adoptDefaultValue(::capnp::Orphan< ::capnp::schema::Value>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Value> disownDefaultValue();

  inline bool getHadExplicitDefault();
  inline void setHadExplicitDefault(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Field::Slot::Pipeline {
public:
  typedef Slot Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::schema::Type::Pipeline getType();
  inline  ::capnp::schema::Value::Pipeline getDefaultValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Field::Group::Reader {
public:
  typedef Group Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTypeId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Field::Group::Builder {
public:
  typedef Group Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTypeId();
  inline void setTypeId( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Field::Group::Pipeline {
public:
  typedef Group Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Field::Ordinal::Reader {
public:
  typedef Ordinal Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isImplicit() const;
  inline  ::capnp::Void getImplicit() const;

  inline bool isExplicit() const;
  inline  ::uint16_t getExplicit() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Field::Ordinal::Builder {
public:
  typedef Ordinal Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isImplicit();
  inline  ::capnp::Void getImplicit();
  inline void setImplicit( ::capnp::Void value = ::capnp::VOID);

  inline bool isExplicit();
  inline  ::uint16_t getExplicit();
  inline void setExplicit( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Field::Ordinal::Pipeline {
public:
  typedef Ordinal Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Enumerant::Reader {
public:
  typedef Enumerant Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::uint16_t getCodeOrder() const;

  inline bool hasAnnotations() const;
  inline  ::capnp::List< ::capnp::schema::Annotation>::Reader getAnnotations() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Enumerant::Builder {
public:
  typedef Enumerant Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::uint16_t getCodeOrder();
  inline void setCodeOrder( ::uint16_t value);

  inline bool hasAnnotations();
  inline  ::capnp::List< ::capnp::schema::Annotation>::Builder getAnnotations();
  inline void setAnnotations( ::capnp::List< ::capnp::schema::Annotation>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Annotation>::Builder initAnnotations(unsigned int size);
  inline void adoptAnnotations(::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>> disownAnnotations();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Enumerant::Pipeline {
public:
  typedef Enumerant Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Superclass::Reader {
public:
  typedef Superclass Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId() const;

  inline bool hasBrand() const;
  inline  ::capnp::schema::Brand::Reader getBrand() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Superclass::Builder {
public:
  typedef Superclass Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline bool hasBrand();
  inline  ::capnp::schema::Brand::Builder getBrand();
  inline void setBrand( ::capnp::schema::Brand::Reader value);
  inline  ::capnp::schema::Brand::Builder initBrand();
  inline void adoptBrand(::capnp::Orphan< ::capnp::schema::Brand>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Brand> disownBrand();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Superclass::Pipeline {
public:
  typedef Superclass Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::schema::Brand::Pipeline getBrand();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Method::Reader {
public:
  typedef Method Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::uint16_t getCodeOrder() const;

  inline  ::uint64_t getParamStructType() const;

  inline  ::uint64_t getResultStructType() const;

  inline bool hasAnnotations() const;
  inline  ::capnp::List< ::capnp::schema::Annotation>::Reader getAnnotations() const;

  inline bool hasParamBrand() const;
  inline  ::capnp::schema::Brand::Reader getParamBrand() const;

  inline bool hasResultBrand() const;
  inline  ::capnp::schema::Brand::Reader getResultBrand() const;

  inline bool hasImplicitParameters() const;
  inline  ::capnp::List< ::capnp::schema::Node::Parameter>::Reader getImplicitParameters() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Method::Builder {
public:
  typedef Method Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::uint16_t getCodeOrder();
  inline void setCodeOrder( ::uint16_t value);

  inline  ::uint64_t getParamStructType();
  inline void setParamStructType( ::uint64_t value);

  inline  ::uint64_t getResultStructType();
  inline void setResultStructType( ::uint64_t value);

  inline bool hasAnnotations();
  inline  ::capnp::List< ::capnp::schema::Annotation>::Builder getAnnotations();
  inline void setAnnotations( ::capnp::List< ::capnp::schema::Annotation>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Annotation>::Builder initAnnotations(unsigned int size);
  inline void adoptAnnotations(::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>> disownAnnotations();

  inline bool hasParamBrand();
  inline  ::capnp::schema::Brand::Builder getParamBrand();
  inline void setParamBrand( ::capnp::schema::Brand::Reader value);
  inline  ::capnp::schema::Brand::Builder initParamBrand();
  inline void adoptParamBrand(::capnp::Orphan< ::capnp::schema::Brand>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Brand> disownParamBrand();

  inline bool hasResultBrand();
  inline  ::capnp::schema::Brand::Builder getResultBrand();
  inline void setResultBrand( ::capnp::schema::Brand::Reader value);
  inline  ::capnp::schema::Brand::Builder initResultBrand();
  inline void adoptResultBrand(::capnp::Orphan< ::capnp::schema::Brand>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Brand> disownResultBrand();

  inline bool hasImplicitParameters();
  inline  ::capnp::List< ::capnp::schema::Node::Parameter>::Builder getImplicitParameters();
  inline void setImplicitParameters( ::capnp::List< ::capnp::schema::Node::Parameter>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Node::Parameter>::Builder initImplicitParameters(unsigned int size);
  inline void adoptImplicitParameters(::capnp::Orphan< ::capnp::List< ::capnp::schema::Node::Parameter>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Node::Parameter>> disownImplicitParameters();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Method::Pipeline {
public:
  typedef Method Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::schema::Brand::Pipeline getParamBrand();
  inline  ::capnp::schema::Brand::Pipeline getResultBrand();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Type::Reader {
public:
  typedef Type Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isVoid() const;
  inline  ::capnp::Void getVoid() const;

  inline bool isBool() const;
  inline  ::capnp::Void getBool() const;

  inline bool isInt8() const;
  inline  ::capnp::Void getInt8() const;

  inline bool isInt16() const;
  inline  ::capnp::Void getInt16() const;

  inline bool isInt32() const;
  inline  ::capnp::Void getInt32() const;

  inline bool isInt64() const;
  inline  ::capnp::Void getInt64() const;

  inline bool isUint8() const;
  inline  ::capnp::Void getUint8() const;

  inline bool isUint16() const;
  inline  ::capnp::Void getUint16() const;

  inline bool isUint32() const;
  inline  ::capnp::Void getUint32() const;

  inline bool isUint64() const;
  inline  ::capnp::Void getUint64() const;

  inline bool isFloat32() const;
  inline  ::capnp::Void getFloat32() const;

  inline bool isFloat64() const;
  inline  ::capnp::Void getFloat64() const;

  inline bool isText() const;
  inline  ::capnp::Void getText() const;

  inline bool isData() const;
  inline  ::capnp::Void getData() const;

  inline bool isList() const;
  inline typename List::Reader getList() const;

  inline bool isEnum() const;
  inline typename Enum::Reader getEnum() const;

  inline bool isStruct() const;
  inline typename Struct::Reader getStruct() const;

  inline bool isInterface() const;
  inline typename Interface::Reader getInterface() const;

  inline bool isAnyPointer() const;
  inline typename AnyPointer::Reader getAnyPointer() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Type::Builder {
public:
  typedef Type Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isVoid();
  inline  ::capnp::Void getVoid();
  inline void setVoid( ::capnp::Void value = ::capnp::VOID);

  inline bool isBool();
  inline  ::capnp::Void getBool();
  inline void setBool( ::capnp::Void value = ::capnp::VOID);

  inline bool isInt8();
  inline  ::capnp::Void getInt8();
  inline void setInt8( ::capnp::Void value = ::capnp::VOID);

  inline bool isInt16();
  inline  ::capnp::Void getInt16();
  inline void setInt16( ::capnp::Void value = ::capnp::VOID);

  inline bool isInt32();
  inline  ::capnp::Void getInt32();
  inline void setInt32( ::capnp::Void value = ::capnp::VOID);

  inline bool isInt64();
  inline  ::capnp::Void getInt64();
  inline void setInt64( ::capnp::Void value = ::capnp::VOID);

  inline bool isUint8();
  inline  ::capnp::Void getUint8();
  inline void setUint8( ::capnp::Void value = ::capnp::VOID);

  inline bool isUint16();
  inline  ::capnp::Void getUint16();
  inline void setUint16( ::capnp::Void value = ::capnp::VOID);

  inline bool isUint32();
  inline  ::capnp::Void getUint32();
  inline void setUint32( ::capnp::Void value = ::capnp::VOID);

  inline bool isUint64();
  inline  ::capnp::Void getUint64();
  inline void setUint64( ::capnp::Void value = ::capnp::VOID);

  inline bool isFloat32();
  inline  ::capnp::Void getFloat32();
  inline void setFloat32( ::capnp::Void value = ::capnp::VOID);

  inline bool isFloat64();
  inline  ::capnp::Void getFloat64();
  inline void setFloat64( ::capnp::Void value = ::capnp::VOID);

  inline bool isText();
  inline  ::capnp::Void getText();
  inline void setText( ::capnp::Void value = ::capnp::VOID);

  inline bool isData();
  inline  ::capnp::Void getData();
  inline void setData( ::capnp::Void value = ::capnp::VOID);

  inline bool isList();
  inline typename List::Builder getList();
  inline typename List::Builder initList();

  inline bool isEnum();
  inline typename Enum::Builder getEnum();
  inline typename Enum::Builder initEnum();

  inline bool isStruct();
  inline typename Struct::Builder getStruct();
  inline typename Struct::Builder initStruct();

  inline bool isInterface();
  inline typename Interface::Builder getInterface();
  inline typename Interface::Builder initInterface();

  inline bool isAnyPointer();
  inline typename AnyPointer::Builder getAnyPointer();
  inline typename AnyPointer::Builder initAnyPointer();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Type::Pipeline {
public:
  typedef Type Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Type::List::Reader {
public:
  typedef List Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasElementType() const;
  inline  ::capnp::schema::Type::Reader getElementType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Type::List::Builder {
public:
  typedef List Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasElementType();
  inline  ::capnp::schema::Type::Builder getElementType();
  inline void setElementType( ::capnp::schema::Type::Reader value);
  inline  ::capnp::schema::Type::Builder initElementType();
  inline void adoptElementType(::capnp::Orphan< ::capnp::schema::Type>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Type> disownElementType();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Type::List::Pipeline {
public:
  typedef List Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::schema::Type::Pipeline getElementType();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Type::Enum::Reader {
public:
  typedef Enum Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTypeId() const;

  inline bool hasBrand() const;
  inline  ::capnp::schema::Brand::Reader getBrand() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Type::Enum::Builder {
public:
  typedef Enum Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTypeId();
  inline void setTypeId( ::uint64_t value);

  inline bool hasBrand();
  inline  ::capnp::schema::Brand::Builder getBrand();
  inline void setBrand( ::capnp::schema::Brand::Reader value);
  inline  ::capnp::schema::Brand::Builder initBrand();
  inline void adoptBrand(::capnp::Orphan< ::capnp::schema::Brand>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Brand> disownBrand();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Type::Enum::Pipeline {
public:
  typedef Enum Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::schema::Brand::Pipeline getBrand();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Type::Struct::Reader {
public:
  typedef Struct Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTypeId() const;

  inline bool hasBrand() const;
  inline  ::capnp::schema::Brand::Reader getBrand() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Type::Struct::Builder {
public:
  typedef Struct Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTypeId();
  inline void setTypeId( ::uint64_t value);

  inline bool hasBrand();
  inline  ::capnp::schema::Brand::Builder getBrand();
  inline void setBrand( ::capnp::schema::Brand::Reader value);
  inline  ::capnp::schema::Brand::Builder initBrand();
  inline void adoptBrand(::capnp::Orphan< ::capnp::schema::Brand>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Brand> disownBrand();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Type::Struct::Pipeline {
public:
  typedef Struct Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::schema::Brand::Pipeline getBrand();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Type::Interface::Reader {
public:
  typedef Interface Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTypeId() const;

  inline bool hasBrand() const;
  inline  ::capnp::schema::Brand::Reader getBrand() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Type::Interface::Builder {
public:
  typedef Interface Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTypeId();
  inline void setTypeId( ::uint64_t value);

  inline bool hasBrand();
  inline  ::capnp::schema::Brand::Builder getBrand();
  inline void setBrand( ::capnp::schema::Brand::Reader value);
  inline  ::capnp::schema::Brand::Builder initBrand();
  inline void adoptBrand(::capnp::Orphan< ::capnp::schema::Brand>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Brand> disownBrand();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Type::Interface::Pipeline {
public:
  typedef Interface Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::schema::Brand::Pipeline getBrand();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Type::AnyPointer::Reader {
public:
  typedef AnyPointer Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnconstrained() const;
  inline typename Unconstrained::Reader getUnconstrained() const;

  inline bool isParameter() const;
  inline typename Parameter::Reader getParameter() const;

  inline bool isImplicitMethodParameter() const;
  inline typename ImplicitMethodParameter::Reader getImplicitMethodParameter() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Type::AnyPointer::Builder {
public:
  typedef AnyPointer Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnconstrained();
  inline typename Unconstrained::Builder getUnconstrained();
  inline typename Unconstrained::Builder initUnconstrained();

  inline bool isParameter();
  inline typename Parameter::Builder getParameter();
  inline typename Parameter::Builder initParameter();

  inline bool isImplicitMethodParameter();
  inline typename ImplicitMethodParameter::Builder getImplicitMethodParameter();
  inline typename ImplicitMethodParameter::Builder initImplicitMethodParameter();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Type::AnyPointer::Pipeline {
public:
  typedef AnyPointer Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Type::AnyPointer::Unconstrained::Reader {
public:
  typedef Unconstrained Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isAnyKind() const;
  inline  ::capnp::Void getAnyKind() const;

  inline bool isStruct() const;
  inline  ::capnp::Void getStruct() const;

  inline bool isList() const;
  inline  ::capnp::Void getList() const;

  inline bool isCapability() const;
  inline  ::capnp::Void getCapability() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Type::AnyPointer::Unconstrained::Builder {
public:
  typedef Unconstrained Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isAnyKind();
  inline  ::capnp::Void getAnyKind();
  inline void setAnyKind( ::capnp::Void value = ::capnp::VOID);

  inline bool isStruct();
  inline  ::capnp::Void getStruct();
  inline void setStruct( ::capnp::Void value = ::capnp::VOID);

  inline bool isList();
  inline  ::capnp::Void getList();
  inline void setList( ::capnp::Void value = ::capnp::VOID);

  inline bool isCapability();
  inline  ::capnp::Void getCapability();
  inline void setCapability( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Type::AnyPointer::Unconstrained::Pipeline {
public:
  typedef Unconstrained Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Type::AnyPointer::Parameter::Reader {
public:
  typedef Parameter Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getScopeId() const;

  inline  ::uint16_t getParameterIndex() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Type::AnyPointer::Parameter::Builder {
public:
  typedef Parameter Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getScopeId();
  inline void setScopeId( ::uint64_t value);

  inline  ::uint16_t getParameterIndex();
  inline void setParameterIndex( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Type::AnyPointer::Parameter::Pipeline {
public:
  typedef Parameter Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Type::AnyPointer::ImplicitMethodParameter::Reader {
public:
  typedef ImplicitMethodParameter Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getParameterIndex() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Type::AnyPointer::ImplicitMethodParameter::Builder {
public:
  typedef ImplicitMethodParameter Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getParameterIndex();
  inline void setParameterIndex( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Type::AnyPointer::ImplicitMethodParameter::Pipeline {
public:
  typedef ImplicitMethodParameter Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Brand::Reader {
public:
  typedef Brand Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasScopes() const;
  inline  ::capnp::List< ::capnp::schema::Brand::Scope>::Reader getScopes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Brand::Builder {
public:
  typedef Brand Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasScopes();
  inline  ::capnp::List< ::capnp::schema::Brand::Scope>::Builder getScopes();
  inline void setScopes( ::capnp::List< ::capnp::schema::Brand::Scope>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Brand::Scope>::Builder initScopes(unsigned int size);
  inline void adoptScopes(::capnp::Orphan< ::capnp::List< ::capnp::schema::Brand::Scope>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Brand::Scope>> disownScopes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Brand::Pipeline {
public:
  typedef Brand Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Brand::Scope::Reader {
public:
  typedef Scope Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::uint64_t getScopeId() const;

  inline bool isBind() const;
  inline bool hasBind() const;
  inline  ::capnp::List< ::capnp::schema::Brand::Binding>::Reader getBind() const;

  inline bool isInherit() const;
  inline  ::capnp::Void getInherit() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Brand::Scope::Builder {
public:
  typedef Scope Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::uint64_t getScopeId();
  inline void setScopeId( ::uint64_t value);

  inline bool isBind();
  inline bool hasBind();
  inline  ::capnp::List< ::capnp::schema::Brand::Binding>::Builder getBind();
  inline void setBind( ::capnp::List< ::capnp::schema::Brand::Binding>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Brand::Binding>::Builder initBind(unsigned int size);
  inline void adoptBind(::capnp::Orphan< ::capnp::List< ::capnp::schema::Brand::Binding>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Brand::Binding>> disownBind();

  inline bool isInherit();
  inline  ::capnp::Void getInherit();
  inline void setInherit( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Brand::Scope::Pipeline {
public:
  typedef Scope Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Brand::Binding::Reader {
public:
  typedef Binding Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnbound() const;
  inline  ::capnp::Void getUnbound() const;

  inline bool isType() const;
  inline bool hasType() const;
  inline  ::capnp::schema::Type::Reader getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Brand::Binding::Builder {
public:
  typedef Binding Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnbound();
  inline  ::capnp::Void getUnbound();
  inline void setUnbound( ::capnp::Void value = ::capnp::VOID);

  inline bool isType();
  inline bool hasType();
  inline  ::capnp::schema::Type::Builder getType();
  inline void setType( ::capnp::schema::Type::Reader value);
  inline  ::capnp::schema::Type::Builder initType();
  inline void adoptType(::capnp::Orphan< ::capnp::schema::Type>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Type> disownType();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Brand::Binding::Pipeline {
public:
  typedef Binding Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Value::Reader {
public:
  typedef Value Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isVoid() const;
  inline  ::capnp::Void getVoid() const;

  inline bool isBool() const;
  inline bool getBool() const;

  inline bool isInt8() const;
  inline  ::int8_t getInt8() const;

  inline bool isInt16() const;
  inline  ::int16_t getInt16() const;

  inline bool isInt32() const;
  inline  ::int32_t getInt32() const;

  inline bool isInt64() const;
  inline  ::int64_t getInt64() const;

  inline bool isUint8() const;
  inline  ::uint8_t getUint8() const;

  inline bool isUint16() const;
  inline  ::uint16_t getUint16() const;

  inline bool isUint32() const;
  inline  ::uint32_t getUint32() const;

  inline bool isUint64() const;
  inline  ::uint64_t getUint64() const;

  inline bool isFloat32() const;
  inline float getFloat32() const;

  inline bool isFloat64() const;
  inline double getFloat64() const;

  inline bool isText() const;
  inline bool hasText() const;
  inline  ::capnp::Text::Reader getText() const;

  inline bool isData() const;
  inline bool hasData() const;
  inline  ::capnp::Data::Reader getData() const;

  inline bool isList() const;
  inline bool hasList() const;
  inline ::capnp::AnyPointer::Reader getList() const;

  inline bool isEnum() const;
  inline  ::uint16_t getEnum() const;

  inline bool isStruct() const;
  inline bool hasStruct() const;
  inline ::capnp::AnyPointer::Reader getStruct() const;

  inline bool isInterface() const;
  inline  ::capnp::Void getInterface() const;

  inline bool isAnyPointer() const;
  inline bool hasAnyPointer() const;
  inline ::capnp::AnyPointer::Reader getAnyPointer() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Value::Builder {
public:
  typedef Value Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isVoid();
  inline  ::capnp::Void getVoid();
  inline void setVoid( ::capnp::Void value = ::capnp::VOID);

  inline bool isBool();
  inline bool getBool();
  inline void setBool(bool value);

  inline bool isInt8();
  inline  ::int8_t getInt8();
  inline void setInt8( ::int8_t value);

  inline bool isInt16();
  inline  ::int16_t getInt16();
  inline void setInt16( ::int16_t value);

  inline bool isInt32();
  inline  ::int32_t getInt32();
  inline void setInt32( ::int32_t value);

  inline bool isInt64();
  inline  ::int64_t getInt64();
  inline void setInt64( ::int64_t value);

  inline bool isUint8();
  inline  ::uint8_t getUint8();
  inline void setUint8( ::uint8_t value);

  inline bool isUint16();
  inline  ::uint16_t getUint16();
  inline void setUint16( ::uint16_t value);

  inline bool isUint32();
  inline  ::uint32_t getUint32();
  inline void setUint32( ::uint32_t value);

  inline bool isUint64();
  inline  ::uint64_t getUint64();
  inline void setUint64( ::uint64_t value);

  inline bool isFloat32();
  inline float getFloat32();
  inline void setFloat32(float value);

  inline bool isFloat64();
  inline double getFloat64();
  inline void setFloat64(double value);

  inline bool isText();
  inline bool hasText();
  inline  ::capnp::Text::Builder getText();
  inline void setText( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText(unsigned int size);
  inline void adoptText(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText();

  inline bool isData();
  inline bool hasData();
  inline  ::capnp::Data::Builder getData();
  inline void setData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownData();

  inline bool isList();
  inline bool hasList();
  inline ::capnp::AnyPointer::Builder getList();
  inline ::capnp::AnyPointer::Builder initList();

  inline bool isEnum();
  inline  ::uint16_t getEnum();
  inline void setEnum( ::uint16_t value);

  inline bool isStruct();
  inline bool hasStruct();
  inline ::capnp::AnyPointer::Builder getStruct();
  inline ::capnp::AnyPointer::Builder initStruct();

  inline bool isInterface();
  inline  ::capnp::Void getInterface();
  inline void setInterface( ::capnp::Void value = ::capnp::VOID);

  inline bool isAnyPointer();
  inline bool hasAnyPointer();
  inline ::capnp::AnyPointer::Builder getAnyPointer();
  inline ::capnp::AnyPointer::Builder initAnyPointer();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Value::Pipeline {
public:
  typedef Value Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Annotation::Reader {
public:
  typedef Annotation Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId() const;

  inline bool hasValue() const;
  inline  ::capnp::schema::Value::Reader getValue() const;

  inline bool hasBrand() const;
  inline  ::capnp::schema::Brand::Reader getBrand() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Annotation::Builder {
public:
  typedef Annotation Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline bool hasValue();
  inline  ::capnp::schema::Value::Builder getValue();
  inline void setValue( ::capnp::schema::Value::Reader value);
  inline  ::capnp::schema::Value::Builder initValue();
  inline void adoptValue(::capnp::Orphan< ::capnp::schema::Value>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Value> disownValue();

  inline bool hasBrand();
  inline  ::capnp::schema::Brand::Builder getBrand();
  inline void setBrand( ::capnp::schema::Brand::Reader value);
  inline  ::capnp::schema::Brand::Builder initBrand();
  inline void adoptBrand(::capnp::Orphan< ::capnp::schema::Brand>&& value);
  inline ::capnp::Orphan< ::capnp::schema::Brand> disownBrand();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Annotation::Pipeline {
public:
  typedef Annotation Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::schema::Value::Pipeline getValue();
  inline  ::capnp::schema::Brand::Pipeline getBrand();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CapnpVersion::Reader {
public:
  typedef CapnpVersion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getMajor() const;

  inline  ::uint8_t getMinor() const;

  inline  ::uint8_t getMicro() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CapnpVersion::Builder {
public:
  typedef CapnpVersion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getMajor();
  inline void setMajor( ::uint16_t value);

  inline  ::uint8_t getMinor();
  inline void setMinor( ::uint8_t value);

  inline  ::uint8_t getMicro();
  inline void setMicro( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CapnpVersion::Pipeline {
public:
  typedef CapnpVersion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CodeGeneratorRequest::Reader {
public:
  typedef CodeGeneratorRequest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNodes() const;
  inline  ::capnp::List< ::capnp::schema::Node>::Reader getNodes() const;

  inline bool hasRequestedFiles() const;
  inline  ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>::Reader getRequestedFiles() const;

  inline bool hasCapnpVersion() const;
  inline  ::capnp::schema::CapnpVersion::Reader getCapnpVersion() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CodeGeneratorRequest::Builder {
public:
  typedef CodeGeneratorRequest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNodes();
  inline  ::capnp::List< ::capnp::schema::Node>::Builder getNodes();
  inline void setNodes( ::capnp::List< ::capnp::schema::Node>::Reader value);
  inline  ::capnp::List< ::capnp::schema::Node>::Builder initNodes(unsigned int size);
  inline void adoptNodes(::capnp::Orphan< ::capnp::List< ::capnp::schema::Node>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Node>> disownNodes();

  inline bool hasRequestedFiles();
  inline  ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>::Builder getRequestedFiles();
  inline void setRequestedFiles( ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>::Reader value);
  inline  ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>::Builder initRequestedFiles(unsigned int size);
  inline void adoptRequestedFiles(::capnp::Orphan< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>> disownRequestedFiles();

  inline bool hasCapnpVersion();
  inline  ::capnp::schema::CapnpVersion::Builder getCapnpVersion();
  inline void setCapnpVersion( ::capnp::schema::CapnpVersion::Reader value);
  inline  ::capnp::schema::CapnpVersion::Builder initCapnpVersion();
  inline void adoptCapnpVersion(::capnp::Orphan< ::capnp::schema::CapnpVersion>&& value);
  inline ::capnp::Orphan< ::capnp::schema::CapnpVersion> disownCapnpVersion();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CodeGeneratorRequest::Pipeline {
public:
  typedef CodeGeneratorRequest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::schema::CapnpVersion::Pipeline getCapnpVersion();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CodeGeneratorRequest::RequestedFile::Reader {
public:
  typedef RequestedFile Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId() const;

  inline bool hasFilename() const;
  inline  ::capnp::Text::Reader getFilename() const;

  inline bool hasImports() const;
  inline  ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>::Reader getImports() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CodeGeneratorRequest::RequestedFile::Builder {
public:
  typedef RequestedFile Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline bool hasFilename();
  inline  ::capnp::Text::Builder getFilename();
  inline void setFilename( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFilename(unsigned int size);
  inline void adoptFilename(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFilename();

  inline bool hasImports();
  inline  ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>::Builder getImports();
  inline void setImports( ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>::Reader value);
  inline  ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>::Builder initImports(unsigned int size);
  inline void adoptImports(::capnp::Orphan< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>> disownImports();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CodeGeneratorRequest::RequestedFile::Pipeline {
public:
  typedef RequestedFile Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CodeGeneratorRequest::RequestedFile::Import::Reader {
public:
  typedef Import Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CodeGeneratorRequest::RequestedFile::Import::Builder {
public:
  typedef Import Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CodeGeneratorRequest::RequestedFile::Import::Pipeline {
public:
  typedef Import Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::capnp::schema::Node::Which Node::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline  ::capnp::schema::Node::Which Node::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Node::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Node::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Node::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Reader::hasDisplayName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Builder::hasDisplayName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Node::Reader::getDisplayName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Node::Builder::getDisplayName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Node::Builder::setDisplayName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Node::Builder::initDisplayName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Node::Builder::adoptDisplayName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Node::Builder::disownDisplayName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t Node::Reader::getDisplayNamePrefixLength() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Node::Builder::getDisplayNamePrefixLength() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Node::Builder::setDisplayNamePrefixLength( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Node::Reader::getScopeId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Node::Builder::getScopeId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Node::Builder::setScopeId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Reader::hasNestedNodes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Builder::hasNestedNodes() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Node::NestedNode>::Reader Node::Reader::getNestedNodes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::NestedNode>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Node::NestedNode>::Builder Node::Builder::getNestedNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::NestedNode>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Node::Builder::setNestedNodes( ::capnp::List< ::capnp::schema::Node::NestedNode>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::NestedNode>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Node::NestedNode>::Builder Node::Builder::initNestedNodes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::NestedNode>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Node::Builder::adoptNestedNodes(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Node::NestedNode>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::NestedNode>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Node::NestedNode>> Node::Builder::disownNestedNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::NestedNode>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Node::Reader::hasAnnotations() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Builder::hasAnnotations() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Annotation>::Reader Node::Reader::getAnnotations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Annotation>::Builder Node::Builder::getAnnotations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Node::Builder::setAnnotations( ::capnp::List< ::capnp::schema::Annotation>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Annotation>::Builder Node::Builder::initAnnotations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Node::Builder::adoptAnnotations(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>> Node::Builder::disownAnnotations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Node::Reader::isFile() const {
  return which() == Node::FILE;
}
inline bool Node::Builder::isFile() {
  return which() == Node::FILE;
}
inline  ::capnp::Void Node::Reader::getFile() const {
  KJ_IREQUIRE((which() == Node::FILE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Node::Builder::getFile() {
  KJ_IREQUIRE((which() == Node::FILE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Node::Builder::setFile( ::capnp::Void value) {
  _builder.setDataField<Node::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, Node::FILE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Reader::isStruct() const {
  return which() == Node::STRUCT;
}
inline bool Node::Builder::isStruct() {
  return which() == Node::STRUCT;
}
inline typename Node::Struct::Reader Node::Reader::getStruct() const {
  KJ_IREQUIRE((which() == Node::STRUCT),
              "Must check which() before get()ing a union member.");
  return typename Node::Struct::Reader(_reader);
}
inline typename Node::Struct::Builder Node::Builder::getStruct() {
  KJ_IREQUIRE((which() == Node::STRUCT),
              "Must check which() before get()ing a union member.");
  return typename Node::Struct::Builder(_builder);
}
inline typename Node::Struct::Builder Node::Builder::initStruct() {
  _builder.setDataField<Node::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, Node::STRUCT);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<7>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<12>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<13>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<224>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<15>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<8>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<3>() * ::capnp::POINTERS).clear();
  return typename Node::Struct::Builder(_builder);
}
inline bool Node::Reader::isEnum() const {
  return which() == Node::ENUM;
}
inline bool Node::Builder::isEnum() {
  return which() == Node::ENUM;
}
inline typename Node::Enum::Reader Node::Reader::getEnum() const {
  KJ_IREQUIRE((which() == Node::ENUM),
              "Must check which() before get()ing a union member.");
  return typename Node::Enum::Reader(_reader);
}
inline typename Node::Enum::Builder Node::Builder::getEnum() {
  KJ_IREQUIRE((which() == Node::ENUM),
              "Must check which() before get()ing a union member.");
  return typename Node::Enum::Builder(_builder);
}
inline typename Node::Enum::Builder Node::Builder::initEnum() {
  _builder.setDataField<Node::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, Node::ENUM);
  _builder.getPointerField(::capnp::bounded<3>() * ::capnp::POINTERS).clear();
  return typename Node::Enum::Builder(_builder);
}
inline bool Node::Reader::isInterface() const {
  return which() == Node::INTERFACE;
}
inline bool Node::Builder::isInterface() {
  return which() == Node::INTERFACE;
}
inline typename Node::Interface::Reader Node::Reader::getInterface() const {
  KJ_IREQUIRE((which() == Node::INTERFACE),
              "Must check which() before get()ing a union member.");
  return typename Node::Interface::Reader(_reader);
}
inline typename Node::Interface::Builder Node::Builder::getInterface() {
  KJ_IREQUIRE((which() == Node::INTERFACE),
              "Must check which() before get()ing a union member.");
  return typename Node::Interface::Builder(_builder);
}
inline typename Node::Interface::Builder Node::Builder::initInterface() {
  _builder.setDataField<Node::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, Node::INTERFACE);
  _builder.getPointerField(::capnp::bounded<3>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<4>() * ::capnp::POINTERS).clear();
  return typename Node::Interface::Builder(_builder);
}
inline bool Node::Reader::isConst() const {
  return which() == Node::CONST;
}
inline bool Node::Builder::isConst() {
  return which() == Node::CONST;
}
inline typename Node::Const::Reader Node::Reader::getConst() const {
  KJ_IREQUIRE((which() == Node::CONST),
              "Must check which() before get()ing a union member.");
  return typename Node::Const::Reader(_reader);
}
inline typename Node::Const::Builder Node::Builder::getConst() {
  KJ_IREQUIRE((which() == Node::CONST),
              "Must check which() before get()ing a union member.");
  return typename Node::Const::Builder(_builder);
}
inline typename Node::Const::Builder Node::Builder::initConst() {
  _builder.setDataField<Node::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, Node::CONST);
  _builder.getPointerField(::capnp::bounded<3>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<4>() * ::capnp::POINTERS).clear();
  return typename Node::Const::Builder(_builder);
}
inline bool Node::Reader::isAnnotation() const {
  return which() == Node::ANNOTATION;
}
inline bool Node::Builder::isAnnotation() {
  return which() == Node::ANNOTATION;
}
inline typename Node::Annotation::Reader Node::Reader::getAnnotation() const {
  KJ_IREQUIRE((which() == Node::ANNOTATION),
              "Must check which() before get()ing a union member.");
  return typename Node::Annotation::Reader(_reader);
}
inline typename Node::Annotation::Builder Node::Builder::getAnnotation() {
  KJ_IREQUIRE((which() == Node::ANNOTATION),
              "Must check which() before get()ing a union member.");
  return typename Node::Annotation::Builder(_builder);
}
inline typename Node::Annotation::Builder Node::Builder::initAnnotation() {
  _builder.setDataField<Node::Which>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, Node::ANNOTATION);
  _builder.setDataField<bool>(::capnp::bounded<112>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<113>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<114>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<115>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<116>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<117>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<118>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<119>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<120>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<121>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<122>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<123>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<3>() * ::capnp::POINTERS).clear();
  return typename Node::Annotation::Builder(_builder);
}
inline bool Node::Reader::hasParameters() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Builder::hasParameters() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Node::Parameter>::Reader Node::Reader::getParameters() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::Parameter>>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Node::Parameter>::Builder Node::Builder::getParameters() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::Parameter>>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void Node::Builder::setParameters( ::capnp::List< ::capnp::schema::Node::Parameter>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::Parameter>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Node::Parameter>::Builder Node::Builder::initParameters(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::Parameter>>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void Node::Builder::adoptParameters(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Node::Parameter>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::Parameter>>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Node::Parameter>> Node::Builder::disownParameters() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::Parameter>>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool Node::Reader::getIsGeneric() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<288>() * ::capnp::ELEMENTS);
}

inline bool Node::Builder::getIsGeneric() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<288>() * ::capnp::ELEMENTS);
}
inline void Node::Builder::setIsGeneric(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<288>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Parameter::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Parameter::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Node::Parameter::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Node::Parameter::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Node::Parameter::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Node::Parameter::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Node::Parameter::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Node::Parameter::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Node::NestedNode::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Node::NestedNode::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Node::NestedNode::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Node::NestedNode::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Node::NestedNode::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Node::NestedNode::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Node::NestedNode::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Node::NestedNode::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Node::NestedNode::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Node::NestedNode::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Node::NestedNode::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Node::Struct::Reader::getDataWordCount() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Node::Struct::Builder::getDataWordCount() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void Node::Struct::Builder::setDataWordCount( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Node::Struct::Reader::getPointerCount() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Node::Struct::Builder::getPointerCount() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}
inline void Node::Struct::Builder::setPointerCount( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::schema::ElementSize Node::Struct::Reader::getPreferredListEncoding() const {
  return _reader.getDataField< ::capnp::schema::ElementSize>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}

inline  ::capnp::schema::ElementSize Node::Struct::Builder::getPreferredListEncoding() {
  return _builder.getDataField< ::capnp::schema::ElementSize>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS);
}
inline void Node::Struct::Builder::setPreferredListEncoding( ::capnp::schema::ElementSize value) {
  _builder.setDataField< ::capnp::schema::ElementSize>(
      ::capnp::bounded<13>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Struct::Reader::getIsGroup() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<224>() * ::capnp::ELEMENTS);
}

inline bool Node::Struct::Builder::getIsGroup() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<224>() * ::capnp::ELEMENTS);
}
inline void Node::Struct::Builder::setIsGroup(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<224>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Node::Struct::Reader::getDiscriminantCount() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Node::Struct::Builder::getDiscriminantCount() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS);
}
inline void Node::Struct::Builder::setDiscriminantCount( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<15>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Node::Struct::Reader::getDiscriminantOffset() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Node::Struct::Builder::getDiscriminantOffset() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void Node::Struct::Builder::setDiscriminantOffset( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Struct::Reader::hasFields() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Struct::Builder::hasFields() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Field>::Reader Node::Struct::Reader::getFields() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Field>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Field>::Builder Node::Struct::Builder::getFields() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Field>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Node::Struct::Builder::setFields( ::capnp::List< ::capnp::schema::Field>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Field>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Field>::Builder Node::Struct::Builder::initFields(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Field>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Node::Struct::Builder::adoptFields(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Field>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Field>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Field>> Node::Struct::Builder::disownFields() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Field>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Node::Enum::Reader::hasEnumerants() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Enum::Builder::hasEnumerants() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Enumerant>::Reader Node::Enum::Reader::getEnumerants() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Enumerant>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Enumerant>::Builder Node::Enum::Builder::getEnumerants() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Enumerant>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Node::Enum::Builder::setEnumerants( ::capnp::List< ::capnp::schema::Enumerant>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Enumerant>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Enumerant>::Builder Node::Enum::Builder::initEnumerants(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Enumerant>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Node::Enum::Builder::adoptEnumerants(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Enumerant>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Enumerant>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Enumerant>> Node::Enum::Builder::disownEnumerants() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Enumerant>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Node::Interface::Reader::hasMethods() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Interface::Builder::hasMethods() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Method>::Reader Node::Interface::Reader::getMethods() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Method>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Method>::Builder Node::Interface::Builder::getMethods() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Method>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Node::Interface::Builder::setMethods( ::capnp::List< ::capnp::schema::Method>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Method>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Method>::Builder Node::Interface::Builder::initMethods(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Method>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Node::Interface::Builder::adoptMethods(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Method>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Method>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Method>> Node::Interface::Builder::disownMethods() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Method>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Node::Interface::Reader::hasSuperclasses() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Interface::Builder::hasSuperclasses() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Superclass>::Reader Node::Interface::Reader::getSuperclasses() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Superclass>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Superclass>::Builder Node::Interface::Builder::getSuperclasses() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Superclass>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Node::Interface::Builder::setSuperclasses( ::capnp::List< ::capnp::schema::Superclass>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Superclass>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Superclass>::Builder Node::Interface::Builder::initSuperclasses(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Superclass>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void Node::Interface::Builder::adoptSuperclasses(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Superclass>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Superclass>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Superclass>> Node::Interface::Builder::disownSuperclasses() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Superclass>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool Node::Const::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Const::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Type::Reader Node::Const::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Type::Builder Node::Const::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Type::Pipeline Node::Const::Pipeline::getType() {
  return  ::capnp::schema::Type::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Node::Const::Builder::setType( ::capnp::schema::Type::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Type>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Type::Builder Node::Const::Builder::initType() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Node::Const::Builder::adoptType(
    ::capnp::Orphan< ::capnp::schema::Type>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Type>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Type> Node::Const::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Node::Const::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Const::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Value::Reader Node::Const::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Value>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Value::Builder Node::Const::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Value>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Value::Pipeline Node::Const::Pipeline::getValue() {
  return  ::capnp::schema::Value::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void Node::Const::Builder::setValue( ::capnp::schema::Value::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Value>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Value::Builder Node::Const::Builder::initValue() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Value>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Node::Const::Builder::adoptValue(
    ::capnp::Orphan< ::capnp::schema::Value>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Value> Node::Const::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Value>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool Node::Annotation::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Annotation::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Type::Reader Node::Annotation::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Type::Builder Node::Annotation::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Type::Pipeline Node::Annotation::Pipeline::getType() {
  return  ::capnp::schema::Type::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Node::Annotation::Builder::setType( ::capnp::schema::Type::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Type>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Type::Builder Node::Annotation::Builder::initType() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Node::Annotation::Builder::adoptType(
    ::capnp::Orphan< ::capnp::schema::Type>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Type>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Type> Node::Annotation::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Node::Annotation::Reader::getTargetsFile() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<112>() * ::capnp::ELEMENTS);
}

inline bool Node::Annotation::Builder::getTargetsFile() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<112>() * ::capnp::ELEMENTS);
}
inline void Node::Annotation::Builder::setTargetsFile(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<112>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Annotation::Reader::getTargetsConst() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<113>() * ::capnp::ELEMENTS);
}

inline bool Node::Annotation::Builder::getTargetsConst() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<113>() * ::capnp::ELEMENTS);
}
inline void Node::Annotation::Builder::setTargetsConst(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<113>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Annotation::Reader::getTargetsEnum() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<114>() * ::capnp::ELEMENTS);
}

inline bool Node::Annotation::Builder::getTargetsEnum() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<114>() * ::capnp::ELEMENTS);
}
inline void Node::Annotation::Builder::setTargetsEnum(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<114>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Annotation::Reader::getTargetsEnumerant() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<115>() * ::capnp::ELEMENTS);
}

inline bool Node::Annotation::Builder::getTargetsEnumerant() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<115>() * ::capnp::ELEMENTS);
}
inline void Node::Annotation::Builder::setTargetsEnumerant(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<115>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Annotation::Reader::getTargetsStruct() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<116>() * ::capnp::ELEMENTS);
}

inline bool Node::Annotation::Builder::getTargetsStruct() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<116>() * ::capnp::ELEMENTS);
}
inline void Node::Annotation::Builder::setTargetsStruct(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<116>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Annotation::Reader::getTargetsField() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<117>() * ::capnp::ELEMENTS);
}

inline bool Node::Annotation::Builder::getTargetsField() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<117>() * ::capnp::ELEMENTS);
}
inline void Node::Annotation::Builder::setTargetsField(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<117>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Annotation::Reader::getTargetsUnion() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<118>() * ::capnp::ELEMENTS);
}

inline bool Node::Annotation::Builder::getTargetsUnion() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<118>() * ::capnp::ELEMENTS);
}
inline void Node::Annotation::Builder::setTargetsUnion(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<118>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Annotation::Reader::getTargetsGroup() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<119>() * ::capnp::ELEMENTS);
}

inline bool Node::Annotation::Builder::getTargetsGroup() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<119>() * ::capnp::ELEMENTS);
}
inline void Node::Annotation::Builder::setTargetsGroup(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<119>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Annotation::Reader::getTargetsInterface() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<120>() * ::capnp::ELEMENTS);
}

inline bool Node::Annotation::Builder::getTargetsInterface() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<120>() * ::capnp::ELEMENTS);
}
inline void Node::Annotation::Builder::setTargetsInterface(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<120>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Annotation::Reader::getTargetsMethod() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<121>() * ::capnp::ELEMENTS);
}

inline bool Node::Annotation::Builder::getTargetsMethod() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<121>() * ::capnp::ELEMENTS);
}
inline void Node::Annotation::Builder::setTargetsMethod(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<121>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Annotation::Reader::getTargetsParam() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<122>() * ::capnp::ELEMENTS);
}

inline bool Node::Annotation::Builder::getTargetsParam() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<122>() * ::capnp::ELEMENTS);
}
inline void Node::Annotation::Builder::setTargetsParam(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<122>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Annotation::Reader::getTargetsAnnotation() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<123>() * ::capnp::ELEMENTS);
}

inline bool Node::Annotation::Builder::getTargetsAnnotation() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<123>() * ::capnp::ELEMENTS);
}
inline void Node::Annotation::Builder::setTargetsAnnotation(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<123>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::schema::Field::Which Field::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline  ::capnp::schema::Field::Which Field::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline bool Field::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Field::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Field::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Field::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Field::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Field::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Field::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Field::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t Field::Reader::getCodeOrder() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Field::Builder::getCodeOrder() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Field::Builder::setCodeOrder( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Field::Reader::hasAnnotations() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Field::Builder::hasAnnotations() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Annotation>::Reader Field::Reader::getAnnotations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Annotation>::Builder Field::Builder::getAnnotations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Field::Builder::setAnnotations( ::capnp::List< ::capnp::schema::Annotation>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Annotation>::Builder Field::Builder::initAnnotations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Field::Builder::adoptAnnotations(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>> Field::Builder::disownAnnotations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint16_t Field::Reader::getDiscriminantValue() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 65535u);
}

inline  ::uint16_t Field::Builder::getDiscriminantValue() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 65535u);
}
inline void Field::Builder::setDiscriminantValue( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 65535u);
}

inline bool Field::Reader::isSlot() const {
  return which() == Field::SLOT;
}
inline bool Field::Builder::isSlot() {
  return which() == Field::SLOT;
}
inline typename Field::Slot::Reader Field::Reader::getSlot() const {
  KJ_IREQUIRE((which() == Field::SLOT),
              "Must check which() before get()ing a union member.");
  return typename Field::Slot::Reader(_reader);
}
inline typename Field::Slot::Builder Field::Builder::getSlot() {
  KJ_IREQUIRE((which() == Field::SLOT),
              "Must check which() before get()ing a union member.");
  return typename Field::Slot::Builder(_builder);
}
inline typename Field::Slot::Builder Field::Builder::initSlot() {
  _builder.setDataField<Field::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Field::SLOT);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<128>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<2>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<3>() * ::capnp::POINTERS).clear();
  return typename Field::Slot::Builder(_builder);
}
inline bool Field::Reader::isGroup() const {
  return which() == Field::GROUP;
}
inline bool Field::Builder::isGroup() {
  return which() == Field::GROUP;
}
inline typename Field::Group::Reader Field::Reader::getGroup() const {
  KJ_IREQUIRE((which() == Field::GROUP),
              "Must check which() before get()ing a union member.");
  return typename Field::Group::Reader(_reader);
}
inline typename Field::Group::Builder Field::Builder::getGroup() {
  KJ_IREQUIRE((which() == Field::GROUP),
              "Must check which() before get()ing a union member.");
  return typename Field::Group::Builder(_builder);
}
inline typename Field::Group::Builder Field::Builder::initGroup() {
  _builder.setDataField<Field::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Field::GROUP);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  return typename Field::Group::Builder(_builder);
}
inline typename Field::Ordinal::Reader Field::Reader::getOrdinal() const {
  return typename Field::Ordinal::Reader(_reader);
}
inline typename Field::Ordinal::Builder Field::Builder::getOrdinal() {
  return typename Field::Ordinal::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Field::Ordinal::Pipeline Field::Pipeline::getOrdinal() {
  return typename Field::Ordinal::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Field::Ordinal::Builder Field::Builder::initOrdinal() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<5>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<6>() * ::capnp::ELEMENTS, 0);
  return typename Field::Ordinal::Builder(_builder);
}
inline  ::uint32_t Field::Slot::Reader::getOffset() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Field::Slot::Builder::getOffset() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Field::Slot::Builder::setOffset( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Field::Slot::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Field::Slot::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Type::Reader Field::Slot::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Type::Builder Field::Slot::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Type::Pipeline Field::Slot::Pipeline::getType() {
  return  ::capnp::schema::Type::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Field::Slot::Builder::setType( ::capnp::schema::Type::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Type>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Type::Builder Field::Slot::Builder::initType() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Field::Slot::Builder::adoptType(
    ::capnp::Orphan< ::capnp::schema::Type>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Type>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Type> Field::Slot::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Field::Slot::Reader::hasDefaultValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Field::Slot::Builder::hasDefaultValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Value::Reader Field::Slot::Reader::getDefaultValue() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Value>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Value::Builder Field::Slot::Builder::getDefaultValue() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Value>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Value::Pipeline Field::Slot::Pipeline::getDefaultValue() {
  return  ::capnp::schema::Value::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Field::Slot::Builder::setDefaultValue( ::capnp::schema::Value::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Value>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Value::Builder Field::Slot::Builder::initDefaultValue() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Value>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Field::Slot::Builder::adoptDefaultValue(
    ::capnp::Orphan< ::capnp::schema::Value>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Value> Field::Slot::Builder::disownDefaultValue() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Value>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Field::Slot::Reader::getHadExplicitDefault() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS);
}

inline bool Field::Slot::Builder::getHadExplicitDefault() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS);
}
inline void Field::Slot::Builder::setHadExplicitDefault(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Field::Group::Reader::getTypeId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Field::Group::Builder::getTypeId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Field::Group::Builder::setTypeId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::schema::Field::Ordinal::Which Field::Ordinal::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline  ::capnp::schema::Field::Ordinal::Which Field::Ordinal::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline bool Field::Ordinal::Reader::isImplicit() const {
  return which() == Field::Ordinal::IMPLICIT;
}
inline bool Field::Ordinal::Builder::isImplicit() {
  return which() == Field::Ordinal::IMPLICIT;
}
inline  ::capnp::Void Field::Ordinal::Reader::getImplicit() const {
  KJ_IREQUIRE((which() == Field::Ordinal::IMPLICIT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Field::Ordinal::Builder::getImplicit() {
  KJ_IREQUIRE((which() == Field::Ordinal::IMPLICIT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Field::Ordinal::Builder::setImplicit( ::capnp::Void value) {
  _builder.setDataField<Field::Ordinal::Which>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, Field::Ordinal::IMPLICIT);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Field::Ordinal::Reader::isExplicit() const {
  return which() == Field::Ordinal::EXPLICIT;
}
inline bool Field::Ordinal::Builder::isExplicit() {
  return which() == Field::Ordinal::EXPLICIT;
}
inline  ::uint16_t Field::Ordinal::Reader::getExplicit() const {
  KJ_IREQUIRE((which() == Field::Ordinal::EXPLICIT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Field::Ordinal::Builder::getExplicit() {
  KJ_IREQUIRE((which() == Field::Ordinal::EXPLICIT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void Field::Ordinal::Builder::setExplicit( ::uint16_t value) {
  _builder.setDataField<Field::Ordinal::Which>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, Field::Ordinal::EXPLICIT);
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline bool Enumerant::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Enumerant::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Enumerant::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Enumerant::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Enumerant::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Enumerant::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Enumerant::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Enumerant::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t Enumerant::Reader::getCodeOrder() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Enumerant::Builder::getCodeOrder() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Enumerant::Builder::setCodeOrder( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Enumerant::Reader::hasAnnotations() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Enumerant::Builder::hasAnnotations() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Annotation>::Reader Enumerant::Reader::getAnnotations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Annotation>::Builder Enumerant::Builder::getAnnotations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Enumerant::Builder::setAnnotations( ::capnp::List< ::capnp::schema::Annotation>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Annotation>::Builder Enumerant::Builder::initAnnotations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Enumerant::Builder::adoptAnnotations(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>> Enumerant::Builder::disownAnnotations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint64_t Superclass::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Superclass::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Superclass::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Superclass::Reader::hasBrand() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Superclass::Builder::hasBrand() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Brand::Reader Superclass::Reader::getBrand() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Brand::Builder Superclass::Builder::getBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Brand::Pipeline Superclass::Pipeline::getBrand() {
  return  ::capnp::schema::Brand::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Superclass::Builder::setBrand( ::capnp::schema::Brand::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Brand::Builder Superclass::Builder::initBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Superclass::Builder::adoptBrand(
    ::capnp::Orphan< ::capnp::schema::Brand>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Brand> Superclass::Builder::disownBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Method::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Method::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Method::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Method::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Method::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Method::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Method::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Method::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t Method::Reader::getCodeOrder() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Method::Builder::getCodeOrder() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Method::Builder::setCodeOrder( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Method::Reader::getParamStructType() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Method::Builder::getParamStructType() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Method::Builder::setParamStructType( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Method::Reader::getResultStructType() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Method::Builder::getResultStructType() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Method::Builder::setResultStructType( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Method::Reader::hasAnnotations() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Method::Builder::hasAnnotations() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Annotation>::Reader Method::Reader::getAnnotations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Annotation>::Builder Method::Builder::getAnnotations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Method::Builder::setAnnotations( ::capnp::List< ::capnp::schema::Annotation>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Annotation>::Builder Method::Builder::initAnnotations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Method::Builder::adoptAnnotations(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Annotation>> Method::Builder::disownAnnotations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Annotation>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Method::Reader::hasParamBrand() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Method::Builder::hasParamBrand() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Brand::Reader Method::Reader::getParamBrand() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Brand::Builder Method::Builder::getParamBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Brand::Pipeline Method::Pipeline::getParamBrand() {
  return  ::capnp::schema::Brand::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Method::Builder::setParamBrand( ::capnp::schema::Brand::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Brand::Builder Method::Builder::initParamBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Method::Builder::adoptParamBrand(
    ::capnp::Orphan< ::capnp::schema::Brand>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Brand> Method::Builder::disownParamBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Method::Reader::hasResultBrand() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Method::Builder::hasResultBrand() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Brand::Reader Method::Reader::getResultBrand() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Brand::Builder Method::Builder::getResultBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Brand::Pipeline Method::Pipeline::getResultBrand() {
  return  ::capnp::schema::Brand::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Method::Builder::setResultBrand( ::capnp::schema::Brand::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Brand::Builder Method::Builder::initResultBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Method::Builder::adoptResultBrand(
    ::capnp::Orphan< ::capnp::schema::Brand>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Brand> Method::Builder::disownResultBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Method::Reader::hasImplicitParameters() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Method::Builder::hasImplicitParameters() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Node::Parameter>::Reader Method::Reader::getImplicitParameters() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::Parameter>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Node::Parameter>::Builder Method::Builder::getImplicitParameters() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::Parameter>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Method::Builder::setImplicitParameters( ::capnp::List< ::capnp::schema::Node::Parameter>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::Parameter>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Node::Parameter>::Builder Method::Builder::initImplicitParameters(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::Parameter>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void Method::Builder::adoptImplicitParameters(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Node::Parameter>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::Parameter>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Node::Parameter>> Method::Builder::disownImplicitParameters() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node::Parameter>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline  ::capnp::schema::Type::Which Type::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::capnp::schema::Type::Which Type::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Type::Reader::isVoid() const {
  return which() == Type::VOID;
}
inline bool Type::Builder::isVoid() {
  return which() == Type::VOID;
}
inline  ::capnp::Void Type::Reader::getVoid() const {
  KJ_IREQUIRE((which() == Type::VOID),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getVoid() {
  KJ_IREQUIRE((which() == Type::VOID),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setVoid( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::VOID);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isBool() const {
  return which() == Type::BOOL;
}
inline bool Type::Builder::isBool() {
  return which() == Type::BOOL;
}
inline  ::capnp::Void Type::Reader::getBool() const {
  KJ_IREQUIRE((which() == Type::BOOL),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getBool() {
  KJ_IREQUIRE((which() == Type::BOOL),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setBool( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::BOOL);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isInt8() const {
  return which() == Type::INT8;
}
inline bool Type::Builder::isInt8() {
  return which() == Type::INT8;
}
inline  ::capnp::Void Type::Reader::getInt8() const {
  KJ_IREQUIRE((which() == Type::INT8),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getInt8() {
  KJ_IREQUIRE((which() == Type::INT8),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setInt8( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::INT8);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isInt16() const {
  return which() == Type::INT16;
}
inline bool Type::Builder::isInt16() {
  return which() == Type::INT16;
}
inline  ::capnp::Void Type::Reader::getInt16() const {
  KJ_IREQUIRE((which() == Type::INT16),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getInt16() {
  KJ_IREQUIRE((which() == Type::INT16),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setInt16( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::INT16);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isInt32() const {
  return which() == Type::INT32;
}
inline bool Type::Builder::isInt32() {
  return which() == Type::INT32;
}
inline  ::capnp::Void Type::Reader::getInt32() const {
  KJ_IREQUIRE((which() == Type::INT32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getInt32() {
  KJ_IREQUIRE((which() == Type::INT32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setInt32( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::INT32);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isInt64() const {
  return which() == Type::INT64;
}
inline bool Type::Builder::isInt64() {
  return which() == Type::INT64;
}
inline  ::capnp::Void Type::Reader::getInt64() const {
  KJ_IREQUIRE((which() == Type::INT64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getInt64() {
  KJ_IREQUIRE((which() == Type::INT64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setInt64( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::INT64);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isUint8() const {
  return which() == Type::UINT8;
}
inline bool Type::Builder::isUint8() {
  return which() == Type::UINT8;
}
inline  ::capnp::Void Type::Reader::getUint8() const {
  KJ_IREQUIRE((which() == Type::UINT8),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getUint8() {
  KJ_IREQUIRE((which() == Type::UINT8),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setUint8( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::UINT8);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isUint16() const {
  return which() == Type::UINT16;
}
inline bool Type::Builder::isUint16() {
  return which() == Type::UINT16;
}
inline  ::capnp::Void Type::Reader::getUint16() const {
  KJ_IREQUIRE((which() == Type::UINT16),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getUint16() {
  KJ_IREQUIRE((which() == Type::UINT16),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setUint16( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::UINT16);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isUint32() const {
  return which() == Type::UINT32;
}
inline bool Type::Builder::isUint32() {
  return which() == Type::UINT32;
}
inline  ::capnp::Void Type::Reader::getUint32() const {
  KJ_IREQUIRE((which() == Type::UINT32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getUint32() {
  KJ_IREQUIRE((which() == Type::UINT32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setUint32( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::UINT32);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isUint64() const {
  return which() == Type::UINT64;
}
inline bool Type::Builder::isUint64() {
  return which() == Type::UINT64;
}
inline  ::capnp::Void Type::Reader::getUint64() const {
  KJ_IREQUIRE((which() == Type::UINT64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getUint64() {
  KJ_IREQUIRE((which() == Type::UINT64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setUint64( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::UINT64);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isFloat32() const {
  return which() == Type::FLOAT32;
}
inline bool Type::Builder::isFloat32() {
  return which() == Type::FLOAT32;
}
inline  ::capnp::Void Type::Reader::getFloat32() const {
  KJ_IREQUIRE((which() == Type::FLOAT32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getFloat32() {
  KJ_IREQUIRE((which() == Type::FLOAT32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setFloat32( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::FLOAT32);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isFloat64() const {
  return which() == Type::FLOAT64;
}
inline bool Type::Builder::isFloat64() {
  return which() == Type::FLOAT64;
}
inline  ::capnp::Void Type::Reader::getFloat64() const {
  KJ_IREQUIRE((which() == Type::FLOAT64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getFloat64() {
  KJ_IREQUIRE((which() == Type::FLOAT64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setFloat64( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::FLOAT64);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isText() const {
  return which() == Type::TEXT;
}
inline bool Type::Builder::isText() {
  return which() == Type::TEXT;
}
inline  ::capnp::Void Type::Reader::getText() const {
  KJ_IREQUIRE((which() == Type::TEXT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getText() {
  KJ_IREQUIRE((which() == Type::TEXT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setText( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::TEXT);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isData() const {
  return which() == Type::DATA;
}
inline bool Type::Builder::isData() {
  return which() == Type::DATA;
}
inline  ::capnp::Void Type::Reader::getData() const {
  KJ_IREQUIRE((which() == Type::DATA),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getData() {
  KJ_IREQUIRE((which() == Type::DATA),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setData( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::DATA);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isList() const {
  return which() == Type::LIST;
}
inline bool Type::Builder::isList() {
  return which() == Type::LIST;
}
inline typename Type::List::Reader Type::Reader::getList() const {
  KJ_IREQUIRE((which() == Type::LIST),
              "Must check which() before get()ing a union member.");
  return typename Type::List::Reader(_reader);
}
inline typename Type::List::Builder Type::Builder::getList() {
  KJ_IREQUIRE((which() == Type::LIST),
              "Must check which() before get()ing a union member.");
  return typename Type::List::Builder(_builder);
}
inline typename Type::List::Builder Type::Builder::initList() {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::LIST);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename Type::List::Builder(_builder);
}
inline bool Type::Reader::isEnum() const {
  return which() == Type::ENUM;
}
inline bool Type::Builder::isEnum() {
  return which() == Type::ENUM;
}
inline typename Type::Enum::Reader Type::Reader::getEnum() const {
  KJ_IREQUIRE((which() == Type::ENUM),
              "Must check which() before get()ing a union member.");
  return typename Type::Enum::Reader(_reader);
}
inline typename Type::Enum::Builder Type::Builder::getEnum() {
  KJ_IREQUIRE((which() == Type::ENUM),
              "Must check which() before get()ing a union member.");
  return typename Type::Enum::Builder(_builder);
}
inline typename Type::Enum::Builder Type::Builder::initEnum() {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::ENUM);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename Type::Enum::Builder(_builder);
}
inline bool Type::Reader::isStruct() const {
  return which() == Type::STRUCT;
}
inline bool Type::Builder::isStruct() {
  return which() == Type::STRUCT;
}
inline typename Type::Struct::Reader Type::Reader::getStruct() const {
  KJ_IREQUIRE((which() == Type::STRUCT),
              "Must check which() before get()ing a union member.");
  return typename Type::Struct::Reader(_reader);
}
inline typename Type::Struct::Builder Type::Builder::getStruct() {
  KJ_IREQUIRE((which() == Type::STRUCT),
              "Must check which() before get()ing a union member.");
  return typename Type::Struct::Builder(_builder);
}
inline typename Type::Struct::Builder Type::Builder::initStruct() {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::STRUCT);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename Type::Struct::Builder(_builder);
}
inline bool Type::Reader::isInterface() const {
  return which() == Type::INTERFACE;
}
inline bool Type::Builder::isInterface() {
  return which() == Type::INTERFACE;
}
inline typename Type::Interface::Reader Type::Reader::getInterface() const {
  KJ_IREQUIRE((which() == Type::INTERFACE),
              "Must check which() before get()ing a union member.");
  return typename Type::Interface::Reader(_reader);
}
inline typename Type::Interface::Builder Type::Builder::getInterface() {
  KJ_IREQUIRE((which() == Type::INTERFACE),
              "Must check which() before get()ing a union member.");
  return typename Type::Interface::Builder(_builder);
}
inline typename Type::Interface::Builder Type::Builder::initInterface() {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::INTERFACE);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename Type::Interface::Builder(_builder);
}
inline bool Type::Reader::isAnyPointer() const {
  return which() == Type::ANY_POINTER;
}
inline bool Type::Builder::isAnyPointer() {
  return which() == Type::ANY_POINTER;
}
inline typename Type::AnyPointer::Reader Type::Reader::getAnyPointer() const {
  KJ_IREQUIRE((which() == Type::ANY_POINTER),
              "Must check which() before get()ing a union member.");
  return typename Type::AnyPointer::Reader(_reader);
}
inline typename Type::AnyPointer::Builder Type::Builder::getAnyPointer() {
  KJ_IREQUIRE((which() == Type::ANY_POINTER),
              "Must check which() before get()ing a union member.");
  return typename Type::AnyPointer::Builder(_builder);
}
inline typename Type::AnyPointer::Builder Type::Builder::initAnyPointer() {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::ANY_POINTER);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<4>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<5>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  return typename Type::AnyPointer::Builder(_builder);
}
inline bool Type::List::Reader::hasElementType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::List::Builder::hasElementType() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Type::Reader Type::List::Reader::getElementType() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Type::Builder Type::List::Builder::getElementType() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Type::Pipeline Type::List::Pipeline::getElementType() {
  return  ::capnp::schema::Type::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Type::List::Builder::setElementType( ::capnp::schema::Type::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Type>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Type::Builder Type::List::Builder::initElementType() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::List::Builder::adoptElementType(
    ::capnp::Orphan< ::capnp::schema::Type>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Type>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Type> Type::List::Builder::disownElementType() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Type::Enum::Reader::getTypeId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Type::Enum::Builder::getTypeId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Type::Enum::Builder::setTypeId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Enum::Reader::hasBrand() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::Enum::Builder::hasBrand() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Brand::Reader Type::Enum::Reader::getBrand() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Brand::Builder Type::Enum::Builder::getBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Brand::Pipeline Type::Enum::Pipeline::getBrand() {
  return  ::capnp::schema::Brand::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Type::Enum::Builder::setBrand( ::capnp::schema::Brand::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Brand::Builder Type::Enum::Builder::initBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Enum::Builder::adoptBrand(
    ::capnp::Orphan< ::capnp::schema::Brand>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Brand> Type::Enum::Builder::disownBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Type::Struct::Reader::getTypeId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Type::Struct::Builder::getTypeId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Type::Struct::Builder::setTypeId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Struct::Reader::hasBrand() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::Struct::Builder::hasBrand() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Brand::Reader Type::Struct::Reader::getBrand() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Brand::Builder Type::Struct::Builder::getBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Brand::Pipeline Type::Struct::Pipeline::getBrand() {
  return  ::capnp::schema::Brand::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Type::Struct::Builder::setBrand( ::capnp::schema::Brand::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Brand::Builder Type::Struct::Builder::initBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Struct::Builder::adoptBrand(
    ::capnp::Orphan< ::capnp::schema::Brand>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Brand> Type::Struct::Builder::disownBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Type::Interface::Reader::getTypeId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Type::Interface::Builder::getTypeId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Type::Interface::Builder::setTypeId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Interface::Reader::hasBrand() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::Interface::Builder::hasBrand() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Brand::Reader Type::Interface::Reader::getBrand() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Brand::Builder Type::Interface::Builder::getBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Brand::Pipeline Type::Interface::Pipeline::getBrand() {
  return  ::capnp::schema::Brand::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Type::Interface::Builder::setBrand( ::capnp::schema::Brand::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Brand::Builder Type::Interface::Builder::initBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Interface::Builder::adoptBrand(
    ::capnp::Orphan< ::capnp::schema::Brand>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Brand> Type::Interface::Builder::disownBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::capnp::schema::Type::AnyPointer::Which Type::AnyPointer::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline  ::capnp::schema::Type::AnyPointer::Which Type::AnyPointer::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline bool Type::AnyPointer::Reader::isUnconstrained() const {
  return which() == Type::AnyPointer::UNCONSTRAINED;
}
inline bool Type::AnyPointer::Builder::isUnconstrained() {
  return which() == Type::AnyPointer::UNCONSTRAINED;
}
inline typename Type::AnyPointer::Unconstrained::Reader Type::AnyPointer::Reader::getUnconstrained() const {
  KJ_IREQUIRE((which() == Type::AnyPointer::UNCONSTRAINED),
              "Must check which() before get()ing a union member.");
  return typename Type::AnyPointer::Unconstrained::Reader(_reader);
}
inline typename Type::AnyPointer::Unconstrained::Builder Type::AnyPointer::Builder::getUnconstrained() {
  KJ_IREQUIRE((which() == Type::AnyPointer::UNCONSTRAINED),
              "Must check which() before get()ing a union member.");
  return typename Type::AnyPointer::Unconstrained::Builder(_builder);
}
inline typename Type::AnyPointer::Unconstrained::Builder Type::AnyPointer::Builder::initUnconstrained() {
  _builder.setDataField<Type::AnyPointer::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Type::AnyPointer::UNCONSTRAINED);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<5>() * ::capnp::ELEMENTS, 0);
  return typename Type::AnyPointer::Unconstrained::Builder(_builder);
}
inline bool Type::AnyPointer::Reader::isParameter() const {
  return which() == Type::AnyPointer::PARAMETER;
}
inline bool Type::AnyPointer::Builder::isParameter() {
  return which() == Type::AnyPointer::PARAMETER;
}
inline typename Type::AnyPointer::Parameter::Reader Type::AnyPointer::Reader::getParameter() const {
  KJ_IREQUIRE((which() == Type::AnyPointer::PARAMETER),
              "Must check which() before get()ing a union member.");
  return typename Type::AnyPointer::Parameter::Reader(_reader);
}
inline typename Type::AnyPointer::Parameter::Builder Type::AnyPointer::Builder::getParameter() {
  KJ_IREQUIRE((which() == Type::AnyPointer::PARAMETER),
              "Must check which() before get()ing a union member.");
  return typename Type::AnyPointer::Parameter::Builder(_builder);
}
inline typename Type::AnyPointer::Parameter::Builder Type::AnyPointer::Builder::initParameter() {
  _builder.setDataField<Type::AnyPointer::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Type::AnyPointer::PARAMETER);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<5>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  return typename Type::AnyPointer::Parameter::Builder(_builder);
}
inline bool Type::AnyPointer::Reader::isImplicitMethodParameter() const {
  return which() == Type::AnyPointer::IMPLICIT_METHOD_PARAMETER;
}
inline bool Type::AnyPointer::Builder::isImplicitMethodParameter() {
  return which() == Type::AnyPointer::IMPLICIT_METHOD_PARAMETER;
}
inline typename Type::AnyPointer::ImplicitMethodParameter::Reader Type::AnyPointer::Reader::getImplicitMethodParameter() const {
  KJ_IREQUIRE((which() == Type::AnyPointer::IMPLICIT_METHOD_PARAMETER),
              "Must check which() before get()ing a union member.");
  return typename Type::AnyPointer::ImplicitMethodParameter::Reader(_reader);
}
inline typename Type::AnyPointer::ImplicitMethodParameter::Builder Type::AnyPointer::Builder::getImplicitMethodParameter() {
  KJ_IREQUIRE((which() == Type::AnyPointer::IMPLICIT_METHOD_PARAMETER),
              "Must check which() before get()ing a union member.");
  return typename Type::AnyPointer::ImplicitMethodParameter::Builder(_builder);
}
inline typename Type::AnyPointer::ImplicitMethodParameter::Builder Type::AnyPointer::Builder::initImplicitMethodParameter() {
  _builder.setDataField<Type::AnyPointer::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Type::AnyPointer::IMPLICIT_METHOD_PARAMETER);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<5>() * ::capnp::ELEMENTS, 0);
  return typename Type::AnyPointer::ImplicitMethodParameter::Builder(_builder);
}
inline  ::capnp::schema::Type::AnyPointer::Unconstrained::Which Type::AnyPointer::Unconstrained::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline  ::capnp::schema::Type::AnyPointer::Unconstrained::Which Type::AnyPointer::Unconstrained::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline bool Type::AnyPointer::Unconstrained::Reader::isAnyKind() const {
  return which() == Type::AnyPointer::Unconstrained::ANY_KIND;
}
inline bool Type::AnyPointer::Unconstrained::Builder::isAnyKind() {
  return which() == Type::AnyPointer::Unconstrained::ANY_KIND;
}
inline  ::capnp::Void Type::AnyPointer::Unconstrained::Reader::getAnyKind() const {
  KJ_IREQUIRE((which() == Type::AnyPointer::Unconstrained::ANY_KIND),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::AnyPointer::Unconstrained::Builder::getAnyKind() {
  KJ_IREQUIRE((which() == Type::AnyPointer::Unconstrained::ANY_KIND),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::AnyPointer::Unconstrained::Builder::setAnyKind( ::capnp::Void value) {
  _builder.setDataField<Type::AnyPointer::Unconstrained::Which>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, Type::AnyPointer::Unconstrained::ANY_KIND);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::AnyPointer::Unconstrained::Reader::isStruct() const {
  return which() == Type::AnyPointer::Unconstrained::STRUCT;
}
inline bool Type::AnyPointer::Unconstrained::Builder::isStruct() {
  return which() == Type::AnyPointer::Unconstrained::STRUCT;
}
inline  ::capnp::Void Type::AnyPointer::Unconstrained::Reader::getStruct() const {
  KJ_IREQUIRE((which() == Type::AnyPointer::Unconstrained::STRUCT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::AnyPointer::Unconstrained::Builder::getStruct() {
  KJ_IREQUIRE((which() == Type::AnyPointer::Unconstrained::STRUCT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::AnyPointer::Unconstrained::Builder::setStruct( ::capnp::Void value) {
  _builder.setDataField<Type::AnyPointer::Unconstrained::Which>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, Type::AnyPointer::Unconstrained::STRUCT);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::AnyPointer::Unconstrained::Reader::isList() const {
  return which() == Type::AnyPointer::Unconstrained::LIST;
}
inline bool Type::AnyPointer::Unconstrained::Builder::isList() {
  return which() == Type::AnyPointer::Unconstrained::LIST;
}
inline  ::capnp::Void Type::AnyPointer::Unconstrained::Reader::getList() const {
  KJ_IREQUIRE((which() == Type::AnyPointer::Unconstrained::LIST),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::AnyPointer::Unconstrained::Builder::getList() {
  KJ_IREQUIRE((which() == Type::AnyPointer::Unconstrained::LIST),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::AnyPointer::Unconstrained::Builder::setList( ::capnp::Void value) {
  _builder.setDataField<Type::AnyPointer::Unconstrained::Which>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, Type::AnyPointer::Unconstrained::LIST);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::AnyPointer::Unconstrained::Reader::isCapability() const {
  return which() == Type::AnyPointer::Unconstrained::CAPABILITY;
}
inline bool Type::AnyPointer::Unconstrained::Builder::isCapability() {
  return which() == Type::AnyPointer::Unconstrained::CAPABILITY;
}
inline  ::capnp::Void Type::AnyPointer::Unconstrained::Reader::getCapability() const {
  KJ_IREQUIRE((which() == Type::AnyPointer::Unconstrained::CAPABILITY),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::AnyPointer::Unconstrained::Builder::getCapability() {
  KJ_IREQUIRE((which() == Type::AnyPointer::Unconstrained::CAPABILITY),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::AnyPointer::Unconstrained::Builder::setCapability( ::capnp::Void value) {
  _builder.setDataField<Type::AnyPointer::Unconstrained::Which>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, Type::AnyPointer::Unconstrained::CAPABILITY);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Type::AnyPointer::Parameter::Reader::getScopeId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Type::AnyPointer::Parameter::Builder::getScopeId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Type::AnyPointer::Parameter::Builder::setScopeId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Type::AnyPointer::Parameter::Reader::getParameterIndex() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Type::AnyPointer::Parameter::Builder::getParameterIndex() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void Type::AnyPointer::Parameter::Builder::setParameterIndex( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Type::AnyPointer::ImplicitMethodParameter::Reader::getParameterIndex() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Type::AnyPointer::ImplicitMethodParameter::Builder::getParameterIndex() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void Type::AnyPointer::ImplicitMethodParameter::Builder::setParameterIndex( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline bool Brand::Reader::hasScopes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Brand::Builder::hasScopes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Brand::Scope>::Reader Brand::Reader::getScopes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Brand::Scope>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Brand::Scope>::Builder Brand::Builder::getScopes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Brand::Scope>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Brand::Builder::setScopes( ::capnp::List< ::capnp::schema::Brand::Scope>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Brand::Scope>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Brand::Scope>::Builder Brand::Builder::initScopes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Brand::Scope>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Brand::Builder::adoptScopes(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Brand::Scope>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Brand::Scope>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Brand::Scope>> Brand::Builder::disownScopes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Brand::Scope>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::capnp::schema::Brand::Scope::Which Brand::Scope::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline  ::capnp::schema::Brand::Scope::Which Brand::Scope::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Brand::Scope::Reader::getScopeId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Brand::Scope::Builder::getScopeId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Brand::Scope::Builder::setScopeId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Brand::Scope::Reader::isBind() const {
  return which() == Brand::Scope::BIND;
}
inline bool Brand::Scope::Builder::isBind() {
  return which() == Brand::Scope::BIND;
}
inline bool Brand::Scope::Reader::hasBind() const {
  if (which() != Brand::Scope::BIND) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Brand::Scope::Builder::hasBind() {
  if (which() != Brand::Scope::BIND) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Brand::Binding>::Reader Brand::Scope::Reader::getBind() const {
  KJ_IREQUIRE((which() == Brand::Scope::BIND),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Brand::Binding>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Brand::Binding>::Builder Brand::Scope::Builder::getBind() {
  KJ_IREQUIRE((which() == Brand::Scope::BIND),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Brand::Binding>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Brand::Scope::Builder::setBind( ::capnp::List< ::capnp::schema::Brand::Binding>::Reader value) {
  _builder.setDataField<Brand::Scope::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Brand::Scope::BIND);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Brand::Binding>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Brand::Binding>::Builder Brand::Scope::Builder::initBind(unsigned int size) {
  _builder.setDataField<Brand::Scope::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Brand::Scope::BIND);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Brand::Binding>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Brand::Scope::Builder::adoptBind(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Brand::Binding>>&& value) {
  _builder.setDataField<Brand::Scope::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Brand::Scope::BIND);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Brand::Binding>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Brand::Binding>> Brand::Scope::Builder::disownBind() {
  KJ_IREQUIRE((which() == Brand::Scope::BIND),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Brand::Binding>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Brand::Scope::Reader::isInherit() const {
  return which() == Brand::Scope::INHERIT;
}
inline bool Brand::Scope::Builder::isInherit() {
  return which() == Brand::Scope::INHERIT;
}
inline  ::capnp::Void Brand::Scope::Reader::getInherit() const {
  KJ_IREQUIRE((which() == Brand::Scope::INHERIT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Brand::Scope::Builder::getInherit() {
  KJ_IREQUIRE((which() == Brand::Scope::INHERIT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Brand::Scope::Builder::setInherit( ::capnp::Void value) {
  _builder.setDataField<Brand::Scope::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Brand::Scope::INHERIT);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::schema::Brand::Binding::Which Brand::Binding::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::capnp::schema::Brand::Binding::Which Brand::Binding::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Brand::Binding::Reader::isUnbound() const {
  return which() == Brand::Binding::UNBOUND;
}
inline bool Brand::Binding::Builder::isUnbound() {
  return which() == Brand::Binding::UNBOUND;
}
inline  ::capnp::Void Brand::Binding::Reader::getUnbound() const {
  KJ_IREQUIRE((which() == Brand::Binding::UNBOUND),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Brand::Binding::Builder::getUnbound() {
  KJ_IREQUIRE((which() == Brand::Binding::UNBOUND),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Brand::Binding::Builder::setUnbound( ::capnp::Void value) {
  _builder.setDataField<Brand::Binding::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Brand::Binding::UNBOUND);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Brand::Binding::Reader::isType() const {
  return which() == Brand::Binding::TYPE;
}
inline bool Brand::Binding::Builder::isType() {
  return which() == Brand::Binding::TYPE;
}
inline bool Brand::Binding::Reader::hasType() const {
  if (which() != Brand::Binding::TYPE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Brand::Binding::Builder::hasType() {
  if (which() != Brand::Binding::TYPE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Type::Reader Brand::Binding::Reader::getType() const {
  KJ_IREQUIRE((which() == Brand::Binding::TYPE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Type::Builder Brand::Binding::Builder::getType() {
  KJ_IREQUIRE((which() == Brand::Binding::TYPE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Brand::Binding::Builder::setType( ::capnp::schema::Type::Reader value) {
  _builder.setDataField<Brand::Binding::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Brand::Binding::TYPE);
  ::capnp::_::PointerHelpers< ::capnp::schema::Type>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Type::Builder Brand::Binding::Builder::initType() {
  _builder.setDataField<Brand::Binding::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Brand::Binding::TYPE);
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Brand::Binding::Builder::adoptType(
    ::capnp::Orphan< ::capnp::schema::Type>&& value) {
  _builder.setDataField<Brand::Binding::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Brand::Binding::TYPE);
  ::capnp::_::PointerHelpers< ::capnp::schema::Type>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Type> Brand::Binding::Builder::disownType() {
  KJ_IREQUIRE((which() == Brand::Binding::TYPE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::schema::Type>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::capnp::schema::Value::Which Value::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::capnp::schema::Value::Which Value::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Value::Reader::isVoid() const {
  return which() == Value::VOID;
}
inline bool Value::Builder::isVoid() {
  return which() == Value::VOID;
}
inline  ::capnp::Void Value::Reader::getVoid() const {
  KJ_IREQUIRE((which() == Value::VOID),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Value::Builder::getVoid() {
  KJ_IREQUIRE((which() == Value::VOID),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setVoid( ::capnp::Void value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::VOID);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isBool() const {
  return which() == Value::BOOL;
}
inline bool Value::Builder::isBool() {
  return which() == Value::BOOL;
}
inline bool Value::Reader::getBool() const {
  KJ_IREQUIRE((which() == Value::BOOL),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline bool Value::Builder::getBool() {
  KJ_IREQUIRE((which() == Value::BOOL),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setBool(bool value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::BOOL);
  _builder.setDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isInt8() const {
  return which() == Value::INT8;
}
inline bool Value::Builder::isInt8() {
  return which() == Value::INT8;
}
inline  ::int8_t Value::Reader::getInt8() const {
  KJ_IREQUIRE((which() == Value::INT8),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int8_t Value::Builder::getInt8() {
  KJ_IREQUIRE((which() == Value::INT8),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setInt8( ::int8_t value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::INT8);
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isInt16() const {
  return which() == Value::INT16;
}
inline bool Value::Builder::isInt16() {
  return which() == Value::INT16;
}
inline  ::int16_t Value::Reader::getInt16() const {
  KJ_IREQUIRE((which() == Value::INT16),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int16_t Value::Builder::getInt16() {
  KJ_IREQUIRE((which() == Value::INT16),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setInt16( ::int16_t value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::INT16);
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isInt32() const {
  return which() == Value::INT32;
}
inline bool Value::Builder::isInt32() {
  return which() == Value::INT32;
}
inline  ::int32_t Value::Reader::getInt32() const {
  KJ_IREQUIRE((which() == Value::INT32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Value::Builder::getInt32() {
  KJ_IREQUIRE((which() == Value::INT32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setInt32( ::int32_t value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::INT32);
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isInt64() const {
  return which() == Value::INT64;
}
inline bool Value::Builder::isInt64() {
  return which() == Value::INT64;
}
inline  ::int64_t Value::Reader::getInt64() const {
  KJ_IREQUIRE((which() == Value::INT64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Value::Builder::getInt64() {
  KJ_IREQUIRE((which() == Value::INT64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setInt64( ::int64_t value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::INT64);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isUint8() const {
  return which() == Value::UINT8;
}
inline bool Value::Builder::isUint8() {
  return which() == Value::UINT8;
}
inline  ::uint8_t Value::Reader::getUint8() const {
  KJ_IREQUIRE((which() == Value::UINT8),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Value::Builder::getUint8() {
  KJ_IREQUIRE((which() == Value::UINT8),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setUint8( ::uint8_t value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::UINT8);
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isUint16() const {
  return which() == Value::UINT16;
}
inline bool Value::Builder::isUint16() {
  return which() == Value::UINT16;
}
inline  ::uint16_t Value::Reader::getUint16() const {
  KJ_IREQUIRE((which() == Value::UINT16),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Value::Builder::getUint16() {
  KJ_IREQUIRE((which() == Value::UINT16),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setUint16( ::uint16_t value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::UINT16);
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isUint32() const {
  return which() == Value::UINT32;
}
inline bool Value::Builder::isUint32() {
  return which() == Value::UINT32;
}
inline  ::uint32_t Value::Reader::getUint32() const {
  KJ_IREQUIRE((which() == Value::UINT32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Value::Builder::getUint32() {
  KJ_IREQUIRE((which() == Value::UINT32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setUint32( ::uint32_t value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::UINT32);
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isUint64() const {
  return which() == Value::UINT64;
}
inline bool Value::Builder::isUint64() {
  return which() == Value::UINT64;
}
inline  ::uint64_t Value::Reader::getUint64() const {
  KJ_IREQUIRE((which() == Value::UINT64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Value::Builder::getUint64() {
  KJ_IREQUIRE((which() == Value::UINT64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setUint64( ::uint64_t value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::UINT64);
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isFloat32() const {
  return which() == Value::FLOAT32;
}
inline bool Value::Builder::isFloat32() {
  return which() == Value::FLOAT32;
}
inline float Value::Reader::getFloat32() const {
  KJ_IREQUIRE((which() == Value::FLOAT32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Value::Builder::getFloat32() {
  KJ_IREQUIRE((which() == Value::FLOAT32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setFloat32(float value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::FLOAT32);
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isFloat64() const {
  return which() == Value::FLOAT64;
}
inline bool Value::Builder::isFloat64() {
  return which() == Value::FLOAT64;
}
inline double Value::Reader::getFloat64() const {
  KJ_IREQUIRE((which() == Value::FLOAT64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Value::Builder::getFloat64() {
  KJ_IREQUIRE((which() == Value::FLOAT64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setFloat64(double value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::FLOAT64);
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isText() const {
  return which() == Value::TEXT;
}
inline bool Value::Builder::isText() {
  return which() == Value::TEXT;
}
inline bool Value::Reader::hasText() const {
  if (which() != Value::TEXT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Value::Builder::hasText() {
  if (which() != Value::TEXT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Value::Reader::getText() const {
  KJ_IREQUIRE((which() == Value::TEXT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Value::Builder::getText() {
  KJ_IREQUIRE((which() == Value::TEXT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Value::Builder::setText( ::capnp::Text::Reader value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::TEXT);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Value::Builder::initText(unsigned int size) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::TEXT);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Value::Builder::adoptText(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::TEXT);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Value::Builder::disownText() {
  KJ_IREQUIRE((which() == Value::TEXT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Value::Reader::isData() const {
  return which() == Value::DATA;
}
inline bool Value::Builder::isData() {
  return which() == Value::DATA;
}
inline bool Value::Reader::hasData() const {
  if (which() != Value::DATA) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Value::Builder::hasData() {
  if (which() != Value::DATA) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Value::Reader::getData() const {
  KJ_IREQUIRE((which() == Value::DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Value::Builder::getData() {
  KJ_IREQUIRE((which() == Value::DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Value::Builder::setData( ::capnp::Data::Reader value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::DATA);
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Value::Builder::initData(unsigned int size) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::DATA);
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Value::Builder::adoptData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::DATA);
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Value::Builder::disownData() {
  KJ_IREQUIRE((which() == Value::DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Value::Reader::isList() const {
  return which() == Value::LIST;
}
inline bool Value::Builder::isList() {
  return which() == Value::LIST;
}
inline bool Value::Reader::hasList() const {
  if (which() != Value::LIST) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Value::Builder::hasList() {
  if (which() != Value::LIST) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader Value::Reader::getList() const {
  KJ_IREQUIRE((which() == Value::LIST),
              "Must check which() before get()ing a union member.");
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Value::Builder::getList() {
  KJ_IREQUIRE((which() == Value::LIST),
              "Must check which() before get()ing a union member.");
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Value::Builder::initList() {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::LIST);
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline bool Value::Reader::isEnum() const {
  return which() == Value::ENUM;
}
inline bool Value::Builder::isEnum() {
  return which() == Value::ENUM;
}
inline  ::uint16_t Value::Reader::getEnum() const {
  KJ_IREQUIRE((which() == Value::ENUM),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Value::Builder::getEnum() {
  KJ_IREQUIRE((which() == Value::ENUM),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setEnum( ::uint16_t value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::ENUM);
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isStruct() const {
  return which() == Value::STRUCT;
}
inline bool Value::Builder::isStruct() {
  return which() == Value::STRUCT;
}
inline bool Value::Reader::hasStruct() const {
  if (which() != Value::STRUCT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Value::Builder::hasStruct() {
  if (which() != Value::STRUCT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader Value::Reader::getStruct() const {
  KJ_IREQUIRE((which() == Value::STRUCT),
              "Must check which() before get()ing a union member.");
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Value::Builder::getStruct() {
  KJ_IREQUIRE((which() == Value::STRUCT),
              "Must check which() before get()ing a union member.");
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Value::Builder::initStruct() {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::STRUCT);
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline bool Value::Reader::isInterface() const {
  return which() == Value::INTERFACE;
}
inline bool Value::Builder::isInterface() {
  return which() == Value::INTERFACE;
}
inline  ::capnp::Void Value::Reader::getInterface() const {
  KJ_IREQUIRE((which() == Value::INTERFACE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Value::Builder::getInterface() {
  KJ_IREQUIRE((which() == Value::INTERFACE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Value::Builder::setInterface( ::capnp::Void value) {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::INTERFACE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Reader::isAnyPointer() const {
  return which() == Value::ANY_POINTER;
}
inline bool Value::Builder::isAnyPointer() {
  return which() == Value::ANY_POINTER;
}
inline bool Value::Reader::hasAnyPointer() const {
  if (which() != Value::ANY_POINTER) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Value::Builder::hasAnyPointer() {
  if (which() != Value::ANY_POINTER) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader Value::Reader::getAnyPointer() const {
  KJ_IREQUIRE((which() == Value::ANY_POINTER),
              "Must check which() before get()ing a union member.");
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Value::Builder::getAnyPointer() {
  KJ_IREQUIRE((which() == Value::ANY_POINTER),
              "Must check which() before get()ing a union member.");
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Value::Builder::initAnyPointer() {
  _builder.setDataField<Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::ANY_POINTER);
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline  ::uint64_t Annotation::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Annotation::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Annotation::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Annotation::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Annotation::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Value::Reader Annotation::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Value>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Value::Builder Annotation::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Value>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Value::Pipeline Annotation::Pipeline::getValue() {
  return  ::capnp::schema::Value::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Annotation::Builder::setValue( ::capnp::schema::Value::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Value>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Value::Builder Annotation::Builder::initValue() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Value>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Annotation::Builder::adoptValue(
    ::capnp::Orphan< ::capnp::schema::Value>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Value> Annotation::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Value>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Annotation::Reader::hasBrand() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Annotation::Builder::hasBrand() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::Brand::Reader Annotation::Reader::getBrand() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::Brand::Builder Annotation::Builder::getBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::Brand::Pipeline Annotation::Pipeline::getBrand() {
  return  ::capnp::schema::Brand::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Annotation::Builder::setBrand( ::capnp::schema::Brand::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::Brand::Builder Annotation::Builder::initBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Annotation::Builder::adoptBrand(
    ::capnp::Orphan< ::capnp::schema::Brand>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint16_t CapnpVersion::Reader::getMajor() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t CapnpVersion::Builder::getMajor() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CapnpVersion::Builder::setMajor( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t CapnpVersion::Reader::getMinor() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t CapnpVersion::Builder::getMinor() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void CapnpVersion::Builder::setMinor( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t CapnpVersion::Reader::getMicro() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t CapnpVersion::Builder::getMicro() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void CapnpVersion::Builder::setMicro( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool CodeGeneratorRequest::Reader::hasNodes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CodeGeneratorRequest::Builder::hasNodes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::Node>::Reader CodeGeneratorRequest::Reader::getNodes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::Node>::Builder CodeGeneratorRequest::Builder::getNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CodeGeneratorRequest::Builder::setNodes( ::capnp::List< ::capnp::schema::Node>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::Node>::Builder CodeGeneratorRequest::Builder::initNodes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CodeGeneratorRequest::Builder::adoptNodes(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::Node>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::Node>> CodeGeneratorRequest::Builder::disownNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::Node>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CodeGeneratorRequest::Reader::hasRequestedFiles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CodeGeneratorRequest::Builder::hasRequestedFiles() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>::Reader CodeGeneratorRequest::Reader::getRequestedFiles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>::Builder CodeGeneratorRequest::Builder::getRequestedFiles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CodeGeneratorRequest::Builder::setRequestedFiles( ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>::Builder CodeGeneratorRequest::Builder::initRequestedFiles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void CodeGeneratorRequest::Builder::adoptRequestedFiles(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>> CodeGeneratorRequest::Builder::disownRequestedFiles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool CodeGeneratorRequest::Reader::hasCapnpVersion() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool CodeGeneratorRequest::Builder::hasCapnpVersion() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::schema::CapnpVersion::Reader CodeGeneratorRequest::Reader::getCapnpVersion() const {
  return ::capnp::_::PointerHelpers< ::capnp::schema::CapnpVersion>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::schema::CapnpVersion::Builder CodeGeneratorRequest::Builder::getCapnpVersion() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::CapnpVersion>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::schema::CapnpVersion::Pipeline CodeGeneratorRequest::Pipeline::getCapnpVersion() {
  return  ::capnp::schema::CapnpVersion::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void CodeGeneratorRequest::Builder::setCapnpVersion( ::capnp::schema::CapnpVersion::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::CapnpVersion>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::schema::CapnpVersion::Builder CodeGeneratorRequest::Builder::initCapnpVersion() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::CapnpVersion>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void CodeGeneratorRequest::Builder::adoptCapnpVersion(
    ::capnp::Orphan< ::capnp::schema::CapnpVersion>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::schema::CapnpVersion>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::schema::CapnpVersion> CodeGeneratorRequest::Builder::disownCapnpVersion() {
  return ::capnp::_::PointerHelpers< ::capnp::schema::CapnpVersion>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint64_t CodeGeneratorRequest::RequestedFile::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t CodeGeneratorRequest::RequestedFile::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CodeGeneratorRequest::RequestedFile::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool CodeGeneratorRequest::RequestedFile::Reader::hasFilename() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CodeGeneratorRequest::RequestedFile::Builder::hasFilename() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CodeGeneratorRequest::RequestedFile::Reader::getFilename() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CodeGeneratorRequest::RequestedFile::Builder::getFilename() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CodeGeneratorRequest::RequestedFile::Builder::setFilename( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CodeGeneratorRequest::RequestedFile::Builder::initFilename(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CodeGeneratorRequest::RequestedFile::Builder::adoptFilename(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CodeGeneratorRequest::RequestedFile::Builder::disownFilename() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CodeGeneratorRequest::RequestedFile::Reader::hasImports() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CodeGeneratorRequest::RequestedFile::Builder::hasImports() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>::Reader CodeGeneratorRequest::RequestedFile::Reader::getImports() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>::Builder CodeGeneratorRequest::RequestedFile::Builder::getImports() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CodeGeneratorRequest::RequestedFile::Builder::setImports( ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>::Builder CodeGeneratorRequest::RequestedFile::Builder::initImports(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void CodeGeneratorRequest::RequestedFile::Builder::adoptImports(
    ::capnp::Orphan< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>> CodeGeneratorRequest::RequestedFile::Builder::disownImports() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::schema::CodeGeneratorRequest::RequestedFile::Import>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint64_t CodeGeneratorRequest::RequestedFile::Import::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t CodeGeneratorRequest::RequestedFile::Import::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CodeGeneratorRequest::RequestedFile::Import::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool CodeGeneratorRequest::RequestedFile::Import::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CodeGeneratorRequest::RequestedFile::Import::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CodeGeneratorRequest::RequestedFile::Import::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CodeGeneratorRequest::RequestedFile::Import::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CodeGeneratorRequest::RequestedFile::Import::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CodeGeneratorRequest::RequestedFile::Import::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CodeGeneratorRequest::RequestedFile::Import::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CodeGeneratorRequest::RequestedFile::Import::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace

#endif  // CAPNP_INCLUDED_a93fc509624c72d9_
