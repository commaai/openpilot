'\" t
.\"     Title: zmq_setsockopt
.\"    Author: [see the "AUTHORS" section]
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 02/18/2017
.\"    Manual: 0MQ Manual
.\"    Source: 0MQ 4.2.2
.\"  Language: English
.\"
.TH "ZMQ_SETSOCKOPT" "3" "02/18/2017" "0MQ 4\&.2\&.2" "0MQ Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
zmq_setsockopt \- set 0MQ socket options
.SH "SYNOPSIS"
.sp
\fBint zmq_setsockopt (void \fR\fB\fI*socket\fR\fR\fB, int \fR\fB\fIoption_name\fR\fR\fB, const void \fR\fB\fI*option_value\fR\fR\fB, size_t \fR\fB\fIoption_len\fR\fR\fB);\fR
.sp
Caution: All options, with the exception of ZMQ_SUBSCRIBE, ZMQ_UNSUBSCRIBE, ZMQ_LINGER, ZMQ_ROUTER_HANDOVER, ZMQ_ROUTER_MANDATORY, ZMQ_PROBE_ROUTER, ZMQ_XPUB_VERBOSE, ZMQ_XPUB_VERBOSER, ZMQ_REQ_CORRELATE, ZMQ_REQ_RELAXED, ZMQ_SNDHWM and ZMQ_RCVHWM, only take effect for subsequent socket bind/connects\&.
.sp
Specifically, security options take effect for subsequent bind/connect calls, and can be changed at any time to affect subsequent binds and/or connects\&.
.SH "DESCRIPTION"
.sp
The \fIzmq_setsockopt()\fR function shall set the option specified by the \fIoption_name\fR argument to the value pointed to by the \fIoption_value\fR argument for the 0MQ socket pointed to by the \fIsocket\fR argument\&. The \fIoption_len\fR argument is the size of the option value in bytes\&. For options taking a value of type "character string", the provided byte data should either contain no zero bytes, or end in a single zero byte (terminating ASCII NUL character)\&.
.sp
The following socket options can be set with the \fIzmq_setsockopt()\fR function:
.SS "ZMQ_AFFINITY: Set I/O thread affinity"
.sp
The \fIZMQ_AFFINITY\fR option shall set the I/O thread affinity for newly created connections on the specified \fIsocket\fR\&.
.sp
Affinity determines which threads from the 0MQ I/O thread pool associated with the socket\(cqs \fIcontext\fR shall handle newly created connections\&. A value of zero specifies no affinity, meaning that work shall be distributed fairly among all 0MQ I/O threads in the thread pool\&. For non\-zero values, the lowest bit corresponds to thread 1, second lowest bit to thread 2 and so on\&. For example, a value of 3 specifies that subsequent connections on \fIsocket\fR shall be handled exclusively by I/O threads 1 and 2\&.
.sp
See also \fBzmq_init\fR(3) for details on allocating the number of I/O threads for a specific \fIcontext\fR\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
uint64_t
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A (bitmap)
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
N/A
T}
.TE
.sp 1
.SS "ZMQ_BACKLOG: Set maximum length of the queue of outstanding connections"
.sp
The \fIZMQ_BACKLOG\fR option shall set the maximum length of the queue of outstanding peer connections for the specified \fIsocket\fR; this only applies to connection\-oriented transports\&. For details refer to your operating system documentation for the \fIlisten\fR function\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
connections
T}
T{
.sp
Default value
T}:T{
.sp
100
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, only for connection\-oriented transports\&.
T}
.TE
.sp 1
.SS "ZMQ_CONNECT_RID: Assign the next outbound connection id"
.sp
The \fIZMQ_CONNECT_RID\fR option sets the peer id of the next host connected via the zmq_connect() call, and immediately readies that connection for data transfer with the named id\&. This option applies only to the first subsequent call to zmq_connect(), calls thereafter use default connection behaviour\&.
.sp
Typical use is to set this socket option ahead of each zmq_connect() attempt to a new host\&. Each connection MUST be assigned a unique name\&. Assigning a name that is already in use is not allowed\&.
.sp
Useful when connecting ROUTER to ROUTER, or STREAM to STREAM, as it allows for immediate sending to peers\&. Outbound id framing requirements for ROUTER and STREAM sockets apply\&.
.sp
The peer id should be from 1 to 255 bytes long and MAY NOT start with binary zero\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
NULL
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_ROUTER, ZMQ_STREAM
T}
.TE
.sp 1
.SS "ZMQ_CONFLATE: Keep only last message"
.sp
If set, a socket shall keep only one message in its inbound/outbound queue, this message being the last message received/the last message to be sent\&. Ignores \fIZMQ_RCVHWM\fR and \fIZMQ_SNDHWM\fR options\&. Does not support multi\-part messages, in particular, only one part of it is kept in the socket internal queue\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
boolean
T}
T{
.sp
Default value
T}:T{
.sp
0 (false)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_PULL, ZMQ_PUSH, ZMQ_SUB, ZMQ_PUB, ZMQ_DEALER
T}
.TE
.sp 1
.SS "ZMQ_CONNECT_TIMEOUT: Set connect() timeout"
.sp
Sets how long to wait before timing\-out a connect() system call\&. The connect() system call normally takes a long time before it returns a time out error\&. Setting this option allows the library to time out the call at an earlier interval\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
0 (disabled)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_CURVE_PUBLICKEY: Set CURVE public key"
.sp
Sets the socket\(cqs long term public key\&. You must set this on CURVE client sockets, see \fBzmq_curve\fR(7)\&. You can provide the key as 32 binary bytes, or as a 40\-character string encoded in the Z85 encoding format and terminated in a null byte\&. The public key must always be used with the matching secret key\&. To generate a public/secret key pair, use \fBzmq_curve_keypair\fR(3)\&. To derive the public key from a secret key, use \fBzmq_curve_public\fR(3)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
an option value size of 40 is supported for backwards compatibility, though is deprecated\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data or Z85 text string
T}
T{
.sp
Option value size
T}:T{
.sp
32 or 41
T}
T{
.sp
Default value
T}:T{
.sp
NULL
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_CURVE_SECRETKEY: Set CURVE secret key"
.sp
Sets the socket\(cqs long term secret key\&. You must set this on both CURVE client and server sockets, see \fBzmq_curve\fR(7)\&. You can provide the key as 32 binary bytes, or as a 40\-character string encoded in the Z85 encoding format and terminated in a null byte\&. To generate a public/secret key pair, use \fBzmq_curve_keypair\fR(3)\&. To derive the public key from a secret key, use \fBzmq_curve_public\fR(3)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
an option value size of 40 is supported for backwards compatibility, though is deprecated\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data or Z85 text string
T}
T{
.sp
Option value size
T}:T{
.sp
32 or 41
T}
T{
.sp
Default value
T}:T{
.sp
NULL
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_CURVE_SERVER: Set CURVE server role"
.sp
Defines whether the socket will act as server for CURVE security, see \fBzmq_curve\fR(7)\&. A value of \fI1\fR means the socket will act as CURVE server\&. A value of \fI0\fR means the socket will not act as CURVE server, and its security role then depends on other option settings\&. Setting this to \fI0\fR shall reset the socket security to NULL\&. When you set this you must also set the server\(cqs secret key using the ZMQ_CURVE_SECRETKEY option\&. A server socket does not need to know its own public key\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_CURVE_SERVERKEY: Set CURVE server key"
.sp
Sets the socket\(cqs long term server key\&. You must set this on CURVE client sockets, see \fBzmq_curve\fR(7)\&. You can provide the key as 32 binary bytes, or as a 40\-character string encoded in the Z85 encoding format and terminated in a null byte\&. This key must have been generated together with the server\(cqs secret key\&. To generate a public/secret key pair, use \fBzmq_curve_keypair\fR(3)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
an option value size of 40 is supported for backwards compatibility, though is deprecated\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data or Z85 text string
T}
T{
.sp
Option value size
T}:T{
.sp
32 or 41
T}
T{
.sp
Default value
T}:T{
.sp
NULL
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_GSSAPI_PLAINTEXT: Disable GSSAPI encryption"
.sp
Defines whether communications on the socket will be encrypted, see \fBzmq_gssapi\fR(7)\&. A value of \fI1\fR means that communications will be plaintext\&. A value of \fI0\fR means communications will be encrypted\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0 (false)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_GSSAPI_PRINCIPAL: Set name of GSSAPI principal"
.sp
Sets the name of the principal for whom GSSAPI credentials should be acquired\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
character string
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
not set
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_GSSAPI_SERVER: Set GSSAPI server role"
.sp
Defines whether the socket will act as server for GSSAPI security, see \fBzmq_gssapi\fR(7)\&. A value of \fI1\fR means the socket will act as GSSAPI server\&. A value of \fI0\fR means the socket will act as GSSAPI client\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0 (false)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_GSSAPI_SERVICE_PRINCIPAL: Set name of GSSAPI service principal"
.sp
Sets the name of the principal of the GSSAPI server to which a GSSAPI client intends to connect\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
character string
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
not set
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_HANDSHAKE_IVL: Set maximum handshake interval"
.sp
The \fIZMQ_HANDSHAKE_IVL\fR option shall set the maximum handshake interval for the specified \fIsocket\fR\&. Handshaking is the exchange of socket configuration information (socket type, identity, security) that occurs when a connection is first opened, only for connection\-oriented transports\&. If handshaking does not complete within the configured time, the connection shall be closed\&. The value 0 means no handshake time limit\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
30000
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all but ZMQ_STREAM, only for connection\-oriented transports
T}
.TE
.sp 1
.SS "ZMQ_HEARTBEAT_IVL: Set interval between sending ZMTP heartbeats"
.sp
The \fIZMQ_HEARTBEAT_IVL\fR option shall set the interval between sending ZMTP heartbeats for the specified \fIsocket\fR\&. If this option is set and is greater than 0, then a \fIPING\fR ZMTP command will be sent every \fIZMQ_HEARTBEAT_IVL\fR milliseconds\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using connection\-oriented transports
T}
.TE
.sp 1
.SS "ZMQ_HEARTBEAT_TIMEOUT: Set timeout for ZMTP heartbeats"
.sp
The \fIZMQ_HEARTBEAT_TIMEOUT\fR option shall set how long to wait before timing\-out a connection after sending a \fIPING\fR ZMTP command and not receiving any traffic\&. This option is only valid if \fIZMQ_HEARTBEAT_IVL\fR is also set, and is greater than 0\&. The connection will time out if there is no traffic received after sending the \fIPING\fR command, but the received traffic does not have to be a \fIPONG\fR command \- any received traffic will cancel the timeout\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using connection\-oriented transports
T}
.TE
.sp 1
.SS "ZMQ_HEARTBEAT_TTL: Set the TTL value for ZMTP heartbeats"
.sp
The \fIZMQ_HEARTBEAT_TTL\fR option shall set the timeout on the remote peer for ZMTP heartbeats\&. If this option is greater than 0, the remote side shall time out the connection if it does not receive any more traffic within the TTL period\&. This option does not have any effect if \fIZMQ_HEARTBEAT_IVL\fR is not set or is 0\&. Internally, this value is rounded down to the nearest decisecond, any value less than 100 will have no effect\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using connection\-oriented transports
T}
.TE
.sp 1
.SS "ZMQ_IDENTITY: Set socket identity"
.sp
The \fIZMQ_IDENTITY\fR option shall set the identity of the specified \fIsocket\fR when connecting to a ROUTER socket\&. The identity should be from 1 to 255 bytes long and may contain any values\&.
.sp
If two clients use the same identity when connecting to a ROUTER, the results shall depend on the ZMQ_ROUTER_HANDOVER option setting\&. If that is not set (or set to the default of zero), the ROUTER socket shall reject clients trying to connect with an already\-used identity\&. If that option is set to 1, the ROUTER socket shall hand\-over the connection to the new client and disconnect the existing one\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
NULL
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_REQ, ZMQ_REP, ZMQ_ROUTER, ZMQ_DEALER\&.
T}
.TE
.sp 1
.SS "ZMQ_IMMEDIATE: Queue messages only to completed connections"
.sp
By default queues will fill on outgoing connections even if the connection has not completed\&. This can lead to "lost" messages on sockets with round\-robin routing (REQ, PUSH, DEALER)\&. If this option is set to 1, messages shall be queued only to completed connections\&. This will cause the socket to block if there are no other connections, but will prevent queues from filling on pipes awaiting connection\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
boolean
T}
T{
.sp
Default value
T}:T{
.sp
0 (false)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, only for connection\-oriented transports\&.
T}
.TE
.sp 1
.SS "ZMQ_INVERT_MATCHING: Invert message filtering"
.sp
Reverses the filtering behavior of PUB\-SUB sockets, when set to 1\&.
.sp
On \fIPUB\fR and \fIXPUB\fR sockets, this causes messages to be sent to all connected sockets \fIexcept\fR those subscribed to a prefix that matches the message\&. On \fISUB\fR sockets, this causes only incoming messages that do \fInot\fR match any of the socket\(cqs subscriptions to be received by the user\&.
.sp
Whenever \fIZMQ_INVERT_MATCHING\fR is set to 1 on a \fIPUB\fR socket, all \fISUB\fR sockets connecting to it must also have the option set to 1\&. Failure to do so will have the \fISUB\fR sockets reject everything the \fIPUB\fR socket sends them\&. \fIXSUB\fR sockets do not need to do this because they do not filter incoming messages\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0,1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_PUB, ZMQ_XPUB, ZMQ_SUB
T}
.TE
.sp 1
.SS "ZMQ_IPV6: Enable IPv6 on socket"
.sp
Set the IPv6 option for the socket\&. A value of 1 means IPv6 is enabled on the socket, while 0 means the socket will use only IPv4\&. When IPv6 is enabled the socket will connect to, or accept connections from, both IPv4 and IPv6 hosts\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
boolean
T}
T{
.sp
Default value
T}:T{
.sp
0 (false)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_LINGER: Set linger period for socket shutdown"
.sp
The \fIZMQ_LINGER\fR option shall set the linger period for the specified \fIsocket\fR\&. The linger period determines how long pending messages which have yet to be sent to a peer shall linger in memory after a socket is disconnected with \fBzmq_disconnect\fR(3) or closed with \fBzmq_close\fR(3), and further affects the termination of the socket\(cqs context with \fBzmq_ctx_term\fR(3)\&. The following outlines the different behaviours:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A value of
\fI\-1\fR
specifies an infinite linger period\&. Pending messages shall not be discarded after a call to
\fIzmq_disconnect()\fR
or
\fIzmq_close()\fR; attempting to terminate the socket\(cqs context with
\fIzmq_ctx_term()\fR
shall block until all pending messages have been sent to a peer\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The value of
\fI0\fR
specifies no linger period\&. Pending messages shall be discarded immediately after a call to
\fIzmq_disconnect()\fR
or
\fIzmq_close()\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Positive values specify an upper bound for the linger period in milliseconds\&. Pending messages shall not be discarded after a call to
\fIzmq_disconnect()\fR
or
\fIzmq_close()\fR; attempting to terminate the socket\(cqs context with
\fIzmq_ctx_term()\fR
shall block until either all pending messages have been sent to a peer, or the linger period expires, after which any pending messages shall be discarded\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
Option value type
T}:T{
int
T}
T{
Option value unit
T}:T{
milliseconds
T}
T{
Default value
T}:T{
30000 (thirty seconds)
T}
T{
Applicable socket types
T}:T{
all
T}
.TE
.sp 1
.RE
.SS "ZMQ_MAXMSGSIZE: Maximum acceptable inbound message size"
.sp
Limits the size of the inbound message\&. If a peer sends a message larger than ZMQ_MAXMSGSIZE it is disconnected\&. Value of \-1 means \fIno limit\fR\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int64_t
T}
T{
.sp
Option value unit
T}:T{
.sp
bytes
T}
T{
.sp
Default value
T}:T{
.sp
\-1
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_MULTICAST_HOPS: Maximum network hops for multicast packets"
.sp
Sets the time\-to\-live field in every multicast packet sent from this socket\&. The default is 1 which means that the multicast packets don\(cqt leave the local network\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
network hops
T}
T{
.sp
Default value
T}:T{
.sp
1
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using multicast transports
T}
.TE
.sp 1
.SS "ZMQ_MULTICAST_MAXTPDU: Maximum transport data unit size for multicast packets"
.sp
Sets the maximum transport data unit size used for outbound multicast packets\&.
.sp
This must be set at or below the minimum Maximum Transmission Unit (MTU) for all network paths over which multicast reception is required\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
bytes
T}
T{
.sp
Default value
T}:T{
.sp
1500
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using multicast transports
T}
.TE
.sp 1
.SS "ZMQ_PLAIN_PASSWORD: Set PLAIN security password"
.sp
Sets the password for outgoing connections over TCP or IPC\&. If you set this to a non\-null value, the security mechanism used for connections shall be PLAIN, see \fBzmq_plain\fR(7)\&. If you set this to a null value, the security mechanism used for connections shall be NULL, see \fBzmq_null\fR(3)\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
character string
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
not set
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_PLAIN_SERVER: Set PLAIN server role"
.sp
Defines whether the socket will act as server for PLAIN security, see \fBzmq_plain\fR(7)\&. A value of \fI1\fR means the socket will act as PLAIN server\&. A value of \fI0\fR means the socket will not act as PLAIN server, and its security role then depends on other option settings\&. Setting this to \fI0\fR shall reset the socket security to NULL\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_PLAIN_USERNAME: Set PLAIN security username"
.sp
Sets the username for outgoing connections over TCP or IPC\&. If you set this to a non\-null value, the security mechanism used for connections shall be PLAIN, see \fBzmq_plain\fR(7)\&. If you set this to a null value, the security mechanism used for connections shall be NULL, see \fBzmq_null\fR(3)\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
character string
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
not set
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_USE_FD: Set the pre\-allocated socket file descriptor"
.sp
When set to a positive integer value before zmq_bind is called on the socket, the socket shall use the corresponding file descriptor for connections over TCP or IPC instead of allocating a new file descriptor\&. Useful for writing systemd socket activated services\&. If set to \-1 (default), a new file descriptor will be allocated instead (default behaviour)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
if set after calling zmq_bind, this option shall have no effect\&. NOTE: the file descriptor passed through MUST have been ran through the "bind" and "listen" system calls beforehand\&. Also, socket option that would normally be passed through zmq_setsockopt like TCP buffers length, IP_TOS or SO_REUSEADDR MUST be set beforehand by the caller, as they must be set before the socket is bound\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
file descriptor
T}
T{
.sp
Default value
T}:T{
.sp
\-1
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all bound sockets, when using IPC or TCP transport
T}
.TE
.sp 1
.SS "ZMQ_PROBE_ROUTER: bootstrap connections to ROUTER sockets"
.sp
When set to 1, the socket will automatically send an empty message when a new connection is made or accepted\&. You may set this on REQ, DEALER, or ROUTER sockets connected to a ROUTER socket\&. The application must filter such empty messages\&. The ZMQ_PROBE_ROUTER option in effect provides the ROUTER application with an event signaling the arrival of a new peer\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
do not set this option on a socket that talks to any other socket types: the results are undefined\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_ROUTER, ZMQ_DEALER, ZMQ_REQ
T}
.TE
.sp 1
.SS "ZMQ_RATE: Set multicast data rate"
.sp
The \fIZMQ_RATE\fR option shall set the maximum send or receive data rate for multicast transports such as \fBzmq_pgm\fR(7) using the specified \fIsocket\fR\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
kilobits per second
T}
T{
.sp
Default value
T}:T{
.sp
100
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using multicast transports
T}
.TE
.sp 1
.SS "ZMQ_RCVBUF: Set kernel receive buffer size"
.sp
The \fIZMQ_RCVBUF\fR option shall set the underlying kernel receive buffer size for the \fIsocket\fR to the specified size in bytes\&. A value of \-1 means leave the OS default unchanged\&. For details refer to your operating system documentation for the \fISO_RCVBUF\fR socket option\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
bytes
T}
T{
.sp
Default value
T}:T{
.sp
\-1
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_RCVHWM: Set high water mark for inbound messages"
.sp
The \fIZMQ_RCVHWM\fR option shall set the high water mark for inbound messages on the specified \fIsocket\fR\&. The high water mark is a hard limit on the maximum number of outstanding messages 0MQ shall queue in memory for any single peer that the specified \fIsocket\fR is communicating with\&. A value of zero means no limit\&.
.sp
If this limit has been reached the socket shall enter an exceptional state and depending on the socket type, 0MQ shall take appropriate action such as blocking or dropping sent messages\&. Refer to the individual socket descriptions in \fBzmq_socket\fR(3) for details on the exact action taken for each socket type\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
messages
T}
T{
.sp
Default value
T}:T{
.sp
1000
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_RCVTIMEO: Maximum time before a recv operation returns with EAGAIN"
.sp
Sets the timeout for receive operation on the socket\&. If the value is 0, \fIzmq_recv(3)\fR will return immediately, with a EAGAIN error if there is no message to receive\&. If the value is \-1, it will block until a message is available\&. For all other values, it will wait for a message for that amount of time before returning with an EAGAIN error\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
\-1 (infinite)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_RECONNECT_IVL: Set reconnection interval"
.sp
The \fIZMQ_RECONNECT_IVL\fR option shall set the initial reconnection interval for the specified \fIsocket\fR\&. The reconnection interval is the period 0MQ shall wait between attempts to reconnect disconnected peers when using connection\-oriented transports\&. The value \-1 means no reconnection\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
The reconnection interval may be randomized by 0MQ to prevent reconnection storms in topologies with a large number of peers per socket\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
100
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, only for connection\-oriented transports
T}
.TE
.sp 1
.SS "ZMQ_RECONNECT_IVL_MAX: Set maximum reconnection interval"
.sp
The \fIZMQ_RECONNECT_IVL_MAX\fR option shall set the maximum reconnection interval for the specified \fIsocket\fR\&. This is the maximum period 0MQ shall wait between attempts to reconnect\&. On each reconnect attempt, the previous interval shall be doubled untill ZMQ_RECONNECT_IVL_MAX is reached\&. This allows for exponential backoff strategy\&. Default value means no exponential backoff is performed and reconnect interval calculations are only based on ZMQ_RECONNECT_IVL\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
Values less than ZMQ_RECONNECT_IVL will be ignored\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
0 (only use ZMQ_RECONNECT_IVL)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, only for connection\-oriented transports
T}
.TE
.sp 1
.SS "ZMQ_RECOVERY_IVL: Set multicast recovery interval"
.sp
The \fIZMQ_RECOVERY_IVL\fR option shall set the recovery interval for multicast transports using the specified \fIsocket\fR\&. The recovery interval determines the maximum time in milliseconds that a receiver can be absent from a multicast group before unrecoverable data loss will occur\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBCaution\fR
.ps -1
.br
.sp
Exercise care when setting large recovery intervals as the data needed for recovery will be held in memory\&. For example, a 1 minute recovery interval at a data rate of 1Gbps requires a 7GB in\-memory buffer\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
10000
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using multicast transports
T}
.TE
.sp 1
.SS "ZMQ_REQ_CORRELATE: match replies with requests"
.sp
The default behaviour of REQ sockets is to rely on the ordering of messages to match requests and responses and that is usually sufficient\&. When this option is set to 1, the REQ socket will prefix outgoing messages with an extra frame containing a request id\&. That means the full message is (request id, 0, user frames\&...)\&. The REQ socket will discard all incoming messages that don\(cqt begin with these two frames\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_REQ
T}
.TE
.sp 1
.SS "ZMQ_REQ_RELAXED: relax strict alternation between request and reply"
.sp
By default, a REQ socket does not allow initiating a new request with \fIzmq_send(3)\fR until the reply to the previous one has been received\&. When set to 1, sending another message is allowed and previous replies will be discarded if any\&. The request\-reply state machine is reset and a new request is sent to the next available peer\&.
.sp
If set to 1, also enable ZMQ_REQ_CORRELATE to ensure correct matching of requests and replies\&. Otherwise a late reply to an aborted request can be reported as the reply to the superseding request\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_REQ
T}
.TE
.sp 1
.SS "ZMQ_ROUTER_HANDOVER: handle duplicate client identities on ROUTER sockets"
.sp
If two clients use the same identity when connecting to a ROUTER, the results shall depend on the ZMQ_ROUTER_HANDOVER option setting\&. If that is not set (or set to the default of zero), the ROUTER socket shall reject clients trying to connect with an already\-used identity\&. If that option is set to 1, the ROUTER socket shall hand\-over the connection to the new client and disconnect the existing one\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_ROUTER
T}
.TE
.sp 1
.SS "ZMQ_ROUTER_MANDATORY: accept only routable messages on ROUTER sockets"
.sp
Sets the ROUTER socket behaviour when an unroutable message is encountered\&. A value of 0 is the default and discards the message silently when it cannot be routed or the peers SNDHWM is reached\&. A value of 1 returns an \fIEHOSTUNREACH\fR error code if the message cannot be routed or \fIEAGAIN\fR error code if the SNDHWM is reached and ZMQ_DONTWAIT was used\&. Without ZMQ_DONTWAIT it will block until the SNDTIMEO is reached or a spot in the send queue opens up\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_ROUTER
T}
.TE
.sp 1
.SS "ZMQ_ROUTER_RAW: switch ROUTER socket to raw mode"
.sp
Sets the raw mode on the ROUTER, when set to 1\&. When the ROUTER socket is in raw mode, and when using the tcp:// transport, it will read and write TCP data without 0MQ framing\&. This lets 0MQ applications talk to non\-0MQ applications\&. When using raw mode, you cannot set explicit identities, and the ZMQ_SNDMORE flag is ignored when sending data messages\&. In raw mode you can close a specific connection by sending it a zero\-length message (following the identity frame)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
This option is deprecated, please use ZMQ_STREAM sockets instead\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_ROUTER
T}
.TE
.sp 1
.SS "ZMQ_SNDBUF: Set kernel transmit buffer size"
.sp
The \fIZMQ_SNDBUF\fR option shall set the underlying kernel transmit buffer size for the \fIsocket\fR to the specified size in bytes\&. A value of \-1 means leave the OS default unchanged\&. For details please refer to your operating system documentation for the \fISO_SNDBUF\fR socket option\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
bytes
T}
T{
.sp
Default value
T}:T{
.sp
\-1
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_SNDHWM: Set high water mark for outbound messages"
.sp
The \fIZMQ_SNDHWM\fR option shall set the high water mark for outbound messages on the specified \fIsocket\fR\&. The high water mark is a hard limit on the maximum number of outstanding messages 0MQ shall queue in memory for any single peer that the specified \fIsocket\fR is communicating with\&. A value of zero means no limit\&.
.sp
If this limit has been reached the socket shall enter an exceptional state and depending on the socket type, 0MQ shall take appropriate action such as blocking or dropping sent messages\&. Refer to the individual socket descriptions in \fBzmq_socket\fR(3) for details on the exact action taken for each socket type\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
0MQ does not guarantee that the socket will accept as many as ZMQ_SNDHWM messages, and the actual limit may be as much as 60\-70% lower depending on the flow of messages on the socket\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
messages
T}
T{
.sp
Default value
T}:T{
.sp
1000
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_SNDTIMEO: Maximum time before a send operation returns with EAGAIN"
.sp
Sets the timeout for send operation on the socket\&. If the value is 0, \fIzmq_send(3)\fR will return immediately, with a EAGAIN error if the message cannot be sent\&. If the value is \-1, it will block until the message is sent\&. For all other values, it will try to send the message for that amount of time before returning with an EAGAIN error\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
\-1 (infinite)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_SOCKS_PROXY: Set SOCKS5 proxy address"
.sp
Sets the SOCKS5 proxy address that shall be used by the socket for the TCP connection(s)\&. Does not support SOCKS5 authentication\&. If the endpoints are domain names instead of addresses they shall not be resolved and they shall be forwarded unchanged to the SOCKS proxy service in the client connection request message (address type 0x03 domain name)\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
character string
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
not set
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_STREAM_NOTIFY: send connect and disconnect notifications"
.sp
Enables connect and disconnect notifications on a STREAM socket, when set to 1\&. When notifications are enabled, the socket delivers a zero\-length message when a peer connects or disconnects\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
1
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_STREAM
T}
.TE
.sp 1
.SS "ZMQ_SUBSCRIBE: Establish message filter"
.sp
The \fIZMQ_SUBSCRIBE\fR option shall establish a new message filter on a \fIZMQ_SUB\fR socket\&. Newly created \fIZMQ_SUB\fR sockets shall filter out all incoming messages, therefore you should call this option to establish an initial message filter\&.
.sp
An empty \fIoption_value\fR of length zero shall subscribe to all incoming messages\&. A non\-empty \fIoption_value\fR shall subscribe to all messages beginning with the specified prefix\&. Multiple filters may be attached to a single \fIZMQ_SUB\fR socket, in which case a message shall be accepted if it matches at least one filter\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
N/A
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_SUB
T}
.TE
.sp 1
.SS "ZMQ_TCP_KEEPALIVE: Override SO_KEEPALIVE socket option"
.sp
Override \fISO_KEEPALIVE\fR socket option (where supported by OS)\&. The default value of \-1 means to skip any overrides and leave it to OS default\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
\-1,0,1
T}
T{
.sp
Default value
T}:T{
.sp
\-1 (leave to OS default)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_TCP_KEEPALIVE_CNT: Override TCP_KEEPCNT socket option"
.sp
Override \fITCP_KEEPCNT\fR socket option (where supported by OS)\&. The default value of \-1 means to skip any overrides and leave it to OS default\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
\-1,>0
T}
T{
.sp
Default value
T}:T{
.sp
\-1 (leave to OS default)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_TCP_KEEPALIVE_IDLE: Override TCP_KEEPIDLE (or TCP_KEEPALIVE on some OS)"
.sp
Override \fITCP_KEEPIDLE\fR (or \fITCP_KEEPALIVE\fR on some OS) socket option (where supported by OS)\&. The default value of \-1 means to skip any overrides and leave it to OS default\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
\-1,>0
T}
T{
.sp
Default value
T}:T{
.sp
\-1 (leave to OS default)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_TCP_KEEPALIVE_INTVL: Override TCP_KEEPINTVL socket option"
.sp
Override \fITCP_KEEPINTVL\fR socket option(where supported by OS)\&. The default value of \-1 means to skip any overrides and leave it to OS default\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
\-1,>0
T}
T{
.sp
Default value
T}:T{
.sp
\-1 (leave to OS default)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_TCP_MAXRT: Set TCP Maximum Retransmit Timeout"
.sp
On OSes where it is supported, sets how long before an unacknowledged TCP retransmit times out\&. The system normally attempts many TCP retransmits following an exponential backoff strategy\&. This means that after a network outage, it may take a long time before the session can be re\-established\&. Setting this option allows the timeout to happen at a shorter interval\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
0 (leave to OS default)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_TOS: Set the Type\-of\-Service on socket"
.sp
Sets the ToS fields (Differentiated services (DS) and Explicit Congestion Notification (ECN) field of the IP header\&. The ToS field is typically used to specify a packets priority\&. The availability of this option is dependent on intermediate network equipment that inspect the ToS field and provide a path for low\-delay, high\-throughput, highly\-reliable service, etc\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
>0
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, only for connection\-oriented transports
T}
.TE
.sp 1
.SS "ZMQ_UNSUBSCRIBE: Remove message filter"
.sp
The \fIZMQ_UNSUBSCRIBE\fR option shall remove an existing message filter on a \fIZMQ_SUB\fR socket\&. The filter specified must match an existing filter previously established with the \fIZMQ_SUBSCRIBE\fR option\&. If the socket has several instances of the same filter attached the \fIZMQ_UNSUBSCRIBE\fR option shall remove only one instance, leaving the rest in place and functional\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
N/A
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_SUB
T}
.TE
.sp 1
.SS "ZMQ_XPUB_VERBOSE: pass subscribe messages on XPUB socket"
.sp
Sets the \fIXPUB\fR socket behaviour on new subscriptions\&. If enabled, the socket passes all subscribe messages to the caller\&. If disabled, these are not visible to the caller\&. The default is 0 (disabled)\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_XPUB
T}
.TE
.sp 1
.SS "ZMQ_XPUB_VERBOSER: pass subscribe and unsubscribe messages on XPUB socket"
.sp
Sets the \fIXPUB\fR socket behaviour on new subscriptions and ubsubscriptions\&. If enabled, the socket passes all subscribe and unsubscribe messages to the caller\&. If disabled, these are not visible to the caller\&. The default is 0 (disabled)\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_XPUB
T}
.TE
.sp 1
.SS "ZMQ_XPUB_MANUAL: change the subscription handling to manual"
.sp
Sets the \fIXPUB\fR socket subscription handling mode manual/automatic\&. A value of \fI0\fR is the default and subscription requests will be handled automatically\&. A value of \fI1\fR will change the subscription requests handling to manual, with manual mode subscription requests are not added to the subscription list\&. To add subscription the user need to call setsockopt with ZMQ_SUBSCRIBE on XPUB socket\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_XPUB
T}
.TE
.sp 1
.SS "ZMQ_XPUB_NODROP: do not silently drop messages if SENDHWM is reached"
.sp
Sets the \fIXPUB\fR socket behaviour to return error EAGAIN if SENDHWM is reached and the message could not be send\&.
.sp
A value of 0 is the default and drops the message silently when the peers SNDHWM is reached\&. A value of 1 returns an \fIEAGAIN\fR error code if the SNDHWM is reached and ZMQ_DONTWAIT was used\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_XPUB, ZMQ_PUB
T}
.TE
.sp 1
.SS "ZMQ_XPUB_WELCOME_MSG: set welcome message that will be received by subscriber when connecting"
.sp
Sets a welcome message the will be recieved by subscriber when connecting\&. Subscriber must subscribe to the Welcome message before connecting\&. Welcome message will also be sent on reconnecting\&. For welcome message to work well user must poll on incoming subscription messages on the XPUB socket and handle them\&.
.sp
Use NULL and lenght of zero to disable welcome message\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
NULL
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_XPUB
T}
.TE
.sp 1
.SS "ZMQ_ZAP_DOMAIN: Set RFC 27 authentication domain"
.sp
Sets the domain for ZAP (ZMQ RFC 27) authentication\&. For NULL security (the default on all tcp:// connections), ZAP authentication only happens if you set a non\-empty domain\&. For PLAIN and CURVE security, ZAP requests are always made, if there is a ZAP handler present\&. See \m[blue]\fBhttp://rfc\&.zeromq\&.org/spec:27\fR\m[] for more details\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
character string
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
not set
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_TCP_ACCEPT_FILTER: Assign filters to allow new TCP connections"
.sp
Assign an arbitrary number of filters that will be applied for each new TCP transport connection on a listening socket\&. If no filters are applied, then the TCP transport allows connections from any IP address\&. If at least one filter is applied then new connection source ip should be matched\&. To clear all filters call zmq_setsockopt(socket, ZMQ_TCP_ACCEPT_FILTER, NULL, 0)\&. Filter is a null\-terminated string with ipv6 or ipv4 CIDR\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
This option is deprecated, please use authentication via the ZAP API and IP address whitelisting / blacklisting\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
no filters (allow from all)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all listening sockets, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_IPC_FILTER_GID: Assign group ID filters to allow new IPC connections"
.sp
Assign an arbitrary number of filters that will be applied for each new IPC transport connection on a listening socket\&. If no IPC filters are applied, then the IPC transport allows connections from any process\&. If at least one UID, GID, or PID filter is applied then new connection credentials should be matched\&. To clear all GID filters call zmq_setsockopt(socket, ZMQ_IPC_FILTER_GID, NULL, 0)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
GID filters are only available on platforms supporting SO_PEERCRED or LOCAL_PEERCRED socket options (currently only Linux and later versions of OS X)\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
This option is deprecated, please use authentication via the ZAP API and IPC whitelisting / blacklisting\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
gid_t
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
no filters (allow from all)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all listening sockets, when using IPC transports\&.
T}
.TE
.sp 1
.SS "ZMQ_IPC_FILTER_PID: Assign process ID filters to allow new IPC connections"
.sp
Assign an arbitrary number of filters that will be applied for each new IPC transport connection on a listening socket\&. If no IPC filters are applied, then the IPC transport allows connections from any process\&. If at least one UID, GID, or PID filter is applied then new connection credentials should be matched\&. To clear all PID filters call zmq_setsockopt(socket, ZMQ_IPC_FILTER_PID, NULL, 0)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
PID filters are only available on platforms supporting the SO_PEERCRED socket option (currently only Linux)\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
This option is deprecated, please use authentication via the ZAP API and IPC whitelisting / blacklisting\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
pid_t
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
no filters (allow from all)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all listening sockets, when using IPC transports\&.
T}
.TE
.sp 1
.SS "ZMQ_IPC_FILTER_UID: Assign user ID filters to allow new IPC connections"
.sp
Assign an arbitrary number of filters that will be applied for each new IPC transport connection on a listening socket\&. If no IPC filters are applied, then the IPC transport allows connections from any process\&. If at least one UID, GID, or PID filter is applied then new connection credentials should be matched\&. To clear all UID filters call zmq_setsockopt(socket, ZMQ_IPC_FILTER_UID, NULL, 0)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
UID filters are only available on platforms supporting SO_PEERCRED or LOCAL_PEERCRED socket options (currently only Linux and later versions of OS X)\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
This option is deprecated, please use authentication via the ZAP API and IPC whitelisting / blacklisting\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
uid_t
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
no filters (allow from all)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all listening sockets, when using IPC transports\&.
T}
.TE
.sp 1
.SS "ZMQ_IPV4ONLY: Use IPv4\-only on socket"
.sp
Set the IPv4\-only option for the socket\&. This option is deprecated\&. Please use the ZMQ_IPV6 option\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
boolean
T}
T{
.sp
Default value
T}:T{
.sp
1 (true)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_VMCI_BUFFER_SIZE: Set buffer size of the VMCI socket"
.sp
The ZMQ_VMCI_BUFFER_SIZE option shall set the size of the underlying buffer for the socket\&. Used during negotiation before the connection is established\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
uint64_t
T}
T{
.sp
Option value unit
T}:T{
.sp
bytes
T}
T{
.sp
Default value
T}:T{
.sp
65546
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using VMCI transport
T}
.TE
.sp 1
.SS "ZMQ_VMCI_BUFFER_MIN_SIZE: Set min buffer size of the VMCI socket"
.sp
The ZMQ_VMCI_BUFFER_MIN_SIZE option shall set the min size of the underlying buffer for the socket\&. Used during negotiation before the connection is established\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
uint64_t
T}
T{
.sp
Option value unit
T}:T{
.sp
bytes
T}
T{
.sp
Default value
T}:T{
.sp
128
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using VMCI transport
T}
.TE
.sp 1
.SS "ZMQ_VMCI_BUFFER_MAX_SIZE: Set max buffer size of the VMCI socket"
.sp
The ZMQ_VMCI_BUFFER_MAX_SIZE option shall set the max size of the underlying buffer for the socket\&. Used during negotiation before the connection is established\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
uint64_t
T}
T{
.sp
Option value unit
T}:T{
.sp
bytes
T}
T{
.sp
Default value
T}:T{
.sp
262144
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using VMCI transport
T}
.TE
.sp 1
.SS "ZMQ_VMCI_CONNECT_TIMEOUT: Set connection timeout of the VMCI socket"
.sp
The ZMQ_VMCI_CONNECT_TIMEOUT option shall set connection timeout for the socket\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
\-1
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using VMCI transport
T}
.TE
.sp 1
.SH "RETURN VALUE"
.sp
The \fIzmq_setsockopt()\fR function shall return zero if successful\&. Otherwise it shall return \-1 and set \fIerrno\fR to one of the values defined below\&.
.SH "ERRORS"
.PP
\fBEINVAL\fR
.RS 4
The requested option
\fIoption_name\fR
is unknown, or the requested
\fIoption_len\fR
or
\fIoption_value\fR
is invalid\&.
.RE
.PP
\fBETERM\fR
.RS 4
The 0MQ
\fIcontext\fR
associated with the specified
\fIsocket\fR
was terminated\&.
.RE
.PP
\fBENOTSOCK\fR
.RS 4
The provided
\fIsocket\fR
was invalid\&.
.RE
.PP
\fBEINTR\fR
.RS 4
The operation was interrupted by delivery of a signal\&.
.RE
.SH "EXAMPLE"
.PP
\fBSubscribing to messages on a ZMQ_SUB socket\fR. 
.sp
.if n \{\
.RS 4
.\}
.nf
/* Subscribe to all messages */
rc = zmq_setsockopt (socket, ZMQ_SUBSCRIBE, "", 0);
assert (rc == 0);
/* Subscribe to messages prefixed with "ANIMALS\&.CATS" */
rc = zmq_setsockopt (socket, ZMQ_SUBSCRIBE, "ANIMALS\&.CATS", 12);
.fi
.if n \{\
.RE
.\}
.PP
\fBSetting I/O thread affinity\fR. 
.sp
.if n \{\
.RS 4
.\}
.nf
int64_t affinity;
/* Incoming connections on TCP port 5555 shall be handled by I/O thread 1 */
affinity = 1;
rc = zmq_setsockopt (socket, ZMQ_AFFINITY, &affinity, sizeof (affinity));
assert (rc);
rc = zmq_bind (socket, "tcp://lo:5555");
assert (rc);
/* Incoming connections on TCP port 5556 shall be handled by I/O thread 2 */
affinity = 2;
rc = zmq_setsockopt (socket, ZMQ_AFFINITY, &affinity, sizeof (affinity));
assert (rc);
rc = zmq_bind (socket, "tcp://lo:5556");
assert (rc);
.fi
.if n \{\
.RE
.\}
.sp
.SH "SEE ALSO"
.sp
\fBzmq_getsockopt\fR(3) \fBzmq_socket\fR(3) \fBzmq_plain\fR(7) \fBzmq_curve\fR(7) \fBzmq\fR(7)
.SH "AUTHORS"
.sp
This page was written by the 0MQ community\&. To make a change please read the 0MQ Contribution Policy at \m[blue]\fBhttp://www\&.zeromq\&.org/docs:contributing\fR\m[]\&.
