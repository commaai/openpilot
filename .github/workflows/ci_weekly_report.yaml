name: weekly CI test report
on:
  schedule:
    - cron: '37 9 * * 1' # 9:37AM UTC -> 2:37AM PST every monday
  workflow_dispatch:
    inputs:
      ci_runs:
        description: 'The amount of runs to trigger in CI test report'
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  CI_RUNS: ${{ github.event.inputs.ci_runs || '50' }}

jobs:
  setup:
    if: github.repository == 'commaai/openpilot'
    runs-on: ubuntu-latest
    outputs:
      ci_runs: ${{ steps.ci_runs_setup.outputs.matrix }}
    steps:
      - id: ci_runs_setup
        name: CI_RUNS=${{ env.CI_RUNS }}
        run: |
          matrix=$(python3 -c "import json; print(json.dumps({ 'run_number' : [x for x in range(${{ env.CI_RUNS }})] }))")
          echo $matrix
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

  ci_matrix_run:
    needs: [ setup ]
    strategy:
      fail-fast: false
      matrix: ${{fromJSON(needs.setup.outputs.ci_runs)}}
    uses: commaai/openpilot/.github/workflows/ci_weekly_run.yaml@master
    with:
      run_number: ${{ matrix.run_number }}

  report:
    needs: [ci_matrix_run]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Get job results
        uses: actions/github-script@v7
        id: get-job-results
        with:
          script: |
            const jobs = await github
              .paginate("GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt}/jobs", {
                owner: "commaai",
                repo: "${{ github.event.repository.name }}",
                run_id: "${{ github.run_id }}",
                attempt: "${{ github.run_attempt }}",
              })
            var report = {}
            jobs.slice(1, jobs.length-1).forEach(job => {
              if (job.conclusion === "skipped") return;
              const jobName = job.name.split('/')[2].trim();
              report[jobName] = report[jobName] || { successes: [], failures: [], cancelled: [] };
              switch (job.conclusion) {
                case "success":
                  report[jobName].successes.push(job.html_url); break;
                case "failure":
                  report[jobName].failures.push(job.html_url); break;
                case "cancelled":
                  report[jobName].cancelled.push(job.html_url); break;
              }
            });
            return JSON.stringify(report);

      - name: Add job results to summary
        env:
          JOB_RESULTS: ${{ fromJSON(steps.get-job-results.outputs.result) }}
        run: |
          echo $JOB_RESULTS > job_results.json
          echo "# CI Job Summary - ${{ env.CI_RUNS }} Runs" >> $GITHUB_STEP_SUMMARY
          echo "| | Job | âœ… Passing | âŒ Failure Details |" >> $GITHUB_STEP_SUMMARY
          echo "| --- | --- | --- | --- |" >> $GITHUB_STEP_SUMMARY

          jq -r 'keys[]' job_results.json |
          while IFS= read -r job; do
            successes=$(jq -r ".[\"$job\"].successes | length" job_results.json)
            pass_percent=$((100 * successes / ${{ env.CI_RUNS }}))

            green=$((5 * successes / ${{ env.CI_RUNS }}))
            gradient=""
            for i in $(seq 5); do
              if [ $i -le $green ]; then
                gradient+="ðŸŸ©"
              else
                gradient+="ðŸŸ¥"
              fi
            done

            failure_links=""
            for failure in $(jq -r ".[\"$job\"].failures[]" job_results.json); do
              failure_links+="[log]($failure), "
            done

            echo "| $gradient | $job | $pass_percent%  | ${failure_links%, } |" >> $GITHUB_STEP_SUMMARY
          done