# autogenerated from AMD ISA PDF - do not edit
# ruff: noqa: E501
from extra.assembly.amd.autogen.rdna4.enum import DSOp, SMEMOp, SOP1Op, SOP2Op, SOPCOp, SOPKOp, SOPPOp, VBUFFEROp, VFLATOp, VGLOBALOp, VIMAGEOp, VINTERPOp, VOP1Op, VOP2Op, VOP3Op, VOP3POp, VOP3SDOp, VOPCOp, VOPDOp, VSAMPLEOp, VSCRATCHOp

PCODE = {
  DSOp.DS_ADD_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nMEM[addr].u32 += DATA.u32;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_SUB_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nMEM[addr].u32 -= DATA.u32;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_RSUB_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nMEM[addr].u32 = DATA.u32 - MEM[addr].u32;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_INC_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_DEC_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_MIN_I32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].i32;\nsrc = DATA.i32;\nMEM[addr].i32 = src < tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  DSOp.DS_MAX_I32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].i32;\nsrc = DATA.i32;\nMEM[addr].i32 = src >= tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  DSOp.DS_MIN_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = src < tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_MAX_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = src >= tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_AND_B32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp & DATA.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_OR_B32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp | DATA.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_XOR_B32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp ^ DATA.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_MSKOR_B32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = ((tmp & ~DATA.b32) | DATA2.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_STORE_B32: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nMEM[addr + OFFSET.u32].b32 = DATA[31 : 0]',
  DSOp.DS_STORE_2ADDR_B32: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nMEM[addr + OFFSET0.u32 * 4U].b32 = DATA[31 : 0];\naddr = CalcDsAddr(vgpr_a.b32, 0x0);\nMEM[addr + OFFSET1.u32 * 4U].b32 = DATA2[31 : 0]',
  DSOp.DS_STORE_2ADDR_STRIDE64_B32: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nMEM[addr + OFFSET0.u32 * 256U].b32 = DATA[31 : 0];\naddr = CalcDsAddr(vgpr_a.b32, 0x0);\nMEM[addr + OFFSET1.u32 * 256U].b32 = DATA2[31 : 0]',
  DSOp.DS_CMPSTORE_B32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b32;\nsrc = DATA.b32;\ncmp = DATA2.b32;\nMEM[addr].b32 = tmp == cmp ? src : tmp;\nRETURN_DATA.b32 = tmp',
  DSOp.DS_MIN_NUM_F32: "tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nif (isNAN(64'F(src.f32)) && isNAN(64'F(tmp.f32))) then\nMEM[ADDR].f32 = 32'F(cvtToQuietNAN(64'F(src.f32)))\nelsif isNAN(64'F(src.f32)) then\nMEM[ADDR].f32 = tmp.f32\nelsif isNAN(64'F(tmp.f32)) then\nMEM[ADDR].f32 = src.f32\nelsif ((src.f32 < tmp.f32) || ((abs(src.f32) == 0.0F) && (abs(tmp.f32) == 0.0F) && sign(src.f32) &&\n!sign(tmp.f32))) then\n// NOTE: -0<+0 is TRUE in this comparison\nMEM[ADDR].f32 = src.f32\nelse\nMEM[ADDR].f32 = tmp.f32\nendif;\nRETURN_DATA.f32 = tmp",
  DSOp.DS_MAX_NUM_F32: "tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nif (isNAN(64'F(src.f32)) && isNAN(64'F(tmp.f32))) then\nMEM[ADDR].f32 = 32'F(cvtToQuietNAN(64'F(src.f32)))\nelsif isNAN(64'F(src.f32)) then\nMEM[ADDR].f32 = tmp.f32\nelsif isNAN(64'F(tmp.f32)) then\nMEM[ADDR].f32 = src.f32\nelsif ((src.f32 > tmp.f32) || ((abs(src.f32) == 0.0F) && (abs(tmp.f32) == 0.0F) && !sign(src.f32) &&\nsign(tmp.f32))) then\n// NOTE: +0>-0 is TRUE in this comparison\nMEM[ADDR].f32 = src.f32\nelse\nMEM[ADDR].f32 = tmp.f32\nendif;\nRETURN_DATA.f32 = tmp",
  DSOp.DS_ADD_F32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].f32;\nMEM[addr].f32 += DATA.f32;\nRETURN_DATA.f32 = tmp',
  DSOp.DS_STORE_B8: 'MEM[ADDR].b8 = DATA[7 : 0]',
  DSOp.DS_STORE_B16: 'MEM[ADDR].b16 = DATA[15 : 0]',
  DSOp.DS_ADD_RTN_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nMEM[addr].u32 += DATA.u32;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_SUB_RTN_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nMEM[addr].u32 -= DATA.u32;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_RSUB_RTN_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nMEM[addr].u32 = DATA.u32 - MEM[addr].u32;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_INC_RTN_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_DEC_RTN_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_MIN_RTN_I32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].i32;\nsrc = DATA.i32;\nMEM[addr].i32 = src < tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  DSOp.DS_MAX_RTN_I32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].i32;\nsrc = DATA.i32;\nMEM[addr].i32 = src >= tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  DSOp.DS_MIN_RTN_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = src < tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_MAX_RTN_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = src >= tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_AND_RTN_B32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp & DATA.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_OR_RTN_B32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp | DATA.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_XOR_RTN_B32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp ^ DATA.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_MSKOR_RTN_B32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = ((tmp & ~DATA.b32) | DATA2.b32);\nRETURN_DATA.b32 = tmp',
  DSOp.DS_STOREXCHG_RTN_B32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = DATA.b32;\nRETURN_DATA.b32 = tmp',
  DSOp.DS_STOREXCHG_2ADDR_RTN_B32: 'addr1 = ADDR_BASE.u32 + OFFSET0.u32 * 4U;\naddr2 = ADDR_BASE.u32 + OFFSET1.u32 * 4U;\ntmp1 = MEM[addr1].b32;\ntmp2 = MEM[addr2].b32;\nMEM[addr1].b32 = DATA.b32;\nMEM[addr2].b32 = DATA2.b32;\n// Note DATA2 can be any other register\nRETURN_DATA[31 : 0] = tmp1;\nRETURN_DATA[63 : 32] = tmp2',
  DSOp.DS_STOREXCHG_2ADDR_STRIDE64_RTN_B32: 'addr1 = ADDR_BASE.u32 + OFFSET0.u32 * 256U;\naddr2 = ADDR_BASE.u32 + OFFSET1.u32 * 256U;\ntmp1 = MEM[addr1].b32;\ntmp2 = MEM[addr2].b32;\nMEM[addr1].b32 = DATA.b32;\nMEM[addr2].b32 = DATA2.b32;\n// Note DATA2 can be any other register\nRETURN_DATA[31 : 0] = tmp1;\nRETURN_DATA[63 : 32] = tmp2',
  DSOp.DS_CMPSTORE_RTN_B32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b32;\nsrc = DATA.b32;\ncmp = DATA2.b32;\nMEM[addr].b32 = tmp == cmp ? src : tmp;\nRETURN_DATA.b32 = tmp',
  DSOp.DS_MIN_NUM_RTN_F32: "tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nif (isNAN(64'F(src.f32)) && isNAN(64'F(tmp.f32))) then\nMEM[ADDR].f32 = 32'F(cvtToQuietNAN(64'F(src.f32)))\nelsif isNAN(64'F(src.f32)) then\nMEM[ADDR].f32 = tmp.f32\nelsif isNAN(64'F(tmp.f32)) then\nMEM[ADDR].f32 = src.f32\nelsif ((src.f32 < tmp.f32) || ((abs(src.f32) == 0.0F) && (abs(tmp.f32) == 0.0F) && sign(src.f32) &&\n!sign(tmp.f32))) then\n// NOTE: -0<+0 is TRUE in this comparison\nMEM[ADDR].f32 = src.f32\nelse\nMEM[ADDR].f32 = tmp.f32\nendif;\nRETURN_DATA.f32 = tmp",
  DSOp.DS_MAX_NUM_RTN_F32: "tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nif (isNAN(64'F(src.f32)) && isNAN(64'F(tmp.f32))) then\nMEM[ADDR].f32 = 32'F(cvtToQuietNAN(64'F(src.f32)))\nelsif isNAN(64'F(src.f32)) then\nMEM[ADDR].f32 = tmp.f32\nelsif isNAN(64'F(tmp.f32)) then\nMEM[ADDR].f32 = src.f32\nelsif ((src.f32 > tmp.f32) || ((abs(src.f32) == 0.0F) && (abs(tmp.f32) == 0.0F) && !sign(src.f32) &&\nsign(tmp.f32))) then\n// NOTE: +0>-0 is TRUE in this comparison\nMEM[ADDR].f32 = src.f32\nelse\nMEM[ADDR].f32 = tmp.f32\nendif;\nRETURN_DATA.f32 = tmp",
  DSOp.DS_SWIZZLE_B32: 'offset = offset1:offset0;\nif (offset >= 0xe000) {\n// FFT decomposition\nmask = offset[4:0];\nfor (i = 0; i < 64; i++) {\nj = reverse_bits(i & 0x1f);\nj = (j >> count_ones(mask));\nj |= (i & mask);\nj |= i & 0x20;\nthread_out[i] = thread_valid[j] ? thread_in[j] : 0;\n}',
  DSOp.DS_LOAD_B32: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nRETURN_DATA[31 : 0] = MEM[addr + OFFSET.u32].b32',
  DSOp.DS_LOAD_2ADDR_B32: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nRETURN_DATA[31 : 0] = MEM[addr + OFFSET0.u32 * 4U].b32;\naddr = CalcDsAddr(vgpr_a.b32, 0x0);\nRETURN_DATA[63 : 32] = MEM[addr + OFFSET1.u32 * 4U].b32',
  DSOp.DS_LOAD_2ADDR_STRIDE64_B32: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nRETURN_DATA[31 : 0] = MEM[addr + OFFSET0.u32 * 256U].b32;\naddr = CalcDsAddr(vgpr_a.b32, 0x0);\nRETURN_DATA[63 : 32] = MEM[addr + OFFSET1.u32 * 256U].b32',
  DSOp.DS_LOAD_I8: "RETURN_DATA.i32 = 32'I(signext(MEM[ADDR].i8))",
  DSOp.DS_LOAD_U8: "RETURN_DATA.u32 = 32'U({ 24'0U, MEM[ADDR].u8 })",
  DSOp.DS_LOAD_I16: "RETURN_DATA.i32 = 32'I(signext(MEM[ADDR].i16))",
  DSOp.DS_LOAD_U16: "RETURN_DATA.u32 = 32'U({ 16'0U, MEM[ADDR].u16 })",
  DSOp.DS_CONSUME: 'addr = offset; // offset by LDS HWBASE\nrtnval =  LDS(addr);\nLDS(addr) = LDS(addr) - countbits(valid mask);\nGPR[VDST] = rtnval; // return to all valid threads',
  DSOp.DS_APPEND: 'addr = offset; // offset by LDS HWBASE\nrtnval =  LDS(addr);\nLDS(addr) = LDS(addr) + countbits(valid mask);\nGPR[VDST] = rtnval; // return to all valid threads',
  DSOp.DS_ADD_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nMEM[addr].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_SUB_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nMEM[addr].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_RSUB_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nMEM[addr].u64 = DATA.u64 - MEM[addr].u64;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_INC_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_DEC_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_MIN_I64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].i64;\nsrc = DATA.i64;\nMEM[addr].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  DSOp.DS_MAX_I64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].i64;\nsrc = DATA.i64;\nMEM[addr].i64 = src >= tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  DSOp.DS_MIN_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_MAX_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = src >= tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_AND_B64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_OR_B64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp | DATA.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_XOR_B64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_MSKOR_B64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = ((tmp & ~DATA.b64) | DATA2.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_STORE_B64: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nMEM[addr + OFFSET.u32].b32 = DATA[31 : 0];\nMEM[addr + OFFSET.u32 + 4U].b32 = DATA[63 : 32]',
  DSOp.DS_STORE_2ADDR_B64: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nMEM[addr + OFFSET0.u32 * 8U].b32 = DATA[31 : 0];\nMEM[addr + OFFSET0.u32 * 8U + 4U].b32 = DATA[63 : 32];\naddr = CalcDsAddr(vgpr_a.b32, 0x0);\nMEM[addr + OFFSET1.u32 * 8U].b32 = DATA2[31 : 0];\nMEM[addr + OFFSET1.u32 * 8U + 4U].b32 = DATA2[63 : 32]',
  DSOp.DS_STORE_2ADDR_STRIDE64_B64: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nMEM[addr + OFFSET0.u32 * 512U].b32 = DATA[31 : 0];\nMEM[addr + OFFSET0.u32 * 512U + 4U].b32 = DATA[63 : 32];\naddr = CalcDsAddr(vgpr_a.b32, 0x0);\nMEM[addr + OFFSET1.u32 * 512U].b32 = DATA2[31 : 0];\nMEM[addr + OFFSET1.u32 * 512U + 4U].b32 = DATA2[63 : 32]',
  DSOp.DS_CMPSTORE_B64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b64;\nsrc = DATA.b64;\ncmp = DATA2.b64;\nMEM[addr].b64 = tmp == cmp ? src : tmp;\nRETURN_DATA.b64 = tmp',
  DSOp.DS_MIN_NUM_F64: 'tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\nif (isNAN(src.f64) && isNAN(tmp.f64)) then\nMEM[ADDR].f64 = cvtToQuietNAN(src.f64)\nelsif isNAN(src.f64) then\nMEM[ADDR].f64 = tmp.f64\nelsif isNAN(tmp.f64) then\nMEM[ADDR].f64 = src.f64\nelsif ((src.f64 < tmp.f64) || ((abs(src.f64) == 0.0) && (abs(tmp.f64) == 0.0) && sign(src.f64) &&\n!sign(tmp.f64))) then\n// NOTE: -0<+0 is TRUE in this comparison\nMEM[ADDR].f64 = src.f64\nelse\nMEM[ADDR].f64 = tmp.f64\nendif;\nRETURN_DATA.f64 = tmp',
  DSOp.DS_MAX_NUM_F64: 'tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\nif (isNAN(src.f64) && isNAN(tmp.f64)) then\nMEM[ADDR].f64 = cvtToQuietNAN(src.f64)\nelsif isNAN(src.f64) then\nMEM[ADDR].f64 = tmp.f64\nelsif isNAN(tmp.f64) then\nMEM[ADDR].f64 = src.f64\nelsif ((src.f64 > tmp.f64) || ((abs(src.f64) == 0.0) && (abs(tmp.f64) == 0.0) && !sign(src.f64) &&\nsign(tmp.f64))) then\n// NOTE: +0>-0 is TRUE in this comparison\nMEM[ADDR].f64 = src.f64\nelse\nMEM[ADDR].f64 = tmp.f64\nendif;\nRETURN_DATA.f64 = tmp',
  DSOp.DS_ADD_RTN_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nMEM[addr].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_SUB_RTN_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nMEM[addr].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_RSUB_RTN_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nMEM[addr].u64 = DATA.u64 - MEM[addr].u64;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_INC_RTN_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_DEC_RTN_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_MIN_RTN_I64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].i64;\nsrc = DATA.i64;\nMEM[addr].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  DSOp.DS_MAX_RTN_I64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].i64;\nsrc = DATA.i64;\nMEM[addr].i64 = src >= tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  DSOp.DS_MIN_RTN_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_MAX_RTN_U64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = src >= tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  DSOp.DS_AND_RTN_B64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_OR_RTN_B64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp | DATA.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_XOR_RTN_B64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_MSKOR_RTN_B64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = ((tmp & ~DATA.b64) | DATA2.b64);\nRETURN_DATA.b64 = tmp',
  DSOp.DS_STOREXCHG_RTN_B64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = DATA.b64;\nRETURN_DATA.b64 = tmp',
  DSOp.DS_STOREXCHG_2ADDR_RTN_B64: 'addr1 = ADDR_BASE.u32 + OFFSET0.u32 * 8U;\naddr2 = ADDR_BASE.u32 + OFFSET1.u32 * 8U;\ntmp1 = MEM[addr1].b64;\ntmp2 = MEM[addr2].b64;\nMEM[addr1].b64 = DATA.b64;\nMEM[addr2].b64 = DATA2.b64;\n// Note DATA2 can be any other register\nRETURN_DATA[63 : 0] = tmp1;\nRETURN_DATA[127 : 64] = tmp2',
  DSOp.DS_STOREXCHG_2ADDR_STRIDE64_RTN_B64: 'addr1 = ADDR_BASE.u32 + OFFSET0.u32 * 512U;\naddr2 = ADDR_BASE.u32 + OFFSET1.u32 * 512U;\ntmp1 = MEM[addr1].b64;\ntmp2 = MEM[addr2].b64;\nMEM[addr1].b64 = DATA.b64;\nMEM[addr2].b64 = DATA2.b64;\n// Note DATA2 can be any other register\nRETURN_DATA[63 : 0] = tmp1;\nRETURN_DATA[127 : 64] = tmp2',
  DSOp.DS_CMPSTORE_RTN_B64: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].b64;\nsrc = DATA.b64;\ncmp = DATA2.b64;\nMEM[addr].b64 = tmp == cmp ? src : tmp;\nRETURN_DATA.b64 = tmp',
  DSOp.DS_MIN_NUM_RTN_F64: 'tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\nif (isNAN(src.f64) && isNAN(tmp.f64)) then\nMEM[ADDR].f64 = cvtToQuietNAN(src.f64)\nelsif isNAN(src.f64) then\nMEM[ADDR].f64 = tmp.f64\nelsif isNAN(tmp.f64) then\nMEM[ADDR].f64 = src.f64\nelsif ((src.f64 < tmp.f64) || ((abs(src.f64) == 0.0) && (abs(tmp.f64) == 0.0) && sign(src.f64) &&\n!sign(tmp.f64))) then\n// NOTE: -0<+0 is TRUE in this comparison\nMEM[ADDR].f64 = src.f64\nelse\nMEM[ADDR].f64 = tmp.f64\nendif;\nRETURN_DATA.f64 = tmp',
  DSOp.DS_MAX_NUM_RTN_F64: 'tmp = MEM[ADDR].f64;\nsrc = DATA.f64;\nif (isNAN(src.f64) && isNAN(tmp.f64)) then\nMEM[ADDR].f64 = cvtToQuietNAN(src.f64)\nelsif isNAN(src.f64) then\nMEM[ADDR].f64 = tmp.f64\nelsif isNAN(tmp.f64) then\nMEM[ADDR].f64 = src.f64\nelsif ((src.f64 > tmp.f64) || ((abs(src.f64) == 0.0) && (abs(tmp.f64) == 0.0) && !sign(src.f64) &&\nsign(tmp.f64))) then\n// NOTE: +0>-0 is TRUE in this comparison\nMEM[ADDR].f64 = src.f64\nelse\nMEM[ADDR].f64 = tmp.f64\nendif;\nRETURN_DATA.f64 = tmp',
  DSOp.DS_LOAD_B64: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nRETURN_DATA[31 : 0] = MEM[addr + OFFSET.u32].b32;\nRETURN_DATA[63 : 32] = MEM[addr + OFFSET.u32 + 4U].b32',
  DSOp.DS_LOAD_2ADDR_B64: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nRETURN_DATA[31 : 0] = MEM[addr + OFFSET0.u32 * 8U].b32;\nRETURN_DATA[63 : 32] = MEM[addr + OFFSET0.u32 * 8U + 4U].b32;\naddr = CalcDsAddr(vgpr_a.b32, 0x0);\nRETURN_DATA[95 : 64] = MEM[addr + OFFSET1.u32 * 8U].b32;\nRETURN_DATA[127 : 96] = MEM[addr + OFFSET1.u32 * 8U + 4U].b32',
  DSOp.DS_LOAD_2ADDR_STRIDE64_B64: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nRETURN_DATA[31 : 0] = MEM[addr + OFFSET0.u32 * 512U].b32;\nRETURN_DATA[63 : 32] = MEM[addr + OFFSET0.u32 * 512U + 4U].b32;\naddr = CalcDsAddr(vgpr_a.b32, 0x0);\nRETURN_DATA[95 : 64] = MEM[addr + OFFSET1.u32 * 512U].b32;\nRETURN_DATA[127 : 96] = MEM[addr + OFFSET1.u32 * 512U + 4U].b32',
  DSOp.DS_ADD_RTN_F32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].f32;\nMEM[addr].f32 += DATA.f32;\nRETURN_DATA.f32 = tmp',
  DSOp.DS_CONDXCHG32_RTN_B64: "declare OFFSET0 : 8'U;\ndeclare OFFSET1 : 8'U;\ndeclare RETURN_DATA : 32'U[2];\nADDR = S0.u32;\nDATA = S1.u64;\noffset = { OFFSET1, OFFSET0 };\nADDR0 = ((ADDR + offset.u32) & 0xfff8U);\nADDR1 = ADDR0 + 4U;\nRETURN_DATA[0] = LDS[ADDR0].u32;\nif DATA[31] then\nLDS[ADDR0] = { 1'0, DATA[30 : 0] }\nendif;\nRETURN_DATA[1] = LDS[ADDR1].u32;\nif DATA[63] then\nLDS[ADDR1] = { 1'0, DATA[62 : 32] }\nendif",
  DSOp.DS_COND_SUB_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = tmp >= src ? tmp - src : tmp;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_SUB_CLAMP_U32: "declare new_value : 32'U;\nold_value = MEM[ADDR].u32;\nif old_value < DATA.u32 then\nnew_value = 0U\nelse\nnew_value = old_value - DATA.u32\nendif;\nMEM[ADDR].u32 = new_value;\nRETURN_DATA.u32 = old_value",
  DSOp.DS_PK_ADD_F16: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ndst[15 : 0].f16 = src[15 : 0].f16 + tmp[15 : 0].f16;\ndst[31 : 16].f16 = src[31 : 16].f16 + tmp[31 : 16].f16;\nMEM[ADDR].b32 = dst.b32;\nRETURN_DATA.b32 = tmp.b32',
  DSOp.DS_PK_ADD_BF16: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ndst[15 : 0].bf16 = src[15 : 0].bf16 + tmp[15 : 0].bf16;\ndst[31 : 16].bf16 = src[31 : 16].bf16 + tmp[31 : 16].bf16;\nMEM[ADDR].b32 = dst.b32;\nRETURN_DATA.b32 = tmp.b32',
  DSOp.DS_STORE_B8_D16_HI: 'MEM[ADDR].b8 = DATA[23 : 16]',
  DSOp.DS_STORE_B16_D16_HI: 'MEM[ADDR].b16 = DATA[31 : 16]',
  DSOp.DS_LOAD_U8_D16: "RETURN_DATA[15 : 0].u16 = 16'U({ 8'0U, MEM[ADDR].u8 });\n// RETURN_DATA[31:16] is preserved.",
  DSOp.DS_LOAD_U8_D16_HI: "RETURN_DATA[31 : 16].u16 = 16'U({ 8'0U, MEM[ADDR].u8 });\n// RETURN_DATA[15:0] is preserved.",
  DSOp.DS_LOAD_I8_D16: "RETURN_DATA[15 : 0].i16 = 16'I(signext(MEM[ADDR].i8));\n// RETURN_DATA[31:16] is preserved.",
  DSOp.DS_LOAD_I8_D16_HI: "RETURN_DATA[31 : 16].i16 = 16'I(signext(MEM[ADDR].i8));\n// RETURN_DATA[15:0] is preserved.",
  DSOp.DS_LOAD_U16_D16: 'RETURN_DATA[15 : 0].u16 = MEM[ADDR].u16;\n// RETURN_DATA[31:16] is preserved.',
  DSOp.DS_LOAD_U16_D16_HI: 'RETURN_DATA[31 : 16].u16 = MEM[ADDR].u16;\n// RETURN_DATA[15:0] is preserved.',
  DSOp.DS_COND_SUB_RTN_U32: 'addr = CalcDsAddr(vgpr_a.b32, offset.b32);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = tmp >= src ? tmp - src : tmp;\nRETURN_DATA.u32 = tmp',
  DSOp.DS_SUB_CLAMP_RTN_U32: "declare new_value : 32'U;\nold_value = MEM[ADDR].u32;\nif old_value < DATA.u32 then\nnew_value = 0U\nelse\nnew_value = old_value - DATA.u32\nendif;\nMEM[ADDR].u32 = new_value;\nRETURN_DATA.u32 = old_value",
  DSOp.DS_PK_ADD_RTN_F16: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ndst[15 : 0].f16 = src[15 : 0].f16 + tmp[15 : 0].f16;\ndst[31 : 16].f16 = src[31 : 16].f16 + tmp[31 : 16].f16;\nMEM[ADDR].b32 = dst.b32;\nRETURN_DATA.b32 = tmp.b32',
  DSOp.DS_PK_ADD_RTN_BF16: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ndst[15 : 0].bf16 = src[15 : 0].bf16 + tmp[15 : 0].bf16;\ndst[31 : 16].bf16 = src[31 : 16].bf16 + tmp[31 : 16].bf16;\nMEM[ADDR].b32 = dst.b32;\nRETURN_DATA.b32 = tmp.b32',
  DSOp.DS_STORE_ADDTID_B32: "declare OFFSET0 : 8'U;\ndeclare OFFSET1 : 8'U;\nMEM[32'I({ OFFSET1, OFFSET0 } + M0[15 : 0]) + laneID.i32 * 4].u32 = DATA0.u32",
  DSOp.DS_LOAD_ADDTID_B32: "declare OFFSET0 : 8'U;\ndeclare OFFSET1 : 8'U;\nRETURN_DATA.u32 = MEM[32'I({ OFFSET1, OFFSET0 } + M0[15 : 0]) + laneID.i32 * 4].u32",
  DSOp.DS_PERMUTE_B32: "// VGPR[laneId][index] is the VGPR RAM\n// VDST, ADDR and DATA0 are from the microcode DS encoding\ndeclare tmp : 32'B[64];\ndeclare OFFSET : 16'U;\ndeclare DATA0 : 32'U;\ndeclare VDST : 32'U;\nnum_lanes = WAVE64 ? 64 : 32;\nfor i in 0 : num_lanes - 1 do\ntmp[i] = 0x0\nendfor;\nfor i in 0 : num_lanes - 1 do\n// If a source thread is disabled, it does not propagate data.\nif EXEC[i].u1 then\n// ADDR needs to be divided by 4.\n// High-order bits are ignored.\ndst_lane = 32'I(VGPR[i][ADDR] + OFFSET.b32) / 4 % num_lanes;\ntmp[dst_lane] = VGPR[i][DATA0]\nendif\nendfor;\n// Copy data into destination VGPRs. If multiple sources\n// select the same destination thread, the highest-numbered\n// source thread wins.\nfor i in 0 : num_lanes - 1 do\nif EXEC[i].u1 then\nVGPR[i][VDST] = tmp[i]\nendif\nendfor",
  DSOp.DS_BPERMUTE_B32: "// VGPR[laneId][index] is the VGPR RAM\n// VDST, ADDR and DATA0 are from the microcode DS encoding\ndeclare tmp : 32'B[64];\ndeclare OFFSET : 16'U;\ndeclare DATA0 : 32'U;\ndeclare VDST : 32'U;\nnum_lanes = WAVE64 ? 64 : 32;\nfor i in 0 : num_lanes - 1 do\ntmp[i] = 0x0\nendfor;\nfor i in 0 : num_lanes - 1 do\n// ADDR needs to be divided by 4.\n// High-order bits are ignored.\nsrc_lane = 32'I(VGPR[i][ADDR] + OFFSET.b32) / 4 % num_lanes;\n// EXEC is applied to the source VGPR reads.\nif EXEC[src_lane].u1 then\ntmp[i] = VGPR[src_lane][DATA0]\nendif\nendfor;\n// Copy data into destination VGPRs. Some source\n// data may be broadcast to multiple lanes.\nfor i in 0 : num_lanes - 1 do\nif EXEC[i].u1 then\nVGPR[i][VDST] = tmp[i]\nendif\nendfor",
  DSOp.DS_BPERMUTE_FI_B32: "// VGPR[laneId][index] is the VGPR RAM\n// VDST, ADDR and DATA0 are from the microcode DS encoding\ndeclare tmp : 32'B[64];\ndeclare OFFSET : 16'U;\ndeclare DATA0 : 32'U;\ndeclare VDST : 32'U;\nnum_lanes = WAVE64 ? 64 : 32;\nfor i in 0 : num_lanes - 1 do\ntmp[i] = 0x0\nendfor;\nfor i in 0 : num_lanes - 1 do\n// ADDR needs to be divided by 4.\n// High-order bits are ignored.\nsrc_lane = 32'I(VGPR[i][ADDR] + OFFSET.b32) / 4 % num_lanes;\n// Source VGPR is read even if src_lane is invalid in EXEC mask.\ntmp[i] = VGPR[src_lane][DATA0]\nendfor;\n// Copy data into destination VGPRs. Some source\n// data may be broadcast to multiple lanes.\nfor i in 0 : num_lanes - 1 do\nif EXEC[i].u1 then\nVGPR[i][VDST] = tmp[i]\nendif\nendfor",
  DSOp.DS_STORE_B96: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nMEM[addr + OFFSET.u32].b32 = DATA[31 : 0];\nMEM[addr + OFFSET.u32 + 4U].b32 = DATA[63 : 32];\nMEM[addr + OFFSET.u32 + 8U].b32 = DATA[95 : 64]',
  DSOp.DS_STORE_B128: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nMEM[addr + OFFSET.u32].b32 = DATA[31 : 0];\nMEM[addr + OFFSET.u32 + 4U].b32 = DATA[63 : 32];\nMEM[addr + OFFSET.u32 + 8U].b32 = DATA[95 : 64];\nMEM[addr + OFFSET.u32 + 12U].b32 = DATA[127 : 96]',
  DSOp.DS_BVH_STACK_PUSH4_POP1_RTN_B32: "declare stack_base : 32'B;\ndeclare stack_index : 32'U;\ndeclare DATA1 : 32'B;\ndeclare last_node_ptr : 32'B;\ndeclare INVALID_NODE : 32'B;\nDATA_VALID = lambda(data) (\nif data == INVALID_NODE then\nreturn 1'0U\nelsif ((last_node_ptr != INVALID_NODE) && (data == last_node_ptr)) then\n// Match last_node_ptr\nreturn 1'0U\nelse\nreturn 1'1U\nendif);\n// main code\n{ stack_base, stack_index } = 64'B(DECODE_ADDR(ADDR, OFFSET0));\nlast_node_ptr = DATA0.b32;\n// First 3 passes: push data onto stack\nfor i in 0 : 2 do\nif DATA_VALID(DATA1[i * 32 + 31 : i * 32]) then\nMEM[stack_base.u32 + stack_index] = DATA1[i * 32 + 31 : i * 32];\nstack_index += 1U\nelsif DATA1[i].b32 == last_node_ptr then\n// Treat all further data as invalid as well.\nbreak\nendif\nendfor;\n// Last pass: return data or pop\nif DATA_VALID(DATA1[127 : 96]) then\nRETURN_DATA[31 : 0] = DATA1[127 : 96]\nelse\nRETURN_DATA[31 : 0] = MEM[stack_base.u32 + stack_index];\nMEM[stack_base.u32 + stack_index] = INVALID_NODE;\nstack_index -= 1U\nendif;\nRETURN_ADDR[31 : 0] = 32'B(ENCODE_ADDR(stack_base, stack_index))",
  DSOp.DS_BVH_STACK_PUSH8_POP1_RTN_B32: "declare stack_base : 32'B;\ndeclare stack_index : 32'U;\ndeclare DATA1 : 32'B;\ndeclare last_node_ptr : 32'B;\ndeclare INVALID_NODE : 32'B;\nDATA_VALID = lambda(data) (\nif data == INVALID_NODE then\nreturn 1'0U\nelsif ((last_node_ptr != INVALID_NODE) && (data == last_node_ptr)) then\n// Match last_node_ptr\nreturn 1'0U\nelse\nreturn 1'1U\nendif);\n// main code\n{ stack_base, stack_index } = 64'B(DECODE_ADDR(ADDR, OFFSET0));\nlast_node_ptr = DATA0.b32;\n// First 7 passes: push data onto stack\nfor i in 0 : 6 do\nif DATA_VALID(DATA1[i * 32 + 31 : i * 32]) then\nMEM[stack_base.u32 + stack_index] = DATA1[i * 32 + 31 : i * 32];\nstack_index += 1U\nelsif DATA1[i].b32 == last_node_ptr then\n// Treat all further data as invalid as well.\nbreak\nendif\nendfor;\n// Last pass: return data or pop\nif DATA_VALID(DATA1[255 : 224]) then\nRETURN_DATA[31 : 0] = DATA1[255 : 224]\nelse\nRETURN_DATA[31 : 0] = MEM[stack_base.u32 + stack_index];\nMEM[stack_base.u32 + stack_index] = INVALID_NODE;\nstack_index -= 1U\nendif;\nRETURN_ADDR[31 : 0] = 32'B(ENCODE_ADDR(stack_base, stack_index))",
  DSOp.DS_BVH_STACK_PUSH8_POP2_RTN_B64: "declare stack_base : 32'B;\ndeclare stack_index : 32'U;\ndeclare DATA1 : 32'B;\ndeclare last_node_ptr : 32'B;\ndeclare INVALID_NODE : 32'B;\nDATA_VALID = lambda(data) (\nif data == INVALID_NODE then\nreturn 1'0U\nelsif ((last_node_ptr != INVALID_NODE) && (data == last_node_ptr)) then\n// Match last_node_ptr\nreturn 1'0U\nelse\nreturn 1'1U\nendif);\n// main code\n{ stack_base, stack_index } = 64'B(DECODE_ADDR(ADDR, OFFSET0));\nlast_node_ptr = DATA0.b32;\n// First 7 passes: push data onto stack\nfor i in 0 : 6 do\nif DATA_VALID(DATA1[i * 32 + 31 : i * 32]) then\nMEM[stack_base.u32 + stack_index] = DATA1[i * 32 + 31 : i * 32];\nstack_index += 1U\nelsif DATA1[i].b32 == last_node_ptr then\n// Treat all further data as invalid as well.\nbreak\nendif\nendfor;\n// Last pass: return data or pop\nif DATA_VALID(DATA1[255 : 224]) then\nRETURN_DATA[31 : 0] = DATA1[255 : 224]\nelse\nRETURN_DATA[31 : 0] = MEM[stack_base.u32 + stack_index];\nMEM[stack_base.u32 + stack_index] = INVALID_NODE;\nstack_index -= 1U\nendif;\n// Attempt a second pop\nif DATA_VALID(MEM[stack_base.u32 + stack_index]) then\nRETURN_DATA[63 : 32] = MEM[stack_base.u32 + stack_index];\nMEM[stack_base.u32 + stack_index] = INVALID_NODE;\nstack_index -= 1U\nendif;\nRETURN_ADDR[31 : 0] = 32'B(ENCODE_ADDR(stack_base, stack_index))",
  DSOp.DS_LOAD_B96: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nRETURN_DATA[31 : 0] = MEM[addr + OFFSET.u32].b32;\nRETURN_DATA[63 : 32] = MEM[addr + OFFSET.u32 + 4U].b32;\nRETURN_DATA[95 : 64] = MEM[addr + OFFSET.u32 + 8U].b32',
  DSOp.DS_LOAD_B128: 'addr = CalcDsAddr(vgpr_a.b32, 0x0);\nRETURN_DATA[31 : 0] = MEM[addr + OFFSET.u32].b32;\nRETURN_DATA[63 : 32] = MEM[addr + OFFSET.u32 + 4U].b32;\nRETURN_DATA[95 : 64] = MEM[addr + OFFSET.u32 + 8U].b32;\nRETURN_DATA[127 : 96] = MEM[addr + OFFSET.u32 + 12U].b32',
  SMEMOp.S_LOAD_B32: 'addr = CalcGlobalAddr(sgpr_base.b64, offset.b64);\nSDATA[31 : 0] = MEM[addr].b32',
  SMEMOp.S_LOAD_B64: 'addr = CalcGlobalAddr(sgpr_base.b64, offset.b64);\nSDATA[31 : 0] = MEM[addr].b32;\nSDATA[63 : 32] = MEM[addr + 4U].b32',
  SMEMOp.S_LOAD_B128: 'addr = CalcGlobalAddr(sgpr_base.b64, offset.b64);\nSDATA[31 : 0] = MEM[addr].b32;\nSDATA[63 : 32] = MEM[addr + 4U].b32;\nSDATA[95 : 64] = MEM[addr + 8U].b32;\nSDATA[127 : 96] = MEM[addr + 12U].b32',
  SMEMOp.S_LOAD_B256: 'addr = CalcGlobalAddr(sgpr_base.b64, offset.b64);\nSDATA[31 : 0] = MEM[addr].b32;\nSDATA[63 : 32] = MEM[addr + 4U].b32;\nSDATA[95 : 64] = MEM[addr + 8U].b32;\nSDATA[127 : 96] = MEM[addr + 12U].b32;\nSDATA[159 : 128] = MEM[addr + 16U].b32;\nSDATA[191 : 160] = MEM[addr + 20U].b32;\nSDATA[223 : 192] = MEM[addr + 24U].b32;\nSDATA[255 : 224] = MEM[addr + 28U].b32',
  SMEMOp.S_LOAD_B512: 'addr = CalcGlobalAddr(sgpr_base.b64, offset.b64);\nSDATA[31 : 0] = MEM[addr].b32;\nSDATA[63 : 32] = MEM[addr + 4U].b32;\nSDATA[95 : 64] = MEM[addr + 8U].b32;\nSDATA[127 : 96] = MEM[addr + 12U].b32;\nSDATA[159 : 128] = MEM[addr + 16U].b32;\nSDATA[191 : 160] = MEM[addr + 20U].b32;\nSDATA[223 : 192] = MEM[addr + 24U].b32;\nSDATA[255 : 224] = MEM[addr + 28U].b32;\nSDATA[287 : 256] = MEM[addr + 32U].b32;\nSDATA[319 : 288] = MEM[addr + 36U].b32;\nSDATA[351 : 320] = MEM[addr + 40U].b32;\nSDATA[383 : 352] = MEM[addr + 44U].b32;\nSDATA[415 : 384] = MEM[addr + 48U].b32;\nSDATA[447 : 416] = MEM[addr + 52U].b32;\nSDATA[479 : 448] = MEM[addr + 56U].b32;\nSDATA[511 : 480] = MEM[addr + 60U].b32',
  SMEMOp.S_LOAD_B96: 'addr = CalcGlobalAddr(sgpr_base.b64, offset.b64);\nSDATA[31 : 0] = MEM[addr].b32;\nSDATA[63 : 32] = MEM[addr + 4U].b32;\nSDATA[95 : 64] = MEM[addr + 8U].b32',
  SMEMOp.S_LOAD_I8: "SDATA.i32 = 32'I(signext(MEM[ADDR].i8))",
  SMEMOp.S_LOAD_U8: "SDATA.u32 = 32'U({ 24'0U, MEM[ADDR].u8 })",
  SMEMOp.S_LOAD_I16: "SDATA.i32 = 32'I(signext(MEM[ADDR].i16))",
  SMEMOp.S_LOAD_U16: "SDATA.u32 = 32'U({ 16'0U, MEM[ADDR].u16 })",
  SMEMOp.S_BUFFER_LOAD_B32: 'addr = CalcBufferAddr(sgpr_base.b64, offset.b64);\nSDATA[31 : 0] = MEM[addr].b32',
  SMEMOp.S_BUFFER_LOAD_B64: 'addr = CalcBufferAddr(sgpr_base.b64, offset.b64);\nSDATA[31 : 0] = MEM[addr].b32;\nSDATA[63 : 32] = MEM[addr + 4U].b32',
  SMEMOp.S_BUFFER_LOAD_B128: 'addr = CalcBufferAddr(sgpr_base.b64, offset.b64);\nSDATA[31 : 0] = MEM[addr].b32;\nSDATA[63 : 32] = MEM[addr + 4U].b32;\nSDATA[95 : 64] = MEM[addr + 8U].b32;\nSDATA[127 : 96] = MEM[addr + 12U].b32',
  SMEMOp.S_BUFFER_LOAD_B256: 'addr = CalcBufferAddr(sgpr_base.b64, offset.b64);\nSDATA[31 : 0] = MEM[addr].b32;\nSDATA[63 : 32] = MEM[addr + 4U].b32;\nSDATA[95 : 64] = MEM[addr + 8U].b32;\nSDATA[127 : 96] = MEM[addr + 12U].b32;\nSDATA[159 : 128] = MEM[addr + 16U].b32;\nSDATA[191 : 160] = MEM[addr + 20U].b32;\nSDATA[223 : 192] = MEM[addr + 24U].b32;\nSDATA[255 : 224] = MEM[addr + 28U].b32',
  SMEMOp.S_BUFFER_LOAD_B512: 'addr = CalcBufferAddr(sgpr_base.b64, offset.b64);\nSDATA[31 : 0] = MEM[addr].b32;\nSDATA[63 : 32] = MEM[addr + 4U].b32;\nSDATA[95 : 64] = MEM[addr + 8U].b32;\nSDATA[127 : 96] = MEM[addr + 12U].b32;\nSDATA[159 : 128] = MEM[addr + 16U].b32;\nSDATA[191 : 160] = MEM[addr + 20U].b32;\nSDATA[223 : 192] = MEM[addr + 24U].b32;\nSDATA[255 : 224] = MEM[addr + 28U].b32;\nSDATA[287 : 256] = MEM[addr + 32U].b32;\nSDATA[319 : 288] = MEM[addr + 36U].b32;\nSDATA[351 : 320] = MEM[addr + 40U].b32;\nSDATA[383 : 352] = MEM[addr + 44U].b32;\nSDATA[415 : 384] = MEM[addr + 48U].b32;\nSDATA[447 : 416] = MEM[addr + 52U].b32;\nSDATA[479 : 448] = MEM[addr + 56U].b32;\nSDATA[511 : 480] = MEM[addr + 60U].b32',
  SMEMOp.S_BUFFER_LOAD_B96: 'addr = CalcBufferAddr(sgpr_base.b64, offset.b64);\nSDATA[31 : 0] = MEM[addr].b32;\nSDATA[63 : 32] = MEM[addr + 4U].b32;\nSDATA[95 : 64] = MEM[addr + 8U].b32',
  SMEMOp.S_BUFFER_LOAD_I8: "SDATA.i32 = 32'I(signext(MEM[ADDR].i8))",
  SMEMOp.S_BUFFER_LOAD_U8: "SDATA.u32 = 32'U({ 24'0U, MEM[ADDR].u8 })",
  SMEMOp.S_BUFFER_LOAD_I16: "SDATA.i32 = 32'I(signext(MEM[ADDR].i16))",
  SMEMOp.S_BUFFER_LOAD_U16: "SDATA.u32 = 32'U({ 16'0U, MEM[ADDR].u16 })",
  SMEMOp.S_PREFETCH_INST: "if MODE.SCALAR_PREFETCH_EN.u1 then\nmem_addr = (64'U(S0[63 : 0].i64 + 64'I(IOFFSET.i24)) & 0xffffffffffffff80ULL);\n// Force 128B alignment\nlength = S2.u32;\n// SGPR or M0\nlength += SDATA.u32;\n// SDATA is an immediate\nlength = (length & 31U);\n// Length restricted to 0..31\nlength = (length + 1U) * 128U;\n// Prefetch 1-32 cachelines, units of 128B\nPrefetchScalarInst(mem_addr, length)\nendif",
  SMEMOp.S_PREFETCH_INST_PC_REL: "if MODE.SCALAR_PREFETCH_EN.u1 then\nmem_addr = (64'U(PC[63 : 0].i64 + 8LL + 64'I(IOFFSET.i24)) & 0xffffffffffffff80ULL);\n// Force 128B alignment\nlength = S1.u32;\n// SGPR or M0\nlength += SDATA.u32;\n// SDATA is an immediate\nlength = (length & 31U);\n// Length restricted to 0..31\nlength = (length + 1U) * 128U;\n// Prefetch 1-32 cachelines, units of 128B\nPrefetchScalarInst(mem_addr, length)\nendif",
  SMEMOp.S_PREFETCH_DATA: "if MODE.SCALAR_PREFETCH_EN.u1 then\nmem_addr = (64'U(S0[63 : 0].i64 + 64'I(IOFFSET.i24)) & 0xffffffffffffff80ULL);\n// Force 128B alignment\nlength = S2.u32;\n// SGPR or M0\nlength += SDATA.u32;\n// SDATA is an immediate\nlength = (length & 31U);\n// Length restricted to 0..31\nlength = (length + 1U) * 128U;\n// Prefetch 1-32 cachelines, units of 128B\nPrefetchScalarData(mem_addr, length)\nendif",
  SMEMOp.S_BUFFER_PREFETCH_DATA: "if MODE.SCALAR_PREFETCH_EN.u1 then\nmem_addr = (64'U(S0[47 : 0].i64 + 64'I(IOFFSET.i24)) & 0xffffffffffffff80ULL);\n// Force 128B alignment\nlength = S2.u32;\n// SGPR or M0\nlength += SDATA.u32;\n// SDATA is an immediate\nlength = (length & 31U);\n// Length restricted to 0..31\nlength = (length + 1U) * 128U;\n// Prefetch 1-32 cachelines, units of 128B\nPrefetchScalarData(mem_addr, length)\nendif",
  SMEMOp.S_PREFETCH_DATA_PC_REL: "if MODE.SCALAR_PREFETCH_EN.u1 then\nmem_addr = (64'U(PC[63 : 0].i64 + 8LL + 64'I(IOFFSET.i24)) & 0xffffffffffffff80ULL);\n// Force 128B alignment\nlength = S1.u32;\n// SGPR or M0\nlength += SDATA.u32;\n// SDATA is an immediate\nlength = (length & 31U);\n// Length restricted to 0..31\nlength = (length + 1U) * 128U;\n// Prefetch 1-32 cachelines, units of 128B\nPrefetchScalarData(mem_addr, length)\nendif",
  SOP1Op.S_MOV_B32: 'D0.b32 = S0.b32',
  SOP1Op.S_MOV_B64: 'D0.b64 = S0.b64',
  SOP1Op.S_CMOV_B32: 'if SCC then\nD0.b32 = S0.b32\nendif',
  SOP1Op.S_CMOV_B64: 'if SCC then\nD0.b64 = S0.b64\nendif',
  SOP1Op.S_BREV_B32: 'D0.u32[31 : 0] = S0.u32[0 : 31]',
  SOP1Op.S_BREV_B64: 'D0.u64[63 : 0] = S0.u64[0 : 63]',
  SOP1Op.S_CTZ_I32_B32: "tmp = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\n// Search from LSB\nif S0.u32[i] == 1'1U then\ntmp = i;\nbreak\nendif\nendfor;\nD0.i32 = tmp",
  SOP1Op.S_CTZ_I32_B64: "tmp = -1;\n// Set if no ones are found\nfor i in 0 : 63 do\n// Search from LSB\nif S0.u64[i] == 1'1U then\ntmp = i;\nbreak\nendif\nendfor;\nD0.i32 = tmp",
  SOP1Op.S_CLZ_I32_U32: "tmp = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\n// Search from MSB\nif S0.u32[31 - i] == 1'1U then\ntmp = i;\nbreak\nendif\nendfor;\nD0.i32 = tmp",
  SOP1Op.S_CLZ_I32_U64: "tmp = -1;\n// Set if no ones are found\nfor i in 0 : 63 do\n// Search from MSB\nif S0.u64[63 - i] == 1'1U then\ntmp = i;\nbreak\nendif\nendfor;\nD0.i32 = tmp",
  SOP1Op.S_CLS_I32: 'tmp = -1;\n// Set if all bits are the same\nfor i in 1 : 31 do\n// Search from MSB\nif S0.u32[31 - i] != S0.u32[31] then\ntmp = i;\nbreak\nendif\nendfor;\nD0.i32 = tmp',
  SOP1Op.S_CLS_I32_I64: 'tmp = -1;\n// Set if all bits are the same\nfor i in 1 : 63 do\n// Search from MSB\nif S0.u64[63 - i] != S0.u64[63] then\ntmp = i;\nbreak\nendif\nendfor;\nD0.i32 = tmp',
  SOP1Op.S_SEXT_I32_I8: "D0.i32 = 32'I(signext(S0.i8))",
  SOP1Op.S_SEXT_I32_I16: "D0.i32 = 32'I(signext(S0.i16))",
  SOP1Op.S_BITSET0_B32: "D0.u32[S0.u32[4 : 0]] = 1'0U",
  SOP1Op.S_BITSET0_B64: "D0.u64[S0.u32[5 : 0]] = 1'0U",
  SOP1Op.S_BITSET1_B32: "D0.u32[S0.u32[4 : 0]] = 1'1U",
  SOP1Op.S_BITSET1_B64: "D0.u64[S0.u32[5 : 0]] = 1'1U",
  SOP1Op.S_BITREPLICATE_B64_B32: 'tmp = S0.u32;\nfor i in 0 : 31 do\nD0.u64[i * 2] = tmp[i];\nD0.u64[i * 2 + 1] = tmp[i]\nendfor',
  SOP1Op.S_ABS_I32: 'D0.i32 = S0.i32 < 0 ? -S0.i32 : S0.i32;\nSCC = D0.i32 != 0',
  SOP1Op.S_BCNT0_I32_B32: "tmp = 0;\nfor i in 0 : 31 do\ntmp += S0.u32[i] == 1'0U ? 1 : 0\nendfor;\nD0.i32 = tmp;\nSCC = D0.u32 != 0U",
  SOP1Op.S_BCNT0_I32_B64: "tmp = 0;\nfor i in 0 : 63 do\ntmp += S0.u64[i] == 1'0U ? 1 : 0\nendfor;\nD0.i32 = tmp;\nSCC = D0.u64 != 0ULL",
  SOP1Op.S_BCNT1_I32_B32: "tmp = 0;\nfor i in 0 : 31 do\ntmp += S0.u32[i] == 1'1U ? 1 : 0\nendfor;\nD0.i32 = tmp;\nSCC = D0.u32 != 0U",
  SOP1Op.S_BCNT1_I32_B64: "tmp = 0;\nfor i in 0 : 63 do\ntmp += S0.u64[i] == 1'1U ? 1 : 0\nendfor;\nD0.i32 = tmp;\nSCC = D0.u64 != 0ULL",
  SOP1Op.S_QUADMASK_B32: 'tmp = 0U;\nfor i in 0 : 7 do\ntmp[i] = S0.u32[i * 4 +: 4] != 0U\nendfor;\nD0.u32 = tmp;\nSCC = D0.u32 != 0U',
  SOP1Op.S_QUADMASK_B64: 'tmp = 0ULL;\nfor i in 0 : 15 do\ntmp[i] = S0.u64[i * 4 +: 4] != 0ULL\nendfor;\nD0.u64 = tmp;\nSCC = D0.u64 != 0ULL',
  SOP1Op.S_WQM_B32: "tmp = 0U;\ndeclare i : 6'U;\nfor i in 6'0U : 6'31U do\ntmp[i] = S0.u32[i & 6'60U +: 6'4U] != 0U\nendfor;\nD0.u32 = tmp;\nSCC = D0.u32 != 0U",
  SOP1Op.S_WQM_B64: "tmp = 0ULL;\ndeclare i : 6'U;\nfor i in 6'0U : 6'63U do\ntmp[i] = S0.u64[i & 6'60U +: 6'4U] != 0ULL\nendfor;\nD0.u64 = tmp;\nSCC = D0.u64 != 0ULL",
  SOP1Op.S_NOT_B32: 'D0.u32 = ~S0.u32;\nSCC = D0.u32 != 0U',
  SOP1Op.S_NOT_B64: 'D0.u64 = ~S0.u64;\nSCC = D0.u64 != 0ULL',
  SOP1Op.S_AND_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = (S0.u32 & EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_AND_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 & EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_OR_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = (S0.u32 | EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_OR_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 | EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_XOR_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = (S0.u32 ^ EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_XOR_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 ^ EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_NAND_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = ~(S0.u32 & EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_NAND_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = ~(S0.u64 & EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_NOR_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = ~(S0.u32 | EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_NOR_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = ~(S0.u64 | EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_XNOR_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = ~(S0.u32 ^ EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_XNOR_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = ~(S0.u64 ^ EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_AND_NOT0_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = (~S0.u32 & EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_AND_NOT0_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (~S0.u64 & EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_OR_NOT0_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = (~S0.u32 | EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_OR_NOT0_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (~S0.u64 | EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_AND_NOT1_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = (S0.u32 & ~EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_AND_NOT1_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 & ~EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_OR_NOT1_SAVEEXEC_B32: 'saveexec = EXEC.u32;\nEXEC.u32 = (S0.u32 | ~EXEC.u32);\nD0.u32 = saveexec.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_OR_NOT1_SAVEEXEC_B64: 'saveexec = EXEC.u64;\nEXEC.u64 = (S0.u64 | ~EXEC.u64);\nD0.u64 = saveexec.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_AND_NOT0_WREXEC_B32: 'EXEC.u32 = (~S0.u32 & EXEC.u32);\nD0.u32 = EXEC.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_AND_NOT0_WREXEC_B64: 'EXEC.u64 = (~S0.u64 & EXEC.u64);\nD0.u64 = EXEC.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_AND_NOT1_WREXEC_B32: 'EXEC.u32 = (S0.u32 & ~EXEC.u32);\nD0.u32 = EXEC.u32;\nSCC = EXEC.u32 != 0U',
  SOP1Op.S_AND_NOT1_WREXEC_B64: 'EXEC.u64 = (S0.u64 & ~EXEC.u64);\nD0.u64 = EXEC.u64;\nSCC = EXEC.u64 != 0ULL',
  SOP1Op.S_MOVRELS_B32: 'addr = SRC0.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nD0.b32 = SGPR[addr].b32',
  SOP1Op.S_MOVRELS_B64: 'addr = SRC0.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nD0.b64 = SGPR[addr].b64',
  SOP1Op.S_MOVRELD_B32: 'addr = DST.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nSGPR[addr].b32 = S0.b32',
  SOP1Op.S_MOVRELD_B64: 'addr = DST.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nSGPR[addr].b64 = S0.b64',
  SOP1Op.S_MOVRELSD_2_B32: 'addrs = SRC0.u32;\n// Raw value from instruction\naddrd = DST.u32;\n// Raw value from instruction\naddrs += M0.u32[9 : 0].u32;\naddrd += M0.u32[25 : 16].u32;\nSGPR[addrd].b32 = SGPR[addrs].b32',
  SOP1Op.S_GETPC_B64: 'D0.i64 = PC + 4LL',
  SOP1Op.S_SETPC_B64: 'PC = S0.i64',
  SOP1Op.S_SWAPPC_B64: 'jump_addr = S0.i64;\nD0.i64 = PC + 4LL;\nPC = jump_addr.i64',
  SOP1Op.S_RFE_B64: "WAVE_STATUS.PRIV = 1'0U;\nPC = S0.i64",
  SOP1Op.S_BARRIER_SIGNAL: ";\n// M0 cannot reference the negative barrier numbers.\nbarrierNumber = IsM0(SRC0.u32) ? 32'I(M0[4 : 0].u32) : SRC0.i32;\nif !InWorkgroup() then\n// Must be in a workgroup to signal a barrier.\ns_nop(16'0U)\nelsif ((barrierNumber == -2) && !WAVE_STATUS.PRIV) then\n// Barrier #-2 is privileged (for traps only).\ns_nop(16'0U)\nelsif barrierNumber == 0 then\n// Barrier #0 is a NOP.\ns_nop(16'0U)\nelse\nBARRIER_STATE[barrierNumber & 63].signalCnt += 7'1U\nendif;\n// Check for barrier completion.\nCheckBarrierComplete(barrierNumber)",
  SOP1Op.S_BARRIER_SIGNAL_ISFIRST: ";\n// M0 cannot reference the negative barrier numbers.\nbarrierNumber = IsM0(SRC0.u32) ? 32'I(M0[4 : 0].u32) : SRC0.i32;\nif !InWorkgroup() then\n// Must be in a workgroup to signal a barrier.\nSCC = 1'0U\nelsif ((barrierNumber == -2) && !WAVE_STATUS.PRIV) then\n// Barrier #-2 is privileged (for traps only).\nSCC = 1'0U\nelsif barrierNumber == 0 then\n// Barrier #0 is a NOP.\nSCC = 1'0U\nelse\n// Set SCC if this is the first signaling event for this barrier.\nSCC = BARRIER_STATE[barrierNumber & 63].signalCnt.u32 == 0U;\nBARRIER_STATE[barrierNumber & 63].signalCnt += 7'1U\nendif;\nCheckBarrierComplete(barrierNumber)",
  SOP1Op.S_GET_BARRIER_STATE: "barrierNumber = IsM0(SRC0.u32) ? 32'I(M0[4 : 0].u32) : SRC0.i32;\nD0.u32 = 32'U({ 9'0, BARRIER_STATE[barrierNumber & 63].signalCnt.u7, 5'0, BARRIER_STATE[barrierNumber &\n63].memberCnt.u7, 3'0, BARRIER_STATE[barrierNumber & 63].valid.u1 })",
  SOP1Op.S_ALLOC_VGPR: "WaitIdleExceptStoreCnt();\nn = ReallocVgprs(32'I(S0[8 : 0].u32));\n// ReallocVgprs returns the actual number of VGPRs allocated rounded to segment size.\n// ReallocVgprs returns a negative value if reallocation fails.\nif n < 0 then\nSCC = 1'0U\nelse\nNUM_VGPRS = n;\nSCC = 1'1U\nendif",
  SOP1Op.S_CEIL_F32: 'D0.f32 = trunc(S0.f32);\nif ((S0.f32 > 0.0F) && (S0.f32 != D0.f32)) then\nD0.f32 += 1.0F\nendif',
  SOP1Op.S_FLOOR_F32: 'D0.f32 = trunc(S0.f32);\nif ((S0.f32 < 0.0F) && (S0.f32 != D0.f32)) then\nD0.f32 += -1.0F\nendif',
  SOP1Op.S_TRUNC_F32: 'D0.f32 = trunc(S0.f32)',
  SOP1Op.S_RNDNE_F32: "D0.f32 = floor(S0.f32 + 0.5F);\nif (isEven(64'F(floor(S0.f32))) && (fract(S0.f32) == 0.5F)) then\nD0.f32 -= 1.0F\nendif",
  SOP1Op.S_CVT_F32_I32: 'D0.f32 = i32_to_f32(S0.i32)',
  SOP1Op.S_CVT_F32_U32: 'D0.f32 = u32_to_f32(S0.u32)',
  SOP1Op.S_CVT_I32_F32: 'D0.i32 = f32_to_i32(S0.f32)',
  SOP1Op.S_CVT_U32_F32: 'D0.u32 = f32_to_u32(S0.f32)',
  SOP1Op.S_CVT_F16_F32: 'D0.f16 = f32_to_f16(S0.f32)',
  SOP1Op.S_CVT_F32_F16: 'D0.f32 = f16_to_f32(S0.f16)',
  SOP1Op.S_CVT_HI_F32_F16: 'D0.f32 = f16_to_f32(S0[31 : 16].f16)',
  SOP1Op.S_CEIL_F16: "D0.f16 = trunc(S0.f16);\nif ((S0.f16 > 16'0.0) && (S0.f16 != D0.f16)) then\nD0.f16 += 16'1.0\nendif",
  SOP1Op.S_FLOOR_F16: "D0.f16 = trunc(S0.f16);\nif ((S0.f16 < 16'0.0) && (S0.f16 != D0.f16)) then\nD0.f16 += -16'1.0\nendif",
  SOP1Op.S_TRUNC_F16: 'D0.f16 = trunc(S0.f16)',
  SOP1Op.S_RNDNE_F16: "D0.f16 = floor(S0.f16 + 16'0.5);\nif (isEven(64'F(floor(S0.f16))) && (fract(S0.f16) == 16'0.5)) then\nD0.f16 -= 16'1.0\nendif",
  SOP2Op.S_ADD_CO_U32: "tmp = 64'U(S0.u32) + 64'U(S1.u32);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow or carry-out for S_ADD_CO_CI_U32.\nD0.u32 = tmp.u32",
  SOP2Op.S_SUB_CO_U32: "tmp = S0.u32 - S1.u32;\nSCC = S1.u32 > S0.u32 ? 1'1U : 1'0U;\n// unsigned overflow or carry-out for S_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
  SOP2Op.S_ADD_CO_I32: 'tmp = S0.i32 + S1.i32;\nSCC = ((S0.u32[31] == S1.u32[31]) && (S0.u32[31] != tmp.u32[31]));\n// signed overflow.\nD0.i32 = tmp.i32',
  SOP2Op.S_SUB_CO_I32: 'tmp = S0.i32 - S1.i32;\nSCC = ((S0.u32[31] != S1.u32[31]) && (S0.u32[31] != tmp.u32[31]));\n// signed overflow.\nD0.i32 = tmp.i32',
  SOP2Op.S_ADD_CO_CI_U32: "tmp = 64'U(S0.u32) + 64'U(S1.u32) + SCC.u64;\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow or carry-out for S_ADD_CO_CI_U32.\nD0.u32 = tmp.u32",
  SOP2Op.S_SUB_CO_CI_U32: "tmp = S0.u32 - S1.u32 - SCC.u32;\nSCC = 64'U(S1.u32) + SCC.u64 > 64'U(S0.u32) ? 1'1U : 1'0U;\n// unsigned overflow or carry-out for S_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
  SOP2Op.S_ABSDIFF_I32: 'D0.i32 = S0.i32 - S1.i32;\nif D0.i32 < 0 then\nD0.i32 = -D0.i32\nendif;\nSCC = D0.i32 != 0',
  SOP2Op.S_LSHL_B32: 'D0.u32 = (S0.u32 << S1[4 : 0].u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_LSHL_B64: 'D0.u64 = (S0.u64 << S1[5 : 0].u32);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_LSHR_B32: 'D0.u32 = (S0.u32 >> S1[4 : 0].u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_LSHR_B64: 'D0.u64 = (S0.u64 >> S1[5 : 0].u32);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_ASHR_I32: "D0.i32 = 32'I(signext(S0.i32) >> S1[4 : 0].u32);\nSCC = D0.i32 != 0",
  SOP2Op.S_ASHR_I64: 'D0.i64 = (signext(S0.i64) >> S1[5 : 0].u32);\nSCC = D0.i64 != 0LL',
  SOP2Op.S_LSHL1_ADD_U32: "tmp = (64'U(S0.u32) << 1U) + 64'U(S1.u32);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u32 = tmp.u32",
  SOP2Op.S_LSHL2_ADD_U32: "tmp = (64'U(S0.u32) << 2U) + 64'U(S1.u32);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u32 = tmp.u32",
  SOP2Op.S_LSHL3_ADD_U32: "tmp = (64'U(S0.u32) << 3U) + 64'U(S1.u32);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u32 = tmp.u32",
  SOP2Op.S_LSHL4_ADD_U32: "tmp = (64'U(S0.u32) << 4U) + 64'U(S1.u32);\nSCC = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// unsigned overflow.\nD0.u32 = tmp.u32",
  SOP2Op.S_MIN_I32: 'SCC = S0.i32 < S1.i32;\nD0.i32 = SCC ? S0.i32 : S1.i32',
  SOP2Op.S_MIN_U32: 'SCC = S0.u32 < S1.u32;\nD0.u32 = SCC ? S0.u32 : S1.u32',
  SOP2Op.S_MAX_I32: 'SCC = S0.i32 >= S1.i32;\nD0.i32 = SCC ? S0.i32 : S1.i32',
  SOP2Op.S_MAX_U32: 'SCC = S0.u32 >= S1.u32;\nD0.u32 = SCC ? S0.u32 : S1.u32',
  SOP2Op.S_AND_B32: 'D0.u32 = (S0.u32 & S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_AND_B64: 'D0.u64 = (S0.u64 & S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_OR_B32: 'D0.u32 = (S0.u32 | S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_OR_B64: 'D0.u64 = (S0.u64 | S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_XOR_B32: 'D0.u32 = (S0.u32 ^ S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_XOR_B64: 'D0.u64 = (S0.u64 ^ S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_NAND_B32: 'D0.u32 = ~(S0.u32 & S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_NAND_B64: 'D0.u64 = ~(S0.u64 & S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_NOR_B32: 'D0.u32 = ~(S0.u32 | S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_NOR_B64: 'D0.u64 = ~(S0.u64 | S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_XNOR_B32: 'D0.u32 = ~(S0.u32 ^ S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_XNOR_B64: 'D0.u64 = ~(S0.u64 ^ S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_AND_NOT1_B32: 'D0.u32 = (S0.u32 & ~S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_AND_NOT1_B64: 'D0.u64 = (S0.u64 & ~S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_OR_NOT1_B32: 'D0.u32 = (S0.u32 | ~S1.u32);\nSCC = D0.u32 != 0U',
  SOP2Op.S_OR_NOT1_B64: 'D0.u64 = (S0.u64 | ~S1.u64);\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_BFE_U32: 'D0.u32 = ((S0.u32 >> S1[4 : 0].u32) & ((1U << S1[22 : 16].u32) - 1U));\nSCC = D0.u32 != 0U',
  SOP2Op.S_BFE_I32: 'tmp.i32 = ((S0.i32 >> S1[4 : 0].u32) & ((1 << S1[22 : 16].u32) - 1));\nD0.i32 = signext_from_bit(tmp.i32, S1[22 : 16].u32);\nSCC = D0.i32 != 0',
  SOP2Op.S_BFE_U64: 'D0.u64 = ((S0.u64 >> S1[5 : 0].u32) & ((1ULL << S1[22 : 16].u32) - 1ULL));\nSCC = D0.u64 != 0ULL',
  SOP2Op.S_BFE_I64: 'tmp.i64 = ((S0.i64 >> S1[5 : 0].u32) & ((1LL << S1[22 : 16].u32) - 1LL));\nD0.i64 = signext_from_bit(tmp.i64, S1[22 : 16].u32);\nSCC = D0.i64 != 0LL',
  SOP2Op.S_BFM_B32: 'D0.u32 = (((1U << S0[4 : 0].u32) - 1U) << S1[4 : 0].u32)',
  SOP2Op.S_BFM_B64: 'D0.u64 = (((1ULL << S0[5 : 0].u32) - 1ULL) << S1[5 : 0].u32)',
  SOP2Op.S_MUL_I32: 'D0.i32 = S0.i32 * S1.i32',
  SOP2Op.S_MUL_HI_U32: "D0.u32 = 32'U((64'U(S0.u32) * 64'U(S1.u32)) >> 32U)",
  SOP2Op.S_MUL_HI_I32: "D0.i32 = 32'I((64'I(S0.i32) * 64'I(S1.i32)) >> 32U)",
  SOP2Op.S_CSELECT_B32: 'D0.u32 = SCC ? S0.u32 : S1.u32',
  SOP2Op.S_CSELECT_B64: 'D0.u64 = SCC ? S0.u64 : S1.u64',
  SOP2Op.S_PACK_LL_B32_B16: 'D0 = { S1[15 : 0].u16, S0[15 : 0].u16 }',
  SOP2Op.S_PACK_LH_B32_B16: 'D0 = { S1[31 : 16].u16, S0[15 : 0].u16 }',
  SOP2Op.S_PACK_HH_B32_B16: 'D0 = { S1[31 : 16].u16, S0[31 : 16].u16 }',
  SOP2Op.S_PACK_HL_B32_B16: 'D0 = { S1[15 : 0].u16, S0[31 : 16].u16 }',
  SOP2Op.S_ADD_F32: 'D0.f32 = S0.f32 + S1.f32',
  SOP2Op.S_SUB_F32: 'D0.f32 = S0.f32 - S1.f32',
  SOP2Op.S_MIN_NUM_F32: "if (isSignalNAN(64'F(S0.f32)) || isSignalNAN(64'F(S1.f32))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f32)) && isNAN(64'F(S1.f32))) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nelsif isNAN(64'F(S0.f32)) then\nD0.f32 = S1.f32\nelsif isNAN(64'F(S1.f32)) then\nD0.f32 = S0.f32\nelsif ((S0.f32 < S1.f32) || ((abs(S0.f32) == 0.0F) && (abs(S1.f32) == 0.0F) && sign(S0.f32) &&\n!sign(S1.f32))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f32 = S0.f32\nelse\nD0.f32 = S1.f32\nendif",
  SOP2Op.S_MAX_NUM_F32: "if (isSignalNAN(64'F(S0.f32)) || isSignalNAN(64'F(S1.f32))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f32)) && isNAN(64'F(S1.f32))) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nelsif isNAN(64'F(S0.f32)) then\nD0.f32 = S1.f32\nelsif isNAN(64'F(S1.f32)) then\nD0.f32 = S0.f32\nelsif ((S0.f32 > S1.f32) || ((abs(S0.f32) == 0.0F) && (abs(S1.f32) == 0.0F) && !sign(S0.f32) &&\nsign(S1.f32))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f32 = S0.f32\nelse\nD0.f32 = S1.f32\nendif",
  SOP2Op.S_MUL_F32: 'D0.f32 = S0.f32 * S1.f32',
  SOP2Op.S_FMAAK_F32: 'D0.f32 = fma(S0.f32, S1.f32, SIMM32.f32)',
  SOP2Op.S_FMAMK_F32: 'D0.f32 = fma(S0.f32, SIMM32.f32, S1.f32)',
  SOP2Op.S_FMAC_F32: 'D0.f32 = fma(S0.f32, S1.f32, D0.f32)',
  SOP2Op.S_CVT_PK_RTZ_F16_F32: 'prev_mode = ROUND_MODE;\nROUND_MODE = ROUND_TOWARD_ZERO;\ntmp[15 : 0].f16 = f32_to_f16(S0.f32);\ntmp[31 : 16].f16 = f32_to_f16(S1.f32);\nD0 = tmp.b32;\nROUND_MODE = prev_mode;\n// Round-toward-zero regardless of current round mode setting in hardware.',
  SOP2Op.S_ADD_F16: 'D0.f16 = S0.f16 + S1.f16',
  SOP2Op.S_SUB_F16: 'D0.f16 = S0.f16 - S1.f16',
  SOP2Op.S_MIN_NUM_F16: "if (isSignalNAN(64'F(S0.f16)) || isSignalNAN(64'F(S1.f16))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f16)) && isNAN(64'F(S1.f16))) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nelsif isNAN(64'F(S0.f16)) then\nD0.f16 = S1.f16\nelsif isNAN(64'F(S1.f16)) then\nD0.f16 = S0.f16\nelsif ((S0.f16 < S1.f16) || ((abs(S0.f16) == 16'0.0) && (abs(S1.f16) == 16'0.0) && sign(S0.f16) &&\n!sign(S1.f16))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif",
  SOP2Op.S_MAX_NUM_F16: "if (isSignalNAN(64'F(S0.f16)) || isSignalNAN(64'F(S1.f16))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f16)) && isNAN(64'F(S1.f16))) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nelsif isNAN(64'F(S0.f16)) then\nD0.f16 = S1.f16\nelsif isNAN(64'F(S1.f16)) then\nD0.f16 = S0.f16\nelsif ((S0.f16 > S1.f16) || ((abs(S0.f16) == 16'0.0) && (abs(S1.f16) == 16'0.0) && !sign(S0.f16) &&\nsign(S1.f16))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif",
  SOP2Op.S_MUL_F16: 'D0.f16 = S0.f16 * S1.f16',
  SOP2Op.S_FMAC_F16: 'D0.f16 = fma(S0.f16, S1.f16, D0.f16)',
  SOP2Op.S_MINIMUM_F32: "if (isSignalNAN(64'F(S0.f32)) || isSignalNAN(64'F(S1.f32))) then\nTRAPSTS.INVALID = 1\nendif;\nif isSignalNAN(64'F(S0.f32)) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nelsif isSignalNAN(64'F(S1.f32)) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))\nelsif isQuietNAN(64'F(S0.f32)) then\nD0.f32 = S0.f32\nelsif isQuietNAN(64'F(S1.f32)) then\nD0.f32 = S1.f32\nelsif ((S0.f32 < S1.f32) || ((abs(S0.f32) == 0.0F) && (abs(S1.f32) == 0.0F) && sign(S0.f32) &&\n!sign(S1.f32))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f32 = S0.f32\nelse\nD0.f32 = S1.f32\nendif",
  SOP2Op.S_MAXIMUM_F32: "if (isSignalNAN(64'F(S0.f32)) || isSignalNAN(64'F(S1.f32))) then\nTRAPSTS.INVALID = 1\nendif;\nif isSignalNAN(64'F(S0.f32)) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nelsif isSignalNAN(64'F(S1.f32)) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))\nelsif isQuietNAN(64'F(S0.f32)) then\nD0.f32 = S0.f32\nelsif isQuietNAN(64'F(S1.f32)) then\nD0.f32 = S1.f32\nelsif ((S0.f32 > S1.f32) || ((abs(S0.f32) == 0.0F) && (abs(S1.f32) == 0.0F) && !sign(S0.f32) &&\nsign(S1.f32))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f32 = S0.f32\nelse\nD0.f32 = S1.f32\nendif",
  SOP2Op.S_MINIMUM_F16: "if (isSignalNAN(64'F(S0.f16)) || isSignalNAN(64'F(S1.f16))) then\nTRAPSTS.INVALID = 1\nendif;\nif isSignalNAN(64'F(S0.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nelsif isSignalNAN(64'F(S1.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nelsif isQuietNAN(64'F(S0.f16)) then\nD0.f16 = S0.f16\nelsif isQuietNAN(64'F(S1.f16)) then\nD0.f16 = S1.f16\nelsif ((S0.f16 < S1.f16) || ((abs(S0.f16) == 16'0.0) && (abs(S1.f16) == 16'0.0) && sign(S0.f16) &&\n!sign(S1.f16))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif",
  SOP2Op.S_MAXIMUM_F16: "if (isSignalNAN(64'F(S0.f16)) || isSignalNAN(64'F(S1.f16))) then\nTRAPSTS.INVALID = 1\nendif;\nif isSignalNAN(64'F(S0.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nelsif isSignalNAN(64'F(S1.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nelsif isQuietNAN(64'F(S0.f16)) then\nD0.f16 = S0.f16\nelsif isQuietNAN(64'F(S1.f16)) then\nD0.f16 = S1.f16\nelsif ((S0.f16 > S1.f16) || ((abs(S0.f16) == 16'0.0) && (abs(S1.f16) == 16'0.0) && !sign(S0.f16) &&\nsign(S1.f16))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif",
  SOP2Op.S_ADD_NC_U64: 'D0.u64 = S0.u64 + S1.u64',
  SOP2Op.S_SUB_NC_U64: 'D0.u64 = S0.u64 - S1.u64',
  SOP2Op.S_MUL_U64: 'D0.u64 = S0.u64 * S1.u64',
  SOPCOp.S_CMP_EQ_I32: 'SCC = S0.i32 == S1.i32',
  SOPCOp.S_CMP_LG_I32: 'SCC = S0.i32 <> S1.i32',
  SOPCOp.S_CMP_GT_I32: 'SCC = S0.i32 > S1.i32',
  SOPCOp.S_CMP_GE_I32: 'SCC = S0.i32 >= S1.i32',
  SOPCOp.S_CMP_LT_I32: 'SCC = S0.i32 < S1.i32',
  SOPCOp.S_CMP_LE_I32: 'SCC = S0.i32 <= S1.i32',
  SOPCOp.S_CMP_EQ_U32: 'SCC = S0.u32 == S1.u32',
  SOPCOp.S_CMP_LG_U32: 'SCC = S0.u32 <> S1.u32',
  SOPCOp.S_CMP_GT_U32: 'SCC = S0.u32 > S1.u32',
  SOPCOp.S_CMP_GE_U32: 'SCC = S0.u32 >= S1.u32',
  SOPCOp.S_CMP_LT_U32: 'SCC = S0.u32 < S1.u32',
  SOPCOp.S_CMP_LE_U32: 'SCC = S0.u32 <= S1.u32',
  SOPCOp.S_BITCMP0_B32: "SCC = S0.u32[S1.u32[4 : 0]] == 1'0U",
  SOPCOp.S_BITCMP1_B32: "SCC = S0.u32[S1.u32[4 : 0]] == 1'1U",
  SOPCOp.S_BITCMP0_B64: "SCC = S0.u64[S1.u32[5 : 0]] == 1'0U",
  SOPCOp.S_BITCMP1_B64: "SCC = S0.u64[S1.u32[5 : 0]] == 1'1U",
  SOPCOp.S_CMP_EQ_U64: 'SCC = S0.u64 == S1.u64',
  SOPCOp.S_CMP_LG_U64: 'SCC = S0.u64 <> S1.u64',
  SOPCOp.S_CMP_LT_F32: 'SCC = S0.f32 < S1.f32',
  SOPCOp.S_CMP_EQ_F32: 'SCC = S0.f32 == S1.f32',
  SOPCOp.S_CMP_LE_F32: 'SCC = S0.f32 <= S1.f32',
  SOPCOp.S_CMP_GT_F32: 'SCC = S0.f32 > S1.f32',
  SOPCOp.S_CMP_LG_F32: 'SCC = S0.f32 <> S1.f32',
  SOPCOp.S_CMP_GE_F32: 'SCC = S0.f32 >= S1.f32',
  SOPCOp.S_CMP_O_F32: "SCC = (!isNAN(64'F(S0.f32)) && !isNAN(64'F(S1.f32)))",
  SOPCOp.S_CMP_U_F32: "SCC = (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)))",
  SOPCOp.S_CMP_NGE_F32: 'SCC = !(S0.f32 >= S1.f32);\n// With NAN inputs this is not the same operation as <',
  SOPCOp.S_CMP_NLG_F32: 'SCC = !(S0.f32 <> S1.f32);\n// With NAN inputs this is not the same operation as ==',
  SOPCOp.S_CMP_NGT_F32: 'SCC = !(S0.f32 > S1.f32);\n// With NAN inputs this is not the same operation as <=',
  SOPCOp.S_CMP_NLE_F32: 'SCC = !(S0.f32 <= S1.f32);\n// With NAN inputs this is not the same operation as >',
  SOPCOp.S_CMP_NEQ_F32: 'SCC = !(S0.f32 == S1.f32);\n// With NAN inputs this is not the same operation as !=',
  SOPCOp.S_CMP_NLT_F32: 'SCC = !(S0.f32 < S1.f32);\n// With NAN inputs this is not the same operation as >=',
  SOPCOp.S_CMP_LT_F16: 'SCC = S0.f16 < S1.f16',
  SOPCOp.S_CMP_EQ_F16: 'SCC = S0.f16 == S1.f16',
  SOPCOp.S_CMP_LE_F16: 'SCC = S0.f16 <= S1.f16',
  SOPCOp.S_CMP_GT_F16: 'SCC = S0.f16 > S1.f16',
  SOPCOp.S_CMP_LG_F16: 'SCC = S0.f16 <> S1.f16',
  SOPCOp.S_CMP_GE_F16: 'SCC = S0.f16 >= S1.f16',
  SOPCOp.S_CMP_O_F16: "SCC = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)))",
  SOPCOp.S_CMP_U_F16: "SCC = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)))",
  SOPCOp.S_CMP_NGE_F16: 'SCC = !(S0.f16 >= S1.f16);\n// With NAN inputs this is not the same operation as <',
  SOPCOp.S_CMP_NLG_F16: 'SCC = !(S0.f16 <> S1.f16);\n// With NAN inputs this is not the same operation as ==',
  SOPCOp.S_CMP_NGT_F16: 'SCC = !(S0.f16 > S1.f16);\n// With NAN inputs this is not the same operation as <=',
  SOPCOp.S_CMP_NLE_F16: 'SCC = !(S0.f16 <= S1.f16);\n// With NAN inputs this is not the same operation as >',
  SOPCOp.S_CMP_NEQ_F16: 'SCC = !(S0.f16 == S1.f16);\n// With NAN inputs this is not the same operation as !=',
  SOPCOp.S_CMP_NLT_F16: 'SCC = !(S0.f16 < S1.f16);\n// With NAN inputs this is not the same operation as >=',
  SOPKOp.S_MOVK_I32: "D0.i32 = 32'I(signext(S0.i16))",
  SOPKOp.S_VERSION: 'nop();\n// Do nothing - for use by tools only',
  SOPKOp.S_CMOVK_I32: "if SCC then\nD0.i32 = 32'I(signext(S0.i16))\nendif",
  SOPKOp.S_ADDK_CO_I32: "tmp = D0.i32;\n// Save value to check sign bits for overflow later.\nD0.i32 = D0.i32 + 32'I(signext(S0.i16));\nSCC = ((tmp[31] == S0.i16[15]) && (tmp[31] != D0.i32[31]));\n// signed overflow.",
  SOPKOp.S_MULK_I32: "D0.i32 = D0.i32 * 32'I(signext(S0.i16))",
  SOPKOp.S_GETREG_B32: "hwRegId = SIMM16.u16[5 : 0];\noffset = SIMM16.u16[10 : 6];\nsize = SIMM16.u16[15 : 11].u32 + 1U;\n// logical size is in range 1:32\nvalue = HW_REGISTERS[hwRegId];\nD0.u32 = 32'U(32'I(value >> offset.u32) & ((1 << size) - 1))",
  SOPKOp.S_SETREG_B32: "hwRegId = SIMM16.u16[5 : 0];\noffset = SIMM16.u16[10 : 6];\nsize = SIMM16.u16[15 : 11].u32 + 1U;\n// logical size is in range 1:32\nmask = (1 << size) - 1;\nmask = (mask << offset.u32);\nmask = (mask & HwRegWriteMask(hwRegId, WAVE_STATUS.PRIV));\n// Mask of bits that can be modified\nvalue = ((S0.u32 << offset.u32) & mask.u32);\nvalue = (value | 32'U(HW_REGISTERS[hwRegId].i32 & ~mask));\nHW_REGISTERS[hwRegId] = value.b32;\n// Side-effects may trigger here if certain bits are modified",
  SOPKOp.S_SETREG_IMM32_B32: "hwRegId = SIMM16.u16[5 : 0];\noffset = SIMM16.u16[10 : 6];\nsize = SIMM16.u16[15 : 11].u32 + 1U;\n// logical size is in range 1:32\nmask = (1 << size) - 1;\nmask = (mask << offset.u32);\nmask = (mask & HwRegWriteMask(hwRegId, WAVE_STATUS.PRIV));\n// Mask of bits that can be modified\nvalue = ((SIMM32.u32 << offset.u32) & mask.u32);\nvalue = (value | 32'U(HW_REGISTERS[hwRegId].i32 & ~mask));\nHW_REGISTERS[hwRegId] = value.b32;\n// Side-effects may trigger here if certain bits are modified",
  SOPKOp.S_CALL_B64: "D0.i64 = PC + 4LL;\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL",
  SOPPOp.S_NOP: 'for i in 0U : SIMM16.u16[3 : 0].u32 do\nnop()\nendfor',
  SOPPOp.S_SLEEP: 's_sleep { duration: 0 }       // Wait for 0 clocks.\ns_sleep { duration: 1 }       // Wait for 1-64 clocks.\ns_sleep { duration: 2 }       // Wait for 65-128 clocks.\ns_sleep { sleep_forever: 1 }        // Wait until an event occurs.',
  SOPPOp.S_DELAY_ALU: 'v_mov_b32 v3, v0\nv_lshlrev_b32   v30, 1, v31\nv_lshlrev_b32   v24, 1, v25\ns_delay_alu { instid0: INSTID_VALU_DEP_3, instskip: INSTSKIP_SKIP_1, instid1: INSTID_VALU_DEP_1 }\n// 1 cycle delay here\nv_add_f32  v0, v1, v3\nv_sub_f32  v11, v9, v9\n// 2 cycles delay here\nv_mul_f32  v10, v13, v11',
  SOPPOp.S_TRAP: 'TrapID = SIMM16.u16[3 : 0].u8;\n"Wait for all instructions to complete";\n// PC passed into trap handler points to S_TRAP itself,\n// *not* to the next instruction.\n{ TTMP[1], TTMP[0] } = { TrapID[3 : 0], 12\'0, PC[47 : 0] };\nPC = TBA.i64;\n// trap base address\nWAVE_STATUS.PRIV = 1\'1U',
  SOPPOp.S_BARRIER_WAIT: ";\n// barrierBit 0: reserved\n// barrierBit 1: workgroup\n// barrierBit 2: trap\nbarrierBit = SIMM16.i32 >= 0 ? 0 : SIMM16.i32 == -1 ? 1 : 2;\nwhile !WAVE_BARRIER_COMPLETE[barrierBit] do\n// Implemented as a power-saving idle\ns_nop(16'0U)\nendwhile;\nWAVE_BARRIER_COMPLETE[barrierBit] = 1'0U",
  SOPPOp.S_CODE_END: '...\ns_endpgm     // last real instruction in shader buffer\ns_code_end      // 1\ns_code_end      // 2\ns_code_end      // 3\ns_code_end      // 4\ns_code_end      // done!',
  SOPPOp.S_BRANCH: "PC = PC + signext(SIMM16.i16 * 16'4) + 4LL;\n// short jump.",
  SOPPOp.S_CBRANCH_SCC0: "if SCC == 1'0U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif",
  SOPPOp.S_CBRANCH_SCC1: "if SCC == 1'1U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif",
  SOPPOp.S_CBRANCH_VCCZ: "if VCCZ.u1 == 1'1U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif",
  SOPPOp.S_CBRANCH_VCCNZ: "if VCCZ.u1 == 1'0U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif",
  SOPPOp.S_CBRANCH_EXECZ: "if EXECZ.u1 == 1'1U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif",
  SOPPOp.S_CBRANCH_EXECNZ: "if EXECZ.u1 == 1'0U then\nPC = PC + signext(SIMM16.i16 * 16'4) + 4LL\nelse\nPC = PC + 4LL\nendif",
  SOPPOp.S_SETPRIO: 'SysUserPrio = MIN(3, SysPrio[1:0] + UserPrio[1:0]). Priority = {SysUserPrio[1:0], WaveAge[3:0]}',
  VBUFFEROp.BUFFER_LOAD_FORMAT_X: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 0].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetX()]);\n// Mem access size depends on format',
  VBUFFEROp.BUFFER_LOAD_FORMAT_XY: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 0].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetX()]);\n// Mem access size depends on format\nVDATA[63 : 32].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetY()])',
  VBUFFEROp.BUFFER_LOAD_FORMAT_XYZ: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 0].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetX()]);\n// Mem access size depends on format\nVDATA[63 : 32].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetY()]);\nVDATA[95 : 64].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetZ()])',
  VBUFFEROp.BUFFER_LOAD_FORMAT_XYZW: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 0].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetX()]);\n// Mem access size depends on format\nVDATA[63 : 32].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetY()]);\nVDATA[95 : 64].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetZ()]);\nVDATA[127 : 96].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetW()])',
  VBUFFEROp.BUFFER_STORE_FORMAT_X: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format',
  VBUFFEROp.BUFFER_STORE_FORMAT_XY: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format\nMEM[addr + ChannelOffsetY()] = ConvertToFormat(VDATA[63 : 32].b32)',
  VBUFFEROp.BUFFER_STORE_FORMAT_XYZ: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format\nMEM[addr + ChannelOffsetY()] = ConvertToFormat(VDATA[63 : 32].b32);\nMEM[addr + ChannelOffsetZ()] = ConvertToFormat(VDATA[95 : 64].b32)',
  VBUFFEROp.BUFFER_STORE_FORMAT_XYZW: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format\nMEM[addr + ChannelOffsetY()] = ConvertToFormat(VDATA[63 : 32].b32);\nMEM[addr + ChannelOffsetZ()] = ConvertToFormat(VDATA[95 : 64].b32);\nMEM[addr + ChannelOffsetW()] = ConvertToFormat(VDATA[127 : 96].b32)',
  VBUFFEROp.BUFFER_LOAD_D16_FORMAT_X: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetX()]));\n// Mem access size depends on format\n// VDATA[31:16].b16 is preserved.",
  VBUFFEROp.BUFFER_LOAD_D16_FORMAT_XY: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetX()]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetY()]))",
  VBUFFEROp.BUFFER_LOAD_D16_FORMAT_XYZ: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetX()]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetY()]));\nVDATA[47 : 32].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetZ()]));\n// VDATA[63:48].b16 is preserved.",
  VBUFFEROp.BUFFER_LOAD_D16_FORMAT_XYZW: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetX()]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetY()]));\nVDATA[47 : 32].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetZ()]));\nVDATA[63 : 48].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetW()]))",
  VBUFFEROp.BUFFER_STORE_D16_FORMAT_X: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format",
  VBUFFEROp.BUFFER_STORE_D16_FORMAT_XY: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[addr + ChannelOffsetY()] = ConvertToFormat(32'B(VDATA[31 : 16].b16))",
  VBUFFEROp.BUFFER_STORE_D16_FORMAT_XYZ: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[addr + ChannelOffsetY()] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\nMEM[addr + ChannelOffsetZ()] = ConvertToFormat(32'B(VDATA[47 : 32].b16))",
  VBUFFEROp.BUFFER_STORE_D16_FORMAT_XYZW: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[addr + ChannelOffsetY()] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\nMEM[addr + ChannelOffsetZ()] = ConvertToFormat(32'B(VDATA[47 : 32].b16));\nMEM[addr + ChannelOffsetW()] = ConvertToFormat(32'B(VDATA[63 : 48].b16))",
  VBUFFEROp.BUFFER_LOAD_U8: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA.u32 = 32'U({ 24'0U, MEM[addr].u8 })",
  VBUFFEROp.BUFFER_LOAD_I8: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA.i32 = 32'I(signext(MEM[addr].i8))",
  VBUFFEROp.BUFFER_LOAD_U16: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA.u32 = 32'U({ 16'0U, MEM[addr].u16 })",
  VBUFFEROp.BUFFER_LOAD_I16: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA.i32 = 32'I(signext(MEM[addr].i16))",
  VBUFFEROp.BUFFER_LOAD_B32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 0] = MEM[addr].b32',
  VBUFFEROp.BUFFER_LOAD_B64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 0] = MEM[addr].b32;\nVDATA[63 : 32] = MEM[addr + 4U].b32',
  VBUFFEROp.BUFFER_LOAD_B96: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 0] = MEM[addr].b32;\nVDATA[63 : 32] = MEM[addr + 4U].b32;\nVDATA[95 : 64] = MEM[addr + 8U].b32',
  VBUFFEROp.BUFFER_LOAD_B128: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 0] = MEM[addr].b32;\nVDATA[63 : 32] = MEM[addr + 4U].b32;\nVDATA[95 : 64] = MEM[addr + 8U].b32;\nVDATA[127 : 96] = MEM[addr + 12U].b32',
  VBUFFEROp.BUFFER_STORE_B8: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr].b8 = VDATA[7 : 0]',
  VBUFFEROp.BUFFER_STORE_B16: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr].b16 = VDATA[15 : 0]',
  VBUFFEROp.BUFFER_STORE_B32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr].b32 = VDATA[31 : 0]',
  VBUFFEROp.BUFFER_STORE_B64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr].b32 = VDATA[31 : 0];\nMEM[addr + 4U].b32 = VDATA[63 : 32]',
  VBUFFEROp.BUFFER_STORE_B96: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr].b32 = VDATA[31 : 0];\nMEM[addr + 4U].b32 = VDATA[63 : 32];\nMEM[addr + 8U].b32 = VDATA[95 : 64]',
  VBUFFEROp.BUFFER_STORE_B128: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr].b32 = VDATA[31 : 0];\nMEM[addr + 4U].b32 = VDATA[63 : 32];\nMEM[addr + 8U].b32 = VDATA[95 : 64];\nMEM[addr + 12U].b32 = VDATA[127 : 96]',
  VBUFFEROp.BUFFER_LOAD_D16_U8: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[15 : 0].u16 = 16'U({ 8'0U, MEM[addr].u8 });\n// VDATA[31:16] is preserved.",
  VBUFFEROp.BUFFER_LOAD_D16_I8: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[15 : 0].i16 = 16'I(signext(MEM[addr].i8));\n// VDATA[31:16] is preserved.",
  VBUFFEROp.BUFFER_LOAD_D16_B16: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[15 : 0].b16 = MEM[addr].b16;\n// VDATA[31:16] is preserved.',
  VBUFFEROp.BUFFER_LOAD_D16_HI_U8: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 16].u16 = 16'U({ 8'0U, MEM[addr].u8 });\n// VDATA[15:0] is preserved.",
  VBUFFEROp.BUFFER_LOAD_D16_HI_I8: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 16].i16 = 16'I(signext(MEM[addr].i8));\n// VDATA[15:0] is preserved.",
  VBUFFEROp.BUFFER_LOAD_D16_HI_B16: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 16].b16 = MEM[addr].b16;\n// VDATA[15:0] is preserved.',
  VBUFFEROp.BUFFER_STORE_D16_HI_B8: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr].b8 = VDATA[23 : 16]',
  VBUFFEROp.BUFFER_STORE_D16_HI_B16: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr].b16 = VDATA[31 : 16]',
  VBUFFEROp.BUFFER_LOAD_D16_HI_FORMAT_X: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetX()]));\n// Mem access size depends on format\n// VDATA[15:0].b16 is preserved.",
  VBUFFEROp.BUFFER_STORE_D16_HI_FORMAT_X: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\n// Mem access size depends on format",
  VBUFFEROp.BUFFER_ATOMIC_SWAP_B32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = DATA.b32;\nRETURN_DATA.b32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_CMPSWAP_B32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u32;\nsrc = DATA[31 : 0].u32;\ncmp = DATA[63 : 32].u32;\nMEM[addr].u32 = tmp == cmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_ADD_U32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u32;\nMEM[addr].u32 += DATA.u32;\nRETURN_DATA.u32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_SUB_U32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u32;\nMEM[addr].u32 -= DATA.u32;\nRETURN_DATA.u32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_SUB_CLAMP_U32: "declare new_value : 32'U;\nold_value = MEM[ADDR].u32;\nif old_value < DATA.u32 then\nnew_value = 0U\nelse\nnew_value = old_value - DATA.u32\nendif;\nMEM[ADDR].u32 = new_value;\nRETURN_DATA.u32 = old_value",
  VBUFFEROp.BUFFER_ATOMIC_MIN_I32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].i32;\nsrc = DATA.i32;\nMEM[addr].i32 = src < tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_MIN_U32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = src < tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_MAX_I32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].i32;\nsrc = DATA.i32;\nMEM[addr].i32 = src >= tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_MAX_U32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = src >= tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_AND_B32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp & DATA.b32);\nRETURN_DATA.b32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_OR_B32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp | DATA.b32);\nRETURN_DATA.b32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_XOR_B32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp ^ DATA.b32);\nRETURN_DATA.b32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_INC_U32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_DEC_U32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_SWAP_B64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = DATA.b64;\nRETURN_DATA.b64 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_CMPSWAP_B64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u64;\nsrc = DATA[63 : 0].u64;\ncmp = DATA[127 : 64].u64;\nMEM[addr].u64 = tmp == cmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_ADD_U64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u64;\nMEM[addr].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_SUB_U64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u64;\nMEM[addr].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_MIN_I64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].i64;\nsrc = DATA.i64;\nMEM[addr].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_MIN_U64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_MAX_I64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].i64;\nsrc = DATA.i64;\nMEM[addr].i64 = src >= tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_MAX_U64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = src >= tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_AND_B64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_OR_B64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp | DATA.b64);\nRETURN_DATA.b64 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_XOR_B64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_INC_U64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_DEC_U64: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_COND_SUB_U32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = tmp >= src ? tmp - src : tmp;\nRETURN_DATA.u32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_MIN_NUM_F32: "tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nif (isNAN(64'F(src.f32)) && isNAN(64'F(tmp.f32))) then\nMEM[ADDR].f32 = 32'F(cvtToQuietNAN(64'F(src.f32)))\nelsif isNAN(64'F(src.f32)) then\nMEM[ADDR].f32 = tmp.f32\nelsif isNAN(64'F(tmp.f32)) then\nMEM[ADDR].f32 = src.f32\nelsif ((src.f32 < tmp.f32) || ((abs(src.f32) == 0.0F) && (abs(tmp.f32) == 0.0F) && sign(src.f32) &&\n!sign(tmp.f32))) then\n// NOTE: -0<+0 is TRUE in this comparison\nMEM[ADDR].f32 = src.f32\nelse\nMEM[ADDR].f32 = tmp.f32\nendif;\nRETURN_DATA.f32 = tmp",
  VBUFFEROp.BUFFER_ATOMIC_MAX_NUM_F32: "tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nif (isNAN(64'F(src.f32)) && isNAN(64'F(tmp.f32))) then\nMEM[ADDR].f32 = 32'F(cvtToQuietNAN(64'F(src.f32)))\nelsif isNAN(64'F(src.f32)) then\nMEM[ADDR].f32 = tmp.f32\nelsif isNAN(64'F(tmp.f32)) then\nMEM[ADDR].f32 = src.f32\nelsif ((src.f32 > tmp.f32) || ((abs(src.f32) == 0.0F) && (abs(tmp.f32) == 0.0F) && !sign(src.f32) &&\nsign(tmp.f32))) then\n// NOTE: +0>-0 is TRUE in this comparison\nMEM[ADDR].f32 = src.f32\nelse\nMEM[ADDR].f32 = tmp.f32\nendif;\nRETURN_DATA.f32 = tmp",
  VBUFFEROp.BUFFER_ATOMIC_ADD_F32: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\ntmp = MEM[addr].f32;\nMEM[addr].f32 += DATA.f32;\nRETURN_DATA.f32 = tmp',
  VBUFFEROp.BUFFER_ATOMIC_PK_ADD_F16: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ndst[15 : 0].f16 = src[15 : 0].f16 + tmp[15 : 0].f16;\ndst[31 : 16].f16 = src[31 : 16].f16 + tmp[31 : 16].f16;\nMEM[ADDR].b32 = dst.b32;\nRETURN_DATA.b32 = tmp.b32',
  VBUFFEROp.BUFFER_ATOMIC_PK_ADD_BF16: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ndst[15 : 0].bf16 = src[15 : 0].bf16 + tmp[15 : 0].bf16;\ndst[31 : 16].bf16 = src[31 : 16].bf16 + tmp[31 : 16].bf16;\nMEM[ADDR].b32 = dst.b32;\nRETURN_DATA.b32 = tmp.b32',
  VBUFFEROp.TBUFFER_LOAD_FORMAT_X: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 0].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetX()]);\n// Mem access size depends on format',
  VBUFFEROp.TBUFFER_LOAD_FORMAT_XY: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 0].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetX()]);\n// Mem access size depends on format\nVDATA[63 : 32].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetY()])',
  VBUFFEROp.TBUFFER_LOAD_FORMAT_XYZ: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 0].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetX()]);\n// Mem access size depends on format\nVDATA[63 : 32].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetY()]);\nVDATA[95 : 64].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetZ()])',
  VBUFFEROp.TBUFFER_LOAD_FORMAT_XYZW: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[31 : 0].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetX()]);\n// Mem access size depends on format\nVDATA[63 : 32].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetY()]);\nVDATA[95 : 64].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetZ()]);\nVDATA[127 : 96].b32 = ConvertFromFormat(MEM[addr + ChannelOffsetW()])',
  VBUFFEROp.TBUFFER_STORE_FORMAT_X: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format',
  VBUFFEROp.TBUFFER_STORE_FORMAT_XY: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format\nMEM[addr + ChannelOffsetY()] = ConvertToFormat(VDATA[63 : 32].b32)',
  VBUFFEROp.TBUFFER_STORE_FORMAT_XYZ: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format\nMEM[addr + ChannelOffsetY()] = ConvertToFormat(VDATA[63 : 32].b32);\nMEM[addr + ChannelOffsetZ()] = ConvertToFormat(VDATA[95 : 64].b32)',
  VBUFFEROp.TBUFFER_STORE_FORMAT_XYZW: 'addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(VDATA[31 : 0].b32);\n// Mem access size depends on format\nMEM[addr + ChannelOffsetY()] = ConvertToFormat(VDATA[63 : 32].b32);\nMEM[addr + ChannelOffsetZ()] = ConvertToFormat(VDATA[95 : 64].b32);\nMEM[addr + ChannelOffsetW()] = ConvertToFormat(VDATA[127 : 96].b32)',
  VBUFFEROp.TBUFFER_LOAD_D16_FORMAT_X: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetX()]));\n// Mem access size depends on format\n// VDATA[31:16].b16 is preserved.",
  VBUFFEROp.TBUFFER_LOAD_D16_FORMAT_XY: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetX()]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetY()]))",
  VBUFFEROp.TBUFFER_LOAD_D16_FORMAT_XYZ: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetX()]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetY()]));\nVDATA[47 : 32].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetZ()]));\n// VDATA[63:48].b16 is preserved.",
  VBUFFEROp.TBUFFER_LOAD_D16_FORMAT_XYZW: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nVDATA[15 : 0].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetX()]));\n// Mem access size depends on format\nVDATA[31 : 16].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetY()]));\nVDATA[47 : 32].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetZ()]));\nVDATA[63 : 48].b16 = 16'B(ConvertFromFormat(MEM[addr + ChannelOffsetW()]))",
  VBUFFEROp.TBUFFER_STORE_D16_FORMAT_X: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format",
  VBUFFEROp.TBUFFER_STORE_D16_FORMAT_XY: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[addr + ChannelOffsetY()] = ConvertToFormat(32'B(VDATA[31 : 16].b16))",
  VBUFFEROp.TBUFFER_STORE_D16_FORMAT_XYZ: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[addr + ChannelOffsetY()] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\nMEM[addr + ChannelOffsetZ()] = ConvertToFormat(32'B(VDATA[47 : 32].b16))",
  VBUFFEROp.TBUFFER_STORE_D16_FORMAT_XYZW: "addr = CalcBufferAddr(vgpr_a.b64, sgpr_o.b64);\nMEM[addr + ChannelOffsetX()] = ConvertToFormat(32'B(VDATA[15 : 0].b16));\n// Mem access size depends on format\nMEM[addr + ChannelOffsetY()] = ConvertToFormat(32'B(VDATA[31 : 16].b16));\nMEM[addr + ChannelOffsetZ()] = ConvertToFormat(32'B(VDATA[47 : 32].b16));\nMEM[addr + ChannelOffsetW()] = ConvertToFormat(32'B(VDATA[63 : 48].b16))",
  VFLATOp.FLAT_LOAD_U8: "addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA.u32 = 32'U({ 24'0U, MEM[addr].u8 })",
  VFLATOp.FLAT_LOAD_I8: "addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA.i32 = 32'I(signext(MEM[addr].i8))",
  VFLATOp.FLAT_LOAD_U16: "addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA.u32 = 32'U({ 16'0U, MEM[addr].u16 })",
  VFLATOp.FLAT_LOAD_I16: "addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA.i32 = 32'I(signext(MEM[addr].i16))",
  VFLATOp.FLAT_LOAD_B32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA[31 : 0] = MEM[addr].b32',
  VFLATOp.FLAT_LOAD_B64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA[31 : 0] = MEM[addr].b32;\nVDATA[63 : 32] = MEM[addr + 4U].b32',
  VFLATOp.FLAT_LOAD_B96: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA[31 : 0] = MEM[addr].b32;\nVDATA[63 : 32] = MEM[addr + 4U].b32;\nVDATA[95 : 64] = MEM[addr + 8U].b32',
  VFLATOp.FLAT_LOAD_B128: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA[31 : 0] = MEM[addr].b32;\nVDATA[63 : 32] = MEM[addr + 4U].b32;\nVDATA[95 : 64] = MEM[addr + 8U].b32;\nVDATA[127 : 96] = MEM[addr + 12U].b32',
  VFLATOp.FLAT_STORE_B8: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nMEM[addr].b8 = VDATA[7 : 0]',
  VFLATOp.FLAT_STORE_B16: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nMEM[addr].b16 = VDATA[15 : 0]',
  VFLATOp.FLAT_STORE_B32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nMEM[addr].b32 = VDATA[31 : 0]',
  VFLATOp.FLAT_STORE_B64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nMEM[addr].b32 = VDATA[31 : 0];\nMEM[addr + 4U].b32 = VDATA[63 : 32]',
  VFLATOp.FLAT_STORE_B96: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nMEM[addr].b32 = VDATA[31 : 0];\nMEM[addr + 4U].b32 = VDATA[63 : 32];\nMEM[addr + 8U].b32 = VDATA[95 : 64]',
  VFLATOp.FLAT_STORE_B128: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nMEM[addr].b32 = VDATA[31 : 0];\nMEM[addr + 4U].b32 = VDATA[63 : 32];\nMEM[addr + 8U].b32 = VDATA[95 : 64];\nMEM[addr + 12U].b32 = VDATA[127 : 96]',
  VFLATOp.FLAT_LOAD_D16_U8: "addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA[15 : 0].u16 = 16'U({ 8'0U, MEM[addr].u8 });\n// VDATA[31:16] is preserved.",
  VFLATOp.FLAT_LOAD_D16_I8: "addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA[15 : 0].i16 = 16'I(signext(MEM[addr].i8));\n// VDATA[31:16] is preserved.",
  VFLATOp.FLAT_LOAD_D16_B16: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA[15 : 0].b16 = MEM[addr].b16;\n// VDATA[31:16] is preserved.',
  VFLATOp.FLAT_LOAD_D16_HI_U8: "addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA[31 : 16].u16 = 16'U({ 8'0U, MEM[addr].u8 });\n// VDATA[15:0] is preserved.",
  VFLATOp.FLAT_LOAD_D16_HI_I8: "addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA[31 : 16].i16 = 16'I(signext(MEM[addr].i8));\n// VDATA[15:0] is preserved.",
  VFLATOp.FLAT_LOAD_D16_HI_B16: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nVDATA[31 : 16].b16 = MEM[addr].b16;\n// VDATA[15:0] is preserved.',
  VFLATOp.FLAT_STORE_D16_HI_B8: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nMEM[addr].b8 = VDATA[23 : 16]',
  VFLATOp.FLAT_STORE_D16_HI_B16: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\nMEM[addr].b16 = VDATA[31 : 16]',
  VFLATOp.GLOBAL_LOAD_ADDTID_B32: "RETURN_DATA.u32 = MEM[SGPR_ADDR[63 : 0] + INST_OFFSET[11 : 0].b64 + 64'B(laneID.i32 * 4)].u32",
  VFLATOp.GLOBAL_STORE_ADDTID_B32: "MEM[SGPR_ADDR[63 : 0] + INST_OFFSET[11 : 0].b64 + 64'B(laneID.i32 * 4)].u32 = DATA.u32",
  VFLATOp.FLAT_ATOMIC_SWAP_B32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = DATA.b32;\nRETURN_DATA.b32 = tmp',
  VFLATOp.FLAT_ATOMIC_CMPSWAP_B32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u32;\nsrc = DATA[31 : 0].u32;\ncmp = DATA[63 : 32].u32;\nMEM[addr].u32 = tmp == cmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  VFLATOp.FLAT_ATOMIC_ADD_U32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u32;\nMEM[addr].u32 += DATA.u32;\nRETURN_DATA.u32 = tmp',
  VFLATOp.FLAT_ATOMIC_SUB_U32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u32;\nMEM[addr].u32 -= DATA.u32;\nRETURN_DATA.u32 = tmp',
  VFLATOp.FLAT_ATOMIC_SUB_CLAMP_U32: "declare new_value : 32'U;\nold_value = MEM[ADDR].u32;\nif old_value < DATA.u32 then\nnew_value = 0U\nelse\nnew_value = old_value - DATA.u32\nendif;\nMEM[ADDR].u32 = new_value;\nRETURN_DATA.u32 = old_value",
  VFLATOp.FLAT_ATOMIC_MIN_I32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].i32;\nsrc = DATA.i32;\nMEM[addr].i32 = src < tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  VFLATOp.FLAT_ATOMIC_MIN_U32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = src < tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  VFLATOp.FLAT_ATOMIC_MAX_I32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].i32;\nsrc = DATA.i32;\nMEM[addr].i32 = src >= tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  VFLATOp.FLAT_ATOMIC_MAX_U32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = src >= tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  VFLATOp.FLAT_ATOMIC_AND_B32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp & DATA.b32);\nRETURN_DATA.b32 = tmp',
  VFLATOp.FLAT_ATOMIC_OR_B32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp | DATA.b32);\nRETURN_DATA.b32 = tmp',
  VFLATOp.FLAT_ATOMIC_XOR_B32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp ^ DATA.b32);\nRETURN_DATA.b32 = tmp',
  VFLATOp.FLAT_ATOMIC_INC_U32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u32 = tmp',
  VFLATOp.FLAT_ATOMIC_DEC_U32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u32 = tmp',
  VFLATOp.FLAT_ATOMIC_SWAP_B64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = DATA.b64;\nRETURN_DATA.b64 = tmp',
  VFLATOp.FLAT_ATOMIC_CMPSWAP_B64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u64;\nsrc = DATA[63 : 0].u64;\ncmp = DATA[127 : 64].u64;\nMEM[addr].u64 = tmp == cmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  VFLATOp.FLAT_ATOMIC_ADD_U64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u64;\nMEM[addr].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp',
  VFLATOp.FLAT_ATOMIC_SUB_U64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u64;\nMEM[addr].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp',
  VFLATOp.FLAT_ATOMIC_MIN_I64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].i64;\nsrc = DATA.i64;\nMEM[addr].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  VFLATOp.FLAT_ATOMIC_MIN_U64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  VFLATOp.FLAT_ATOMIC_MAX_I64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].i64;\nsrc = DATA.i64;\nMEM[addr].i64 = src >= tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  VFLATOp.FLAT_ATOMIC_MAX_U64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = src >= tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  VFLATOp.FLAT_ATOMIC_AND_B64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp',
  VFLATOp.FLAT_ATOMIC_OR_B64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp | DATA.b64);\nRETURN_DATA.b64 = tmp',
  VFLATOp.FLAT_ATOMIC_XOR_B64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp',
  VFLATOp.FLAT_ATOMIC_INC_U64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp',
  VFLATOp.FLAT_ATOMIC_DEC_U64: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp',
  VFLATOp.FLAT_ATOMIC_COND_SUB_U32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = tmp >= src ? tmp - src : tmp;\nRETURN_DATA.u32 = tmp',
  VFLATOp.FLAT_ATOMIC_MIN_NUM_F32: "tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nif (isNAN(64'F(src.f32)) && isNAN(64'F(tmp.f32))) then\nMEM[ADDR].f32 = 32'F(cvtToQuietNAN(64'F(src.f32)))\nelsif isNAN(64'F(src.f32)) then\nMEM[ADDR].f32 = tmp.f32\nelsif isNAN(64'F(tmp.f32)) then\nMEM[ADDR].f32 = src.f32\nelsif ((src.f32 < tmp.f32) || ((abs(src.f32) == 0.0F) && (abs(tmp.f32) == 0.0F) && sign(src.f32) &&\n!sign(tmp.f32))) then\n// NOTE: -0<+0 is TRUE in this comparison\nMEM[ADDR].f32 = src.f32\nelse\nMEM[ADDR].f32 = tmp.f32\nendif;\nRETURN_DATA.f32 = tmp",
  VFLATOp.FLAT_ATOMIC_MAX_NUM_F32: "tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nif (isNAN(64'F(src.f32)) && isNAN(64'F(tmp.f32))) then\nMEM[ADDR].f32 = 32'F(cvtToQuietNAN(64'F(src.f32)))\nelsif isNAN(64'F(src.f32)) then\nMEM[ADDR].f32 = tmp.f32\nelsif isNAN(64'F(tmp.f32)) then\nMEM[ADDR].f32 = src.f32\nelsif ((src.f32 > tmp.f32) || ((abs(src.f32) == 0.0F) && (abs(tmp.f32) == 0.0F) && !sign(src.f32) &&\nsign(tmp.f32))) then\n// NOTE: +0>-0 is TRUE in this comparison\nMEM[ADDR].f32 = src.f32\nelse\nMEM[ADDR].f32 = tmp.f32\nendif;\nRETURN_DATA.f32 = tmp",
  VFLATOp.FLAT_ATOMIC_ADD_F32: 'addr = CalcFlatAddr(v_addr.b64, flat_scratch.b64);\ntmp = MEM[addr].f32;\nMEM[addr].f32 += DATA.f32;\nRETURN_DATA.f32 = tmp',
  VFLATOp.FLAT_ATOMIC_PK_ADD_F16: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ndst[15 : 0].f16 = src[15 : 0].f16 + tmp[15 : 0].f16;\ndst[31 : 16].f16 = src[31 : 16].f16 + tmp[31 : 16].f16;\nMEM[ADDR].b32 = dst.b32;\nRETURN_DATA.b32 = tmp.b32',
  VFLATOp.FLAT_ATOMIC_PK_ADD_BF16: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ndst[15 : 0].bf16 = src[15 : 0].bf16 + tmp[15 : 0].bf16;\ndst[31 : 16].bf16 = src[31 : 16].bf16 + tmp[31 : 16].bf16;\nMEM[ADDR].b32 = dst.b32;\nRETURN_DATA.b32 = tmp.b32',
  VGLOBALOp.GLOBAL_LOAD_U8: "addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA.u32 = 32'U({ 24'0U, MEM[addr].u8 })",
  VGLOBALOp.GLOBAL_LOAD_I8: "addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA.i32 = 32'I(signext(MEM[addr].i8))",
  VGLOBALOp.GLOBAL_LOAD_U16: "addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA.u32 = 32'U({ 16'0U, MEM[addr].u16 })",
  VGLOBALOp.GLOBAL_LOAD_I16: "addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA.i32 = 32'I(signext(MEM[addr].i16))",
  VGLOBALOp.GLOBAL_LOAD_B32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA[31 : 0] = MEM[addr].b32',
  VGLOBALOp.GLOBAL_LOAD_B64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA[31 : 0] = MEM[addr].b32;\nVDATA[63 : 32] = MEM[addr + 4U].b32',
  VGLOBALOp.GLOBAL_LOAD_B96: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA[31 : 0] = MEM[addr].b32;\nVDATA[63 : 32] = MEM[addr + 4U].b32;\nVDATA[95 : 64] = MEM[addr + 8U].b32',
  VGLOBALOp.GLOBAL_LOAD_B128: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA[31 : 0] = MEM[addr].b32;\nVDATA[63 : 32] = MEM[addr + 4U].b32;\nVDATA[95 : 64] = MEM[addr + 8U].b32;\nVDATA[127 : 96] = MEM[addr + 12U].b32',
  VGLOBALOp.GLOBAL_STORE_B8: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nMEM[addr].b8 = VDATA[7 : 0]',
  VGLOBALOp.GLOBAL_STORE_B16: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nMEM[addr].b16 = VDATA[15 : 0]',
  VGLOBALOp.GLOBAL_STORE_B32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nMEM[addr].b32 = VDATA[31 : 0]',
  VGLOBALOp.GLOBAL_STORE_B64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nMEM[addr].b32 = VDATA[31 : 0];\nMEM[addr + 4U].b32 = VDATA[63 : 32]',
  VGLOBALOp.GLOBAL_STORE_B96: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nMEM[addr].b32 = VDATA[31 : 0];\nMEM[addr + 4U].b32 = VDATA[63 : 32];\nMEM[addr + 8U].b32 = VDATA[95 : 64]',
  VGLOBALOp.GLOBAL_STORE_B128: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nMEM[addr].b32 = VDATA[31 : 0];\nMEM[addr + 4U].b32 = VDATA[63 : 32];\nMEM[addr + 8U].b32 = VDATA[95 : 64];\nMEM[addr + 12U].b32 = VDATA[127 : 96]',
  VGLOBALOp.GLOBAL_LOAD_D16_U8: "addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA[15 : 0].u16 = 16'U({ 8'0U, MEM[addr].u8 });\n// VDATA[31:16] is preserved.",
  VGLOBALOp.GLOBAL_LOAD_D16_I8: "addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA[15 : 0].i16 = 16'I(signext(MEM[addr].i8));\n// VDATA[31:16] is preserved.",
  VGLOBALOp.GLOBAL_LOAD_D16_B16: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA[15 : 0].b16 = MEM[addr].b16;\n// VDATA[31:16] is preserved.',
  VGLOBALOp.GLOBAL_LOAD_D16_HI_U8: "addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA[31 : 16].u16 = 16'U({ 8'0U, MEM[addr].u8 });\n// VDATA[15:0] is preserved.",
  VGLOBALOp.GLOBAL_LOAD_D16_HI_I8: "addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA[31 : 16].i16 = 16'I(signext(MEM[addr].i8));\n// VDATA[15:0] is preserved.",
  VGLOBALOp.GLOBAL_LOAD_D16_HI_B16: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nVDATA[31 : 16].b16 = MEM[addr].b16;\n// VDATA[15:0] is preserved.',
  VGLOBALOp.GLOBAL_STORE_D16_HI_B8: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nMEM[addr].b8 = VDATA[23 : 16]',
  VGLOBALOp.GLOBAL_STORE_D16_HI_B16: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\nMEM[addr].b16 = VDATA[31 : 16]',
  VGLOBALOp.GLOBAL_LOAD_ADDTID_B32: "RETURN_DATA.u32 = MEM[SGPR_ADDR[63 : 0] + INST_OFFSET[11 : 0].b64 + 64'B(laneID.i32 * 4)].u32",
  VGLOBALOp.GLOBAL_STORE_ADDTID_B32: "MEM[SGPR_ADDR[63 : 0] + INST_OFFSET[11 : 0].b64 + 64'B(laneID.i32 * 4)].u32 = DATA.u32",
  VGLOBALOp.GLOBAL_ATOMIC_SWAP_B32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = DATA.b32;\nRETURN_DATA.b32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_CMPSWAP_B32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u32;\nsrc = DATA[31 : 0].u32;\ncmp = DATA[63 : 32].u32;\nMEM[addr].u32 = tmp == cmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_ADD_U32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u32;\nMEM[addr].u32 += DATA.u32;\nRETURN_DATA.u32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_SUB_U32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u32;\nMEM[addr].u32 -= DATA.u32;\nRETURN_DATA.u32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_SUB_CLAMP_U32: "declare new_value : 32'U;\nold_value = MEM[ADDR].u32;\nif old_value < DATA.u32 then\nnew_value = 0U\nelse\nnew_value = old_value - DATA.u32\nendif;\nMEM[ADDR].u32 = new_value;\nRETURN_DATA.u32 = old_value",
  VGLOBALOp.GLOBAL_ATOMIC_MIN_I32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].i32;\nsrc = DATA.i32;\nMEM[addr].i32 = src < tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_MIN_U32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = src < tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_MAX_I32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].i32;\nsrc = DATA.i32;\nMEM[addr].i32 = src >= tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_MAX_U32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = src >= tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_AND_B32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp & DATA.b32);\nRETURN_DATA.b32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_OR_B32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp | DATA.b32);\nRETURN_DATA.b32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_XOR_B32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp ^ DATA.b32);\nRETURN_DATA.b32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_INC_U32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_DEC_U32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_SWAP_B64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = DATA.b64;\nRETURN_DATA.b64 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_CMPSWAP_B64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u64;\nsrc = DATA[63 : 0].u64;\ncmp = DATA[127 : 64].u64;\nMEM[addr].u64 = tmp == cmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_ADD_U64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u64;\nMEM[addr].u64 += DATA.u64;\nRETURN_DATA.u64 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_SUB_U64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u64;\nMEM[addr].u64 -= DATA.u64;\nRETURN_DATA.u64 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_MIN_I64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].i64;\nsrc = DATA.i64;\nMEM[addr].i64 = src < tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_MIN_U64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = src < tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_MAX_I64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].i64;\nsrc = DATA.i64;\nMEM[addr].i64 = src >= tmp ? src : tmp;\nRETURN_DATA.i64 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_MAX_U64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = src >= tmp ? src : tmp;\nRETURN_DATA.u64 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_AND_B64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp & DATA.b64);\nRETURN_DATA.b64 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_OR_B64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp | DATA.b64);\nRETURN_DATA.b64 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_XOR_B64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].b64;\nMEM[addr].b64 = (tmp ^ DATA.b64);\nRETURN_DATA.b64 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_INC_U64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = tmp >= src ? 0ULL : tmp + 1ULL;\nRETURN_DATA.u64 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_DEC_U64: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u64;\nsrc = DATA.u64;\nMEM[addr].u64 = ((tmp == 0ULL) || (tmp > src)) ? src : tmp - 1ULL;\nRETURN_DATA.u64 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_COND_SUB_U32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[ADDR].u32 = tmp >= src ? tmp - src : tmp;\nRETURN_DATA.u32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_MIN_NUM_F32: "tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nif (isNAN(64'F(src.f32)) && isNAN(64'F(tmp.f32))) then\nMEM[ADDR].f32 = 32'F(cvtToQuietNAN(64'F(src.f32)))\nelsif isNAN(64'F(src.f32)) then\nMEM[ADDR].f32 = tmp.f32\nelsif isNAN(64'F(tmp.f32)) then\nMEM[ADDR].f32 = src.f32\nelsif ((src.f32 < tmp.f32) || ((abs(src.f32) == 0.0F) && (abs(tmp.f32) == 0.0F) && sign(src.f32) &&\n!sign(tmp.f32))) then\n// NOTE: -0<+0 is TRUE in this comparison\nMEM[ADDR].f32 = src.f32\nelse\nMEM[ADDR].f32 = tmp.f32\nendif;\nRETURN_DATA.f32 = tmp",
  VGLOBALOp.GLOBAL_ATOMIC_MAX_NUM_F32: "tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nif (isNAN(64'F(src.f32)) && isNAN(64'F(tmp.f32))) then\nMEM[ADDR].f32 = 32'F(cvtToQuietNAN(64'F(src.f32)))\nelsif isNAN(64'F(src.f32)) then\nMEM[ADDR].f32 = tmp.f32\nelsif isNAN(64'F(tmp.f32)) then\nMEM[ADDR].f32 = src.f32\nelsif ((src.f32 > tmp.f32) || ((abs(src.f32) == 0.0F) && (abs(tmp.f32) == 0.0F) && !sign(src.f32) &&\nsign(tmp.f32))) then\n// NOTE: +0>-0 is TRUE in this comparison\nMEM[ADDR].f32 = src.f32\nelse\nMEM[ADDR].f32 = tmp.f32\nendif;\nRETURN_DATA.f32 = tmp",
  VGLOBALOp.GLOBAL_LOAD_BLOCK: 'for i in 0 : 31 do\n// Algorithm can skip over "holes" both in the memory block and VGPR block.\nif M0[i].u1 then\nVGPR[laneId][VDST.u32 + i.u32] = MEM[VGPR[laneId][ADDR].i32 + i * 4].b32\nendif\nendfor',
  VGLOBALOp.GLOBAL_STORE_BLOCK: 'for i in 0 : 31 do\n// Algorithm can skip over "holes" both in the memory block and VGPR block.\nif M0[i].u1 then\nMEM[VGPR[laneId][ADDR].i32 + i * 4] = VGPR[laneId][VDATA.u32 + i.u32].b32\nendif\nendfor',
  VGLOBALOp.GLOBAL_ATOMIC_ADD_F32: 'addr = CalcGlobalAddr(v_addr.b64, s_saddr.b64);\ntmp = MEM[addr].f32;\nMEM[addr].f32 += DATA.f32;\nRETURN_DATA.f32 = tmp',
  VGLOBALOp.GLOBAL_ATOMIC_PK_ADD_F16: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ndst[15 : 0].f16 = src[15 : 0].f16 + tmp[15 : 0].f16;\ndst[31 : 16].f16 = src[31 : 16].f16 + tmp[31 : 16].f16;\nMEM[ADDR].b32 = dst.b32;\nRETURN_DATA.b32 = tmp.b32',
  VGLOBALOp.GLOBAL_ATOMIC_PK_ADD_BF16: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ndst[15 : 0].bf16 = src[15 : 0].bf16 + tmp[15 : 0].bf16;\ndst[31 : 16].bf16 = src[31 : 16].bf16 + tmp[31 : 16].bf16;\nMEM[ADDR].b32 = dst.b32;\nRETURN_DATA.b32 = tmp.b32',
  VGLOBALOp.GLOBAL_ATOMIC_ORDERED_ADD_B64: "shader_id = DATA[31 : 0];\nshader_offset = DATA[63 : 32];\nold_mem_id = MEM[ADDR].b32;\nold_mem_value = MEM[ADDR + 4U].b32;\nif old_mem_id == shader_id then\nMEM[ADDR].b32 = 32'B((old_mem_id.i32 + 1) & VGT_GS_MAX_WAVE_ID.i32);\n// increment the ordered ID in memory\nMEM[ADDR + 4U].b32 = old_mem_value + shader_offset;\n// add the streamout offset\nendif;\nRETURN_DATA[31 : 0].b32 = old_mem_id;\nRETURN_DATA[63 : 32].b32 = old_mem_value",
  VIMAGEOp.IMAGE_ATOMIC_SWAP: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = DATA.b32;\nRETURN_DATA.b32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_CMPSWAP: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].u32;\nsrc = DATA[31 : 0].u32;\ncmp = DATA[63 : 32].u32;\nMEM[addr].u32 = tmp == cmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_ADD_UINT: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].u32;\nMEM[addr].u32 += DATA.u32;\nRETURN_DATA.u32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_SUB_UINT: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].u32;\nMEM[addr].u32 -= DATA.u32;\nRETURN_DATA.u32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_MIN_INT: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].i32;\nsrc = DATA.i32;\nMEM[addr].i32 = src < tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_MIN_UINT: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = src < tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_MAX_INT: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].i32;\nsrc = DATA.i32;\nMEM[addr].i32 = src >= tmp ? src : tmp;\nRETURN_DATA.i32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_MAX_UINT: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = src >= tmp ? src : tmp;\nRETURN_DATA.u32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_AND: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp & DATA.b32);\nRETURN_DATA.b32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_OR: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp | DATA.b32);\nRETURN_DATA.b32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_XOR: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].b32;\nMEM[addr].b32 = (tmp ^ DATA.b32);\nRETURN_DATA.b32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_INC_UINT: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = tmp >= src ? 0U : tmp + 1U;\nRETURN_DATA.u32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_DEC_UINT: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].u32;\nsrc = DATA.u32;\nMEM[addr].u32 = ((tmp == 0U) || (tmp > src)) ? src : tmp - 1U;\nRETURN_DATA.u32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_ADD_FLT: 'addr = CalcImageAddr(v_addr.b128);\ntmp = MEM[addr].f32;\nMEM[addr].f32 += DATA.f32;\nRETURN_DATA.f32 = tmp',
  VIMAGEOp.IMAGE_ATOMIC_MIN_FLT: "tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nif (isNAN(64'F(src.f32)) && isNAN(64'F(tmp.f32))) then\nMEM[ADDR].f32 = 32'F(cvtToQuietNAN(64'F(src.f32)))\nelsif isNAN(64'F(src.f32)) then\nMEM[ADDR].f32 = tmp.f32\nelsif isNAN(64'F(tmp.f32)) then\nMEM[ADDR].f32 = src.f32\nelsif ((src.f32 < tmp.f32) || ((abs(src.f32) == 0.0F) && (abs(tmp.f32) == 0.0F) && sign(src.f32) &&\n!sign(tmp.f32))) then\n// NOTE: -0<+0 is TRUE in this comparison\nMEM[ADDR].f32 = src.f32\nelse\nMEM[ADDR].f32 = tmp.f32\nendif;\nRETURN_DATA.f32 = tmp",
  VIMAGEOp.IMAGE_ATOMIC_MAX_FLT: "tmp = MEM[ADDR].f32;\nsrc = DATA.f32;\nif (isNAN(64'F(src.f32)) && isNAN(64'F(tmp.f32))) then\nMEM[ADDR].f32 = 32'F(cvtToQuietNAN(64'F(src.f32)))\nelsif isNAN(64'F(src.f32)) then\nMEM[ADDR].f32 = tmp.f32\nelsif isNAN(64'F(tmp.f32)) then\nMEM[ADDR].f32 = src.f32\nelsif ((src.f32 > tmp.f32) || ((abs(src.f32) == 0.0F) && (abs(tmp.f32) == 0.0F) && !sign(src.f32) &&\nsign(tmp.f32))) then\n// NOTE: +0>-0 is TRUE in this comparison\nMEM[ADDR].f32 = src.f32\nelse\nMEM[ADDR].f32 = tmp.f32\nendif;\nRETURN_DATA.f32 = tmp",
  VIMAGEOp.IMAGE_ATOMIC_PK_ADD_F16: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ndst[15 : 0].f16 = src[15 : 0].f16 + tmp[15 : 0].f16;\ndst[31 : 16].f16 = src[31 : 16].f16 + tmp[31 : 16].f16;\nMEM[ADDR].b32 = dst.b32;\nRETURN_DATA.b32 = tmp.b32',
  VIMAGEOp.IMAGE_ATOMIC_PK_ADD_BF16: 'tmp = MEM[ADDR].b32;\nsrc = DATA.b32;\ndst[15 : 0].bf16 = src[15 : 0].bf16 + tmp[15 : 0].bf16;\ndst[31 : 16].bf16 = src[31 : 16].bf16 + tmp[31 : 16].bf16;\nMEM[ADDR].b32 = dst.b32;\nRETURN_DATA.b32 = tmp.b32',
  VINTERPOp.V_INTERP_P10_F32: 'D0.f32 = fma(VGPR[(laneId.u32 & 0xfffffffcU) + 1U][SRC0.u32].f32, S1.f32, VGPR[laneId.u32 &\n0xfffffffcU][SRC2.u32].f32)',
  VINTERPOp.V_INTERP_P2_F32: 'D0.f32 = fma(VGPR[(laneId.u32 & 0xfffffffcU) + 2U][SRC0.u32].f32, S1.f32, S2.f32)',
  VINTERPOp.V_INTERP_P10_F16_F32: "D0.f32 = fma(32'F(VGPR[(laneId.u32 & 0xfffffffcU) + 1U][SRC0.u32].f16), S1.f32, 32'F(VGPR[laneId.u32 &\n0xfffffffcU][SRC2.u32].f16))",
  VINTERPOp.V_INTERP_P2_F16_F32: "D0.f16 = 16'F(fma(32'F(VGPR[(laneId.u32 & 0xfffffffcU) + 2U][SRC0.u32].f16), S1.f32, S2.f32))",
  VINTERPOp.V_INTERP_P10_RTZ_F16_F32: "D0.f32 = fma(32'F(VGPR[(laneId.u32 & 0xfffffffcU) + 1U][SRC0.u32].f16), S1.f32, 32'F(VGPR[laneId.u32 &\n0xfffffffcU][SRC2.u32].f16))",
  VINTERPOp.V_INTERP_P2_RTZ_F16_F32: "D0.f32 = fma(32'F(VGPR[(laneId.u32 & 0xfffffffcU) + 2U][SRC0.u32].f16), S1.f32, S2.f32)",
  VOP1Op.V_MOV_B32_E32: 'D0.b32 = S0.b32',
  VOP1Op.V_READFIRSTLANE_B32_E32: "declare lane : 32'U;\nif WAVE64 then\n// 64 lanes\nif EXEC == 0x0LL then\nlane = 0U;\n// Force lane 0 if all lanes are disabled\nelse\nlane = 32'U(s_ff1_i32_b64(EXEC));\n// Lowest active lane\nendif\nelse\n// 32 lanes\nif EXEC_LO.i32 == 0 then\nlane = 0U;\n// Force lane 0 if all lanes are disabled\nelse\nlane = 32'U(s_ff1_i32_b32(EXEC_LO));\n// Lowest active lane\nendif\nendif;\nD0.b32 = VGPR[lane][SRC0.u32]",
  VOP1Op.V_CVT_I32_F64_E32: 'D0.i32 = f64_to_i32(S0.f64)',
  VOP1Op.V_CVT_F64_I32_E32: 'D0.f64 = i32_to_f64(S0.i32)',
  VOP1Op.V_CVT_F32_I32_E32: 'D0.f32 = i32_to_f32(S0.i32)',
  VOP1Op.V_CVT_F32_U32_E32: 'D0.f32 = u32_to_f32(S0.u32)',
  VOP1Op.V_CVT_U32_F32_E32: 'D0.u32 = f32_to_u32(S0.f32)',
  VOP1Op.V_CVT_I32_F32_E32: 'D0.i32 = f32_to_i32(S0.f32)',
  VOP1Op.V_CVT_F16_F32_E32: 'D0.f16 = f32_to_f16(S0.f32)',
  VOP1Op.V_CVT_F32_F16_E32: 'D0.f32 = f16_to_f32(S0.f16)',
  VOP1Op.V_CVT_NEAREST_I32_F32_E32: 'D0.i32 = f32_to_i32(floor(S0.f32 + 0.5F))',
  VOP1Op.V_CVT_FLOOR_I32_F32_E32: 'D0.i32 = f32_to_i32(floor(S0.f32))',
  VOP1Op.V_CVT_OFF_F32_I4_E32: "declare CVT_OFF_TABLE : 32'F[16];\nD0.f32 = CVT_OFF_TABLE[S0.u32[3 : 0]]",
  VOP1Op.V_CVT_F32_F64_E32: 'D0.f32 = f64_to_f32(S0.f64)',
  VOP1Op.V_CVT_F64_F32_E32: 'D0.f64 = f32_to_f64(S0.f32)',
  VOP1Op.V_CVT_F32_UBYTE0_E32: 'D0.f32 = u32_to_f32(S0[7 : 0].u32)',
  VOP1Op.V_CVT_F32_UBYTE1_E32: 'D0.f32 = u32_to_f32(S0[15 : 8].u32)',
  VOP1Op.V_CVT_F32_UBYTE2_E32: 'D0.f32 = u32_to_f32(S0[23 : 16].u32)',
  VOP1Op.V_CVT_F32_UBYTE3_E32: 'D0.f32 = u32_to_f32(S0[31 : 24].u32)',
  VOP1Op.V_CVT_U32_F64_E32: 'D0.u32 = f64_to_u32(S0.f64)',
  VOP1Op.V_CVT_F64_U32_E32: 'D0.f64 = u32_to_f64(S0.u32)',
  VOP1Op.V_TRUNC_F64_E32: 'D0.f64 = trunc(S0.f64)',
  VOP1Op.V_CEIL_F64_E32: 'D0.f64 = trunc(S0.f64);\nif ((S0.f64 > 0.0) && (S0.f64 != D0.f64)) then\nD0.f64 += 1.0\nendif',
  VOP1Op.V_RNDNE_F64_E32: 'D0.f64 = floor(S0.f64 + 0.5);\nif (isEven(floor(S0.f64)) && (fract(S0.f64) == 0.5)) then\nD0.f64 -= 1.0\nendif',
  VOP1Op.V_FLOOR_F64_E32: 'D0.f64 = trunc(S0.f64);\nif ((S0.f64 < 0.0) && (S0.f64 != D0.f64)) then\nD0.f64 += -1.0\nendif',
  VOP1Op.V_MOV_B16_E32: 'D0.b16 = S0.b16',
  VOP1Op.V_FRACT_F32_E32: 'D0.f32 = S0.f32 + -floor(S0.f32)',
  VOP1Op.V_TRUNC_F32_E32: 'D0.f32 = trunc(S0.f32)',
  VOP1Op.V_CEIL_F32_E32: 'D0.f32 = trunc(S0.f32);\nif ((S0.f32 > 0.0F) && (S0.f32 != D0.f32)) then\nD0.f32 += 1.0F\nendif',
  VOP1Op.V_RNDNE_F32_E32: "D0.f32 = floor(S0.f32 + 0.5F);\nif (isEven(64'F(floor(S0.f32))) && (fract(S0.f32) == 0.5F)) then\nD0.f32 -= 1.0F\nendif",
  VOP1Op.V_FLOOR_F32_E32: 'D0.f32 = trunc(S0.f32);\nif ((S0.f32 < 0.0F) && (S0.f32 != D0.f32)) then\nD0.f32 += -1.0F\nendif',
  VOP1Op.V_EXP_F32_E32: 'D0.f32 = pow(2.0F, S0.f32)',
  VOP1Op.V_LOG_F32_E32: 'D0.f32 = log2(S0.f32)',
  VOP1Op.V_RCP_F32_E32: 'D0.f32 = 1.0F / S0.f32',
  VOP1Op.V_RCP_IFLAG_F32_E32: 'D0.f32 = 1.0F / S0.f32;\n// Can only raise integer DIV_BY_ZERO exception',
  VOP1Op.V_RSQ_F32_E32: 'D0.f32 = 1.0F / sqrt(S0.f32)',
  VOP1Op.V_RCP_F64_E32: 'D0.f64 = 1.0 / S0.f64',
  VOP1Op.V_RSQ_F64_E32: 'D0.f64 = 1.0 / sqrt(S0.f64)',
  VOP1Op.V_SQRT_F32_E32: 'D0.f32 = sqrt(S0.f32)',
  VOP1Op.V_SQRT_F64_E32: 'D0.f64 = sqrt(S0.f64)',
  VOP1Op.V_SIN_F32_E32: "D0.f32 = sin(S0.f32 * 32'F(PI * 2.0))",
  VOP1Op.V_COS_F32_E32: "D0.f32 = cos(S0.f32 * 32'F(PI * 2.0))",
  VOP1Op.V_NOT_B32_E32: 'D0.u32 = ~S0.u32',
  VOP1Op.V_BFREV_B32_E32: 'D0.u32[31 : 0] = S0.u32[0 : 31]',
  VOP1Op.V_CLZ_I32_U32_E32: "D0.i32 = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\n// Search from MSB\nif S0.u32[31 - i] == 1'1U then\nD0.i32 = i;\nbreak\nendif\nendfor",
  VOP1Op.V_CTZ_I32_B32_E32: "D0.i32 = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\n// Search from LSB\nif S0.u32[i] == 1'1U then\nD0.i32 = i;\nbreak\nendif\nendfor",
  VOP1Op.V_CLS_I32_E32: 'D0.i32 = -1;\n// Set if all bits are the same\nfor i in 1 : 31 do\n// Search from MSB\nif S0.i32[31 - i] != S0.i32[31] then\nD0.i32 = i;\nbreak\nendif\nendfor',
  VOP1Op.V_FREXP_EXP_I32_F64_E32: 'if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then\nD0.i32 = 0\nelse\nD0.i32 = exponent(S0.f64) - 1023 + 1\nendif',
  VOP1Op.V_FREXP_MANT_F64_E32: 'if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then\nD0.f64 = S0.f64\nelse\nD0.f64 = mantissa(S0.f64)\nendif',
  VOP1Op.V_FRACT_F64_E32: 'D0.f64 = S0.f64 + -floor(S0.f64)',
  VOP1Op.V_FREXP_EXP_I32_F32_E32: "if ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then\nD0.i32 = 0\nelse\nD0.i32 = exponent(S0.f32) - 127 + 1\nendif",
  VOP1Op.V_FREXP_MANT_F32_E32: "if ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then\nD0.f32 = S0.f32\nelse\nD0.f32 = mantissa(S0.f32)\nendif",
  VOP1Op.V_MOVRELD_B32_E32: 'addr = DST.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nVGPR[laneId][addr].b32 = S0.b32',
  VOP1Op.V_MOVRELS_B32_E32: 'addr = SRC0.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nD0.b32 = VGPR[laneId][addr].b32',
  VOP1Op.V_MOVRELSD_B32_E32: 'addrs = SRC0.u32;\n// Raw value from instruction\naddrd = DST.u32;\n// Raw value from instruction\naddrs += M0.u32[31 : 0];\naddrd += M0.u32[31 : 0];\nVGPR[laneId][addrd].b32 = VGPR[laneId][addrs].b32',
  VOP1Op.V_MOVRELSD_2_B32_E32: 'addrs = SRC0.u32;\n// Raw value from instruction\naddrd = DST.u32;\n// Raw value from instruction\naddrs += M0.u32[9 : 0].u32;\naddrd += M0.u32[25 : 16].u32;\nVGPR[laneId][addrd].b32 = VGPR[laneId][addrs].b32',
  VOP1Op.V_CVT_F16_U16_E32: 'D0.f16 = u16_to_f16(S0.u16)',
  VOP1Op.V_CVT_F16_I16_E32: 'D0.f16 = i16_to_f16(S0.i16)',
  VOP1Op.V_CVT_U16_F16_E32: 'D0.u16 = f16_to_u16(S0.f16)',
  VOP1Op.V_CVT_I16_F16_E32: 'D0.i16 = f16_to_i16(S0.f16)',
  VOP1Op.V_RCP_F16_E32: "D0.f16 = 16'1.0 / S0.f16",
  VOP1Op.V_SQRT_F16_E32: 'D0.f16 = sqrt(S0.f16)',
  VOP1Op.V_RSQ_F16_E32: "D0.f16 = 16'1.0 / sqrt(S0.f16)",
  VOP1Op.V_LOG_F16_E32: 'D0.f16 = log2(S0.f16)',
  VOP1Op.V_EXP_F16_E32: "D0.f16 = pow(16'2.0, S0.f16)",
  VOP1Op.V_FREXP_MANT_F16_E32: "if ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then\nD0.f16 = S0.f16\nelse\nD0.f16 = mantissa(S0.f16)\nendif",
  VOP1Op.V_FREXP_EXP_I16_F16_E32: "if ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then\nD0.i16 = 16'0\nelse\nD0.i16 = 16'I(exponent(S0.f16) - 15 + 1)\nendif",
  VOP1Op.V_FLOOR_F16_E32: "D0.f16 = trunc(S0.f16);\nif ((S0.f16 < 16'0.0) && (S0.f16 != D0.f16)) then\nD0.f16 += -16'1.0\nendif",
  VOP1Op.V_CEIL_F16_E32: "D0.f16 = trunc(S0.f16);\nif ((S0.f16 > 16'0.0) && (S0.f16 != D0.f16)) then\nD0.f16 += 16'1.0\nendif",
  VOP1Op.V_TRUNC_F16_E32: 'D0.f16 = trunc(S0.f16)',
  VOP1Op.V_RNDNE_F16_E32: "D0.f16 = floor(S0.f16 + 16'0.5);\nif (isEven(64'F(floor(S0.f16))) && (fract(S0.f16) == 16'0.5)) then\nD0.f16 -= 16'1.0\nendif",
  VOP1Op.V_FRACT_F16_E32: 'D0.f16 = S0.f16 + -floor(S0.f16)',
  VOP1Op.V_SIN_F16_E32: "D0.f16 = sin(S0.f16 * 16'F(PI * 2.0))",
  VOP1Op.V_COS_F16_E32: "D0.f16 = cos(S0.f16 * 16'F(PI * 2.0))",
  VOP1Op.V_SAT_PK_U8_I16_E32: "SAT8 = lambda(n) (\nif n <= 16'0 then\nreturn 8'0U\nelsif n >= 16'255 then\nreturn 8'255U\nelse\nreturn n[7 : 0].u8\nendif);\ntmp = 16'0;\ntmp[7 : 0].u8 = SAT8(S0[15 : 0].i16);\ntmp[15 : 8].u8 = SAT8(S0[31 : 16].i16);\nD0.b16 = tmp.b16",
  VOP1Op.V_CVT_NORM_I16_F16_E32: 'D0.i16 = f16_to_snorm(S0.f16)',
  VOP1Op.V_CVT_NORM_U16_F16_E32: 'D0.u16 = f16_to_unorm(S0.f16)',
  VOP1Op.V_SWAP_B32_E32: 'tmp = D0.b32;\nD0.b32 = S0.b32;\nS0.b32 = tmp',
  VOP1Op.V_SWAP_B16_E32: 'tmp = D0.b16;\nD0.b16 = S0.b16;\nS0.b16 = tmp',
  VOP1Op.V_PERMLANE64_B32_E32: "declare tmp : 32'B[64];\ndeclare lane : 32'U;\nif WAVE32 then\n// Supported in wave64 ONLY; treated as scalar NOP in wave32\ns_nop(16'0U)\nelse\nfor lane in 0U : 63U do\n// Copy original S0 in case D==S0\ntmp[lane] = VGPR[lane][SRC0.u32]\nendfor;\nfor lane in 0U : 63U do\naltlane = { ~lane[5], lane[4 : 0] };\n// 0<->32, ..., 31<->63\nif EXEC[lane].u1 then\nVGPR[lane][VDST.u32] = tmp[altlane]\nendif\nendfor\nendif",
  VOP1Op.V_SWAPREL_B32_E32: 'addrs = SRC0.u32;\n// Raw value from instruction\naddrd = DST.u32;\n// Raw value from instruction\naddrs += M0.u32[9 : 0].u32;\naddrd += M0.u32[25 : 16].u32;\ntmp = VGPR[laneId][addrd].b32;\nVGPR[laneId][addrd].b32 = VGPR[laneId][addrs].b32;\nVGPR[laneId][addrs].b32 = tmp',
  VOP1Op.V_NOT_B16_E32: 'D0.u16 = ~S0.u16',
  VOP1Op.V_CVT_I32_I16_E32: "D0.i32 = 32'I(signext(S0.i16))",
  VOP1Op.V_CVT_U32_U16_E32: "D0 = { 16'0, S0.u16 }",
  VOP1Op.V_CVT_F32_FP8_E32: "if OPSEL[1 : 0].u2 == 2'0U then\nD0.f32 = fp8_to_f32(VGPR[laneId][SRC0.u32][7 : 0].fp8)\nelsif OPSEL[1 : 0].u2 == 2'2U then\n// Byte select bits are reversed\nD0.f32 = fp8_to_f32(VGPR[laneId][SRC0.u32][15 : 8].fp8)\nelsif OPSEL[1 : 0].u2 == 2'1U then\nD0.f32 = fp8_to_f32(VGPR[laneId][SRC0.u32][23 : 16].fp8)\nelse\nD0.f32 = fp8_to_f32(VGPR[laneId][SRC0.u32][31 : 24].fp8)\nendif",
  VOP1Op.V_CVT_F32_BF8_E32: "if OPSEL[1 : 0].u2 == 2'0U then\nD0.f32 = bf8_to_f32(VGPR[laneId][SRC0.u32][7 : 0].bf8)\nelsif OPSEL[1 : 0].u2 == 2'2U then\n// Byte select bits are reversed\nD0.f32 = bf8_to_f32(VGPR[laneId][SRC0.u32][15 : 8].bf8)\nelsif OPSEL[1 : 0].u2 == 2'1U then\nD0.f32 = bf8_to_f32(VGPR[laneId][SRC0.u32][23 : 16].bf8)\nelse\nD0.f32 = bf8_to_f32(VGPR[laneId][SRC0.u32][31 : 24].bf8)\nendif",
  VOP1Op.V_CVT_PK_F32_FP8_E32: 'tmp = OPSEL[0].u1 ? VGPR[laneId][SRC0.u32][31 : 16] : VGPR[laneId][SRC0.u32][15 : 0];\nD0[31 : 0].f32 = fp8_to_f32(tmp[7 : 0].fp8);\nD0[63 : 32].f32 = fp8_to_f32(tmp[15 : 8].fp8)',
  VOP1Op.V_CVT_PK_F32_BF8_E32: 'tmp = OPSEL[0].u1 ? VGPR[laneId][SRC0.u32][31 : 16] : VGPR[laneId][SRC0.u32][15 : 0];\nD0[31 : 0].f32 = bf8_to_f32(tmp[7 : 0].bf8);\nD0[63 : 32].f32 = bf8_to_f32(tmp[15 : 8].bf8)',
  VOP2Op.V_CNDMASK_B32_E32: 'D0.u32 = VCC.u64[laneId] ? S1.u32 : S0.u32',
  VOP2Op.V_ADD_F64_E32: 'D0.f64 = S0.f64 + S1.f64',
  VOP2Op.V_ADD_F32_E32: 'D0.f32 = S0.f32 + S1.f32',
  VOP2Op.V_SUB_F32_E32: 'D0.f32 = S0.f32 - S1.f32',
  VOP2Op.V_SUBREV_F32_E32: 'D0.f32 = S1.f32 - S0.f32',
  VOP2Op.V_MUL_F64_E32: 'D0.f64 = S0.f64 * S1.f64',
  VOP2Op.V_MUL_DX9_ZERO_F32_E32: "if ((64'F(S0.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then\n// DX9 rules, 0.0 * x = 0.0\nD0.f32 = 0.0F\nelse\nD0.f32 = S0.f32 * S1.f32\nendif",
  VOP2Op.V_MUL_F32_E32: 'D0.f32 = S0.f32 * S1.f32',
  VOP2Op.V_MUL_I32_I24_E32: "D0.i32 = 32'I(S0.i24) * 32'I(S1.i24)",
  VOP2Op.V_MUL_HI_I32_I24_E32: "D0.i32 = 32'I((64'I(S0.i24) * 64'I(S1.i24)) >> 32U)",
  VOP2Op.V_MUL_U32_U24_E32: "D0.u32 = 32'U(S0.u24) * 32'U(S1.u24)",
  VOP2Op.V_MUL_HI_U32_U24_E32: "D0.u32 = 32'U((64'U(S0.u24) * 64'U(S1.u24)) >> 32U)",
  VOP2Op.V_MIN_NUM_F64_E32: 'if (isSignalNAN(S0.f64) || isSignalNAN(S1.f64)) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(S0.f64) && isNAN(S1.f64)) then\nD0.f64 = cvtToQuietNAN(S0.f64)\nelsif isNAN(S0.f64) then\nD0.f64 = S1.f64\nelsif isNAN(S1.f64) then\nD0.f64 = S0.f64\nelsif ((S0.f64 < S1.f64) || ((abs(S0.f64) == 0.0) && (abs(S1.f64) == 0.0) && sign(S0.f64) &&\n!sign(S1.f64))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f64 = S0.f64\nelse\nD0.f64 = S1.f64\nendif',
  VOP2Op.V_MAX_NUM_F64_E32: 'if (isSignalNAN(S0.f64) || isSignalNAN(S1.f64)) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(S0.f64) && isNAN(S1.f64)) then\nD0.f64 = cvtToQuietNAN(S0.f64)\nelsif isNAN(S0.f64) then\nD0.f64 = S1.f64\nelsif isNAN(S1.f64) then\nD0.f64 = S0.f64\nelsif ((S0.f64 > S1.f64) || ((abs(S0.f64) == 0.0) && (abs(S1.f64) == 0.0) && !sign(S0.f64) &&\nsign(S1.f64))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f64 = S0.f64\nelse\nD0.f64 = S1.f64\nendif',
  VOP2Op.V_MIN_I32_E32: 'D0.i32 = S0.i32 < S1.i32 ? S0.i32 : S1.i32',
  VOP2Op.V_MAX_I32_E32: 'D0.i32 = S0.i32 >= S1.i32 ? S0.i32 : S1.i32',
  VOP2Op.V_MIN_U32_E32: 'D0.u32 = S0.u32 < S1.u32 ? S0.u32 : S1.u32',
  VOP2Op.V_MAX_U32_E32: 'D0.u32 = S0.u32 >= S1.u32 ? S0.u32 : S1.u32',
  VOP2Op.V_MIN_NUM_F32_E32: "if (isSignalNAN(64'F(S0.f32)) || isSignalNAN(64'F(S1.f32))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f32)) && isNAN(64'F(S1.f32))) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nelsif isNAN(64'F(S0.f32)) then\nD0.f32 = S1.f32\nelsif isNAN(64'F(S1.f32)) then\nD0.f32 = S0.f32\nelsif ((S0.f32 < S1.f32) || ((abs(S0.f32) == 0.0F) && (abs(S1.f32) == 0.0F) && sign(S0.f32) &&\n!sign(S1.f32))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f32 = S0.f32\nelse\nD0.f32 = S1.f32\nendif",
  VOP2Op.V_MAX_NUM_F32_E32: "if (isSignalNAN(64'F(S0.f32)) || isSignalNAN(64'F(S1.f32))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f32)) && isNAN(64'F(S1.f32))) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nelsif isNAN(64'F(S0.f32)) then\nD0.f32 = S1.f32\nelsif isNAN(64'F(S1.f32)) then\nD0.f32 = S0.f32\nelsif ((S0.f32 > S1.f32) || ((abs(S0.f32) == 0.0F) && (abs(S1.f32) == 0.0F) && !sign(S0.f32) &&\nsign(S1.f32))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f32 = S0.f32\nelse\nD0.f32 = S1.f32\nendif",
  VOP2Op.V_LSHLREV_B32_E32: 'D0.u32 = (S1.u32 << S0[4 : 0].u32)',
  VOP2Op.V_LSHRREV_B32_E32: 'D0.u32 = (S1.u32 >> S0[4 : 0].u32)',
  VOP2Op.V_ASHRREV_I32_E32: 'D0.i32 = (S1.i32 >> S0[4 : 0].u32)',
  VOP2Op.V_AND_B32_E32: 'D0.u32 = (S0.u32 & S1.u32)',
  VOP2Op.V_OR_B32_E32: 'D0.u32 = (S0.u32 | S1.u32)',
  VOP2Op.V_XOR_B32_E32: 'D0.u32 = (S0.u32 ^ S1.u32)',
  VOP2Op.V_XNOR_B32_E32: 'D0.u32 = ~(S0.u32 ^ S1.u32)',
  VOP2Op.V_LSHLREV_B64_E32: 'D0.u64 = (S1.u64 << S0[5 : 0].u32)',
  VOP2Op.V_ADD_CO_CI_U32_E32: "tmp = 64'U(S0.u32) + 64'U(S1.u32) + VCC.u64[laneId].u64;\nVCC.u64[laneId] = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_ADD_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP2Op.V_SUB_CO_CI_U32_E32: "tmp = S0.u32 - S1.u32 - VCC.u64[laneId].u32;\nVCC.u64[laneId] = 64'U(S1.u32) + VCC.u64[laneId].u64 > 64'U(S0.u32) ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP2Op.V_SUBREV_CO_CI_U32_E32: "tmp = S1.u32 - S0.u32 - VCC.u64[laneId].u32;\nVCC.u64[laneId] = 64'U(S0.u32) + VCC.u64[laneId].u64 > 64'U(S1.u32) ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP2Op.V_ADD_NC_U32_E32: 'D0.u32 = S0.u32 + S1.u32',
  VOP2Op.V_SUB_NC_U32_E32: 'D0.u32 = S0.u32 - S1.u32',
  VOP2Op.V_SUBREV_NC_U32_E32: 'D0.u32 = S1.u32 - S0.u32',
  VOP2Op.V_FMAC_F32_E32: 'D0.f32 = fma(S0.f32, S1.f32, D0.f32)',
  VOP2Op.V_FMAMK_F32_E32: 'D0.f32 = fma(S0.f32, SIMM32.f32, S1.f32)',
  VOP2Op.V_FMAAK_F32_E32: 'D0.f32 = fma(S0.f32, S1.f32, SIMM32.f32)',
  VOP2Op.V_CVT_PK_RTZ_F16_F32_E32: 'prev_mode = ROUND_MODE;\nROUND_MODE = ROUND_TOWARD_ZERO;\ntmp[15 : 0].f16 = f32_to_f16(S0.f32);\ntmp[31 : 16].f16 = f32_to_f16(S1.f32);\nD0 = tmp.b32;\nROUND_MODE = prev_mode;\n// Round-toward-zero regardless of current round mode setting in hardware.',
  VOP2Op.V_MIN_NUM_F16_E32: "if (isSignalNAN(64'F(S0.f16)) || isSignalNAN(64'F(S1.f16))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f16)) && isNAN(64'F(S1.f16))) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nelsif isNAN(64'F(S0.f16)) then\nD0.f16 = S1.f16\nelsif isNAN(64'F(S1.f16)) then\nD0.f16 = S0.f16\nelsif ((S0.f16 < S1.f16) || ((abs(S0.f16) == 16'0.0) && (abs(S1.f16) == 16'0.0) && sign(S0.f16) &&\n!sign(S1.f16))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif",
  VOP2Op.V_MAX_NUM_F16_E32: "if (isSignalNAN(64'F(S0.f16)) || isSignalNAN(64'F(S1.f16))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f16)) && isNAN(64'F(S1.f16))) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nelsif isNAN(64'F(S0.f16)) then\nD0.f16 = S1.f16\nelsif isNAN(64'F(S1.f16)) then\nD0.f16 = S0.f16\nelsif ((S0.f16 > S1.f16) || ((abs(S0.f16) == 16'0.0) && (abs(S1.f16) == 16'0.0) && !sign(S0.f16) &&\nsign(S1.f16))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif",
  VOP2Op.V_ADD_F16_E32: 'D0.f16 = S0.f16 + S1.f16',
  VOP2Op.V_SUB_F16_E32: 'D0.f16 = S0.f16 - S1.f16',
  VOP2Op.V_SUBREV_F16_E32: 'D0.f16 = S1.f16 - S0.f16',
  VOP2Op.V_MUL_F16_E32: 'D0.f16 = S0.f16 * S1.f16',
  VOP2Op.V_FMAC_F16_E32: 'D0.f16 = fma(S0.f16, S1.f16, D0.f16)',
  VOP2Op.V_FMAMK_F16_E32: 'D0.f16 = fma(S0.f16, SIMM32.f16, S1.f16)',
  VOP2Op.V_FMAAK_F16_E32: 'D0.f16 = fma(S0.f16, S1.f16, SIMM32.f16)',
  VOP2Op.V_LDEXP_F16_E32: "D0.f16 = S0.f16 * 16'F(2.0F ** 32'I(S1.i16))",
  VOP2Op.V_PK_FMAC_F16_E32: 'D0[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, D0[31 : 16].f16);\nD0[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, D0[15 : 0].f16)',
  VOP3Op.V_CMP_LT_F16_E64: 'D0.u64[laneId] = S0.f16 < S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_F16_E64: 'D0.u64[laneId] = S0.f16 == S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_F16_E64: 'D0.u64[laneId] = S0.f16 <= S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_F16_E64: 'D0.u64[laneId] = S0.f16 > S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LG_F16_E64: 'D0.u64[laneId] = S0.f16 <> S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_F16_E64: 'D0.u64[laneId] = S0.f16 >= S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_O_F16_E64: "D0.u64[laneId] = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)));\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_U_F16_E64: "D0.u64[laneId] = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)));\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_NGE_F16_E64: 'D0.u64[laneId] = !(S0.f16 >= S1.f16);\n// With NAN inputs this is not the same operation as <\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLG_F16_E64: 'D0.u64[laneId] = !(S0.f16 <> S1.f16);\n// With NAN inputs this is not the same operation as ==\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NGT_F16_E64: 'D0.u64[laneId] = !(S0.f16 > S1.f16);\n// With NAN inputs this is not the same operation as <=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLE_F16_E64: 'D0.u64[laneId] = !(S0.f16 <= S1.f16);\n// With NAN inputs this is not the same operation as >\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NEQ_F16_E64: 'D0.u64[laneId] = !(S0.f16 == S1.f16);\n// With NAN inputs this is not the same operation as !=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLT_F16_E64: 'D0.u64[laneId] = !(S0.f16 < S1.f16);\n// With NAN inputs this is not the same operation as >=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LT_F32_E64: 'D0.u64[laneId] = S0.f32 < S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_F32_E64: 'D0.u64[laneId] = S0.f32 == S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_F32_E64: 'D0.u64[laneId] = S0.f32 <= S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_F32_E64: 'D0.u64[laneId] = S0.f32 > S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LG_F32_E64: 'D0.u64[laneId] = S0.f32 <> S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_F32_E64: 'D0.u64[laneId] = S0.f32 >= S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_O_F32_E64: "D0.u64[laneId] = (!isNAN(64'F(S0.f32)) && !isNAN(64'F(S1.f32)));\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_U_F32_E64: "D0.u64[laneId] = (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)));\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_NGE_F32_E64: 'D0.u64[laneId] = !(S0.f32 >= S1.f32);\n// With NAN inputs this is not the same operation as <\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLG_F32_E64: 'D0.u64[laneId] = !(S0.f32 <> S1.f32);\n// With NAN inputs this is not the same operation as ==\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NGT_F32_E64: 'D0.u64[laneId] = !(S0.f32 > S1.f32);\n// With NAN inputs this is not the same operation as <=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLE_F32_E64: 'D0.u64[laneId] = !(S0.f32 <= S1.f32);\n// With NAN inputs this is not the same operation as >\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NEQ_F32_E64: 'D0.u64[laneId] = !(S0.f32 == S1.f32);\n// With NAN inputs this is not the same operation as !=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLT_F32_E64: 'D0.u64[laneId] = !(S0.f32 < S1.f32);\n// With NAN inputs this is not the same operation as >=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LT_F64_E64: 'D0.u64[laneId] = S0.f64 < S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_F64_E64: 'D0.u64[laneId] = S0.f64 == S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_F64_E64: 'D0.u64[laneId] = S0.f64 <= S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_F64_E64: 'D0.u64[laneId] = S0.f64 > S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LG_F64_E64: 'D0.u64[laneId] = S0.f64 <> S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_F64_E64: 'D0.u64[laneId] = S0.f64 >= S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_O_F64_E64: 'D0.u64[laneId] = (!isNAN(S0.f64) && !isNAN(S1.f64));\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_U_F64_E64: 'D0.u64[laneId] = (isNAN(S0.f64) || isNAN(S1.f64));\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NGE_F64_E64: 'D0.u64[laneId] = !(S0.f64 >= S1.f64);\n// With NAN inputs this is not the same operation as <\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLG_F64_E64: 'D0.u64[laneId] = !(S0.f64 <> S1.f64);\n// With NAN inputs this is not the same operation as ==\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NGT_F64_E64: 'D0.u64[laneId] = !(S0.f64 > S1.f64);\n// With NAN inputs this is not the same operation as <=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLE_F64_E64: 'D0.u64[laneId] = !(S0.f64 <= S1.f64);\n// With NAN inputs this is not the same operation as >\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NEQ_F64_E64: 'D0.u64[laneId] = !(S0.f64 == S1.f64);\n// With NAN inputs this is not the same operation as !=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NLT_F64_E64: 'D0.u64[laneId] = !(S0.f64 < S1.f64);\n// With NAN inputs this is not the same operation as >=\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LT_I16_E64: 'D0.u64[laneId] = S0.i16 < S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_I16_E64: 'D0.u64[laneId] = S0.i16 == S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_I16_E64: 'D0.u64[laneId] = S0.i16 <= S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_I16_E64: 'D0.u64[laneId] = S0.i16 > S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NE_I16_E64: 'D0.u64[laneId] = S0.i16 <> S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_I16_E64: 'D0.u64[laneId] = S0.i16 >= S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LT_U16_E64: 'D0.u64[laneId] = S0.u16 < S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_U16_E64: 'D0.u64[laneId] = S0.u16 == S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_U16_E64: 'D0.u64[laneId] = S0.u16 <= S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_U16_E64: 'D0.u64[laneId] = S0.u16 > S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NE_U16_E64: 'D0.u64[laneId] = S0.u16 <> S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_U16_E64: 'D0.u64[laneId] = S0.u16 >= S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LT_I32_E64: 'D0.u64[laneId] = S0.i32 < S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_I32_E64: 'D0.u64[laneId] = S0.i32 == S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_I32_E64: 'D0.u64[laneId] = S0.i32 <= S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_I32_E64: 'D0.u64[laneId] = S0.i32 > S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NE_I32_E64: 'D0.u64[laneId] = S0.i32 <> S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_I32_E64: 'D0.u64[laneId] = S0.i32 >= S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LT_U32_E64: 'D0.u64[laneId] = S0.u32 < S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_U32_E64: 'D0.u64[laneId] = S0.u32 == S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_U32_E64: 'D0.u64[laneId] = S0.u32 <= S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_U32_E64: 'D0.u64[laneId] = S0.u32 > S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NE_U32_E64: 'D0.u64[laneId] = S0.u32 <> S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_U32_E64: 'D0.u64[laneId] = S0.u32 >= S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LT_I64_E64: 'D0.u64[laneId] = S0.i64 < S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_I64_E64: 'D0.u64[laneId] = S0.i64 == S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_I64_E64: 'D0.u64[laneId] = S0.i64 <= S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_I64_E64: 'D0.u64[laneId] = S0.i64 > S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NE_I64_E64: 'D0.u64[laneId] = S0.i64 <> S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_I64_E64: 'D0.u64[laneId] = S0.i64 >= S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LT_U64_E64: 'D0.u64[laneId] = S0.u64 < S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_EQ_U64_E64: 'D0.u64[laneId] = S0.u64 == S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_LE_U64_E64: 'D0.u64[laneId] = S0.u64 <= S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GT_U64_E64: 'D0.u64[laneId] = S0.u64 > S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_NE_U64_E64: 'D0.u64[laneId] = S0.u64 <> S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_GE_U64_E64: 'D0.u64[laneId] = S0.u64 >= S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOP3Op.V_CMP_CLASS_F16_E64: "declare result : 1'U;\nif isSignalNAN(64'F(S0.f16)) then\nresult = S1.u32[0]\nelsif isQuietNAN(64'F(S0.f16)) then\nresult = S1.u32[1]\nelsif exponent(S0.f16) == 31 then\n// +-INF\nresult = S1.u32[sign(S0.f16) ? 2 : 9]\nelsif exponent(S0.f16) > 0 then\n// +-normal value\nresult = S1.u32[sign(S0.f16) ? 3 : 8]\nelsif 64'F(abs(S0.f16)) > 0.0 then\n// +-denormal value\nresult = S1.u32[sign(S0.f16) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u32[sign(S0.f16) ? 5 : 6]\nendif;\nD0.u64[laneId] = result;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_CLASS_F32_E64: "declare result : 1'U;\nif isSignalNAN(64'F(S0.f32)) then\nresult = S1.u32[0]\nelsif isQuietNAN(64'F(S0.f32)) then\nresult = S1.u32[1]\nelsif exponent(S0.f32) == 255 then\n// +-INF\nresult = S1.u32[sign(S0.f32) ? 2 : 9]\nelsif exponent(S0.f32) > 0 then\n// +-normal value\nresult = S1.u32[sign(S0.f32) ? 3 : 8]\nelsif 64'F(abs(S0.f32)) > 0.0 then\n// +-denormal value\nresult = S1.u32[sign(S0.f32) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u32[sign(S0.f32) ? 5 : 6]\nendif;\nD0.u64[laneId] = result;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMP_CLASS_F64_E64: "declare result : 1'U;\nif isSignalNAN(S0.f64) then\nresult = S1.u32[0]\nelsif isQuietNAN(S0.f64) then\nresult = S1.u32[1]\nelsif exponent(S0.f64) == 2047 then\n// +-INF\nresult = S1.u32[sign(S0.f64) ? 2 : 9]\nelsif exponent(S0.f64) > 0 then\n// +-normal value\nresult = S1.u32[sign(S0.f64) ? 3 : 8]\nelsif abs(S0.f64) > 0.0 then\n// +-denormal value\nresult = S1.u32[sign(S0.f64) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u32[sign(S0.f64) ? 5 : 6]\nendif;\nD0.u64[laneId] = result;\n// D0 = VCC in VOPC encoding.",
  VOP3Op.V_CMPX_LT_F16_E64: 'EXEC.u64[laneId] = S0.f16 < S1.f16',
  VOP3Op.V_CMPX_EQ_F16_E64: 'EXEC.u64[laneId] = S0.f16 == S1.f16',
  VOP3Op.V_CMPX_LE_F16_E64: 'EXEC.u64[laneId] = S0.f16 <= S1.f16',
  VOP3Op.V_CMPX_GT_F16_E64: 'EXEC.u64[laneId] = S0.f16 > S1.f16',
  VOP3Op.V_CMPX_LG_F16_E64: 'EXEC.u64[laneId] = S0.f16 <> S1.f16',
  VOP3Op.V_CMPX_GE_F16_E64: 'EXEC.u64[laneId] = S0.f16 >= S1.f16',
  VOP3Op.V_CMPX_O_F16_E64: "EXEC.u64[laneId] = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)))",
  VOP3Op.V_CMPX_U_F16_E64: "EXEC.u64[laneId] = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)))",
  VOP3Op.V_CMPX_NGE_F16_E64: 'EXEC.u64[laneId] = !(S0.f16 >= S1.f16);\n// With NAN inputs this is not the same operation as <',
  VOP3Op.V_CMPX_NLG_F16_E64: 'EXEC.u64[laneId] = !(S0.f16 <> S1.f16);\n// With NAN inputs this is not the same operation as ==',
  VOP3Op.V_CMPX_NGT_F16_E64: 'EXEC.u64[laneId] = !(S0.f16 > S1.f16);\n// With NAN inputs this is not the same operation as <=',
  VOP3Op.V_CMPX_NLE_F16_E64: 'EXEC.u64[laneId] = !(S0.f16 <= S1.f16);\n// With NAN inputs this is not the same operation as >',
  VOP3Op.V_CMPX_NEQ_F16_E64: 'EXEC.u64[laneId] = !(S0.f16 == S1.f16);\n// With NAN inputs this is not the same operation as !=',
  VOP3Op.V_CMPX_NLT_F16_E64: 'EXEC.u64[laneId] = !(S0.f16 < S1.f16);\n// With NAN inputs this is not the same operation as >=',
  VOP3Op.V_CMPX_LT_F32_E64: 'EXEC.u64[laneId] = S0.f32 < S1.f32',
  VOP3Op.V_CMPX_EQ_F32_E64: 'EXEC.u64[laneId] = S0.f32 == S1.f32',
  VOP3Op.V_CMPX_LE_F32_E64: 'EXEC.u64[laneId] = S0.f32 <= S1.f32',
  VOP3Op.V_CMPX_GT_F32_E64: 'EXEC.u64[laneId] = S0.f32 > S1.f32',
  VOP3Op.V_CMPX_LG_F32_E64: 'EXEC.u64[laneId] = S0.f32 <> S1.f32',
  VOP3Op.V_CMPX_GE_F32_E64: 'EXEC.u64[laneId] = S0.f32 >= S1.f32',
  VOP3Op.V_CMPX_O_F32_E64: "EXEC.u64[laneId] = (!isNAN(64'F(S0.f32)) && !isNAN(64'F(S1.f32)))",
  VOP3Op.V_CMPX_U_F32_E64: "EXEC.u64[laneId] = (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)))",
  VOP3Op.V_CMPX_NGE_F32_E64: 'EXEC.u64[laneId] = !(S0.f32 >= S1.f32);\n// With NAN inputs this is not the same operation as <',
  VOP3Op.V_CMPX_NLG_F32_E64: 'EXEC.u64[laneId] = !(S0.f32 <> S1.f32);\n// With NAN inputs this is not the same operation as ==',
  VOP3Op.V_CMPX_NGT_F32_E64: 'EXEC.u64[laneId] = !(S0.f32 > S1.f32);\n// With NAN inputs this is not the same operation as <=',
  VOP3Op.V_CMPX_NLE_F32_E64: 'EXEC.u64[laneId] = !(S0.f32 <= S1.f32);\n// With NAN inputs this is not the same operation as >',
  VOP3Op.V_CMPX_NEQ_F32_E64: 'EXEC.u64[laneId] = !(S0.f32 == S1.f32);\n// With NAN inputs this is not the same operation as !=',
  VOP3Op.V_CMPX_NLT_F32_E64: 'EXEC.u64[laneId] = !(S0.f32 < S1.f32);\n// With NAN inputs this is not the same operation as >=',
  VOP3Op.V_CMPX_LT_F64_E64: 'EXEC.u64[laneId] = S0.f64 < S1.f64',
  VOP3Op.V_CMPX_EQ_F64_E64: 'EXEC.u64[laneId] = S0.f64 == S1.f64',
  VOP3Op.V_CMPX_LE_F64_E64: 'EXEC.u64[laneId] = S0.f64 <= S1.f64',
  VOP3Op.V_CMPX_GT_F64_E64: 'EXEC.u64[laneId] = S0.f64 > S1.f64',
  VOP3Op.V_CMPX_LG_F64_E64: 'EXEC.u64[laneId] = S0.f64 <> S1.f64',
  VOP3Op.V_CMPX_GE_F64_E64: 'EXEC.u64[laneId] = S0.f64 >= S1.f64',
  VOP3Op.V_CMPX_O_F64_E64: 'EXEC.u64[laneId] = (!isNAN(S0.f64) && !isNAN(S1.f64))',
  VOP3Op.V_CMPX_U_F64_E64: 'EXEC.u64[laneId] = (isNAN(S0.f64) || isNAN(S1.f64))',
  VOP3Op.V_CMPX_NGE_F64_E64: 'EXEC.u64[laneId] = !(S0.f64 >= S1.f64);\n// With NAN inputs this is not the same operation as <',
  VOP3Op.V_CMPX_NLG_F64_E64: 'EXEC.u64[laneId] = !(S0.f64 <> S1.f64);\n// With NAN inputs this is not the same operation as ==',
  VOP3Op.V_CMPX_NGT_F64_E64: 'EXEC.u64[laneId] = !(S0.f64 > S1.f64);\n// With NAN inputs this is not the same operation as <=',
  VOP3Op.V_CMPX_NLE_F64_E64: 'EXEC.u64[laneId] = !(S0.f64 <= S1.f64);\n// With NAN inputs this is not the same operation as >',
  VOP3Op.V_CMPX_NEQ_F64_E64: 'EXEC.u64[laneId] = !(S0.f64 == S1.f64);\n// With NAN inputs this is not the same operation as !=',
  VOP3Op.V_CMPX_NLT_F64_E64: 'EXEC.u64[laneId] = !(S0.f64 < S1.f64);\n// With NAN inputs this is not the same operation as >=',
  VOP3Op.V_CMPX_LT_I16_E64: 'EXEC.u64[laneId] = S0.i16 < S1.i16',
  VOP3Op.V_CMPX_EQ_I16_E64: 'EXEC.u64[laneId] = S0.i16 == S1.i16',
  VOP3Op.V_CMPX_LE_I16_E64: 'EXEC.u64[laneId] = S0.i16 <= S1.i16',
  VOP3Op.V_CMPX_GT_I16_E64: 'EXEC.u64[laneId] = S0.i16 > S1.i16',
  VOP3Op.V_CMPX_NE_I16_E64: 'EXEC.u64[laneId] = S0.i16 <> S1.i16',
  VOP3Op.V_CMPX_GE_I16_E64: 'EXEC.u64[laneId] = S0.i16 >= S1.i16',
  VOP3Op.V_CMPX_LT_U16_E64: 'EXEC.u64[laneId] = S0.u16 < S1.u16',
  VOP3Op.V_CMPX_EQ_U16_E64: 'EXEC.u64[laneId] = S0.u16 == S1.u16',
  VOP3Op.V_CMPX_LE_U16_E64: 'EXEC.u64[laneId] = S0.u16 <= S1.u16',
  VOP3Op.V_CMPX_GT_U16_E64: 'EXEC.u64[laneId] = S0.u16 > S1.u16',
  VOP3Op.V_CMPX_NE_U16_E64: 'EXEC.u64[laneId] = S0.u16 <> S1.u16',
  VOP3Op.V_CMPX_GE_U16_E64: 'EXEC.u64[laneId] = S0.u16 >= S1.u16',
  VOP3Op.V_CMPX_LT_I32_E64: 'EXEC.u64[laneId] = S0.i32 < S1.i32',
  VOP3Op.V_CMPX_EQ_I32_E64: 'EXEC.u64[laneId] = S0.i32 == S1.i32',
  VOP3Op.V_CMPX_LE_I32_E64: 'EXEC.u64[laneId] = S0.i32 <= S1.i32',
  VOP3Op.V_CMPX_GT_I32_E64: 'EXEC.u64[laneId] = S0.i32 > S1.i32',
  VOP3Op.V_CMPX_NE_I32_E64: 'EXEC.u64[laneId] = S0.i32 <> S1.i32',
  VOP3Op.V_CMPX_GE_I32_E64: 'EXEC.u64[laneId] = S0.i32 >= S1.i32',
  VOP3Op.V_CMPX_LT_U32_E64: 'EXEC.u64[laneId] = S0.u32 < S1.u32',
  VOP3Op.V_CMPX_EQ_U32_E64: 'EXEC.u64[laneId] = S0.u32 == S1.u32',
  VOP3Op.V_CMPX_LE_U32_E64: 'EXEC.u64[laneId] = S0.u32 <= S1.u32',
  VOP3Op.V_CMPX_GT_U32_E64: 'EXEC.u64[laneId] = S0.u32 > S1.u32',
  VOP3Op.V_CMPX_NE_U32_E64: 'EXEC.u64[laneId] = S0.u32 <> S1.u32',
  VOP3Op.V_CMPX_GE_U32_E64: 'EXEC.u64[laneId] = S0.u32 >= S1.u32',
  VOP3Op.V_CMPX_LT_I64_E64: 'EXEC.u64[laneId] = S0.i64 < S1.i64',
  VOP3Op.V_CMPX_EQ_I64_E64: 'EXEC.u64[laneId] = S0.i64 == S1.i64',
  VOP3Op.V_CMPX_LE_I64_E64: 'EXEC.u64[laneId] = S0.i64 <= S1.i64',
  VOP3Op.V_CMPX_GT_I64_E64: 'EXEC.u64[laneId] = S0.i64 > S1.i64',
  VOP3Op.V_CMPX_NE_I64_E64: 'EXEC.u64[laneId] = S0.i64 <> S1.i64',
  VOP3Op.V_CMPX_GE_I64_E64: 'EXEC.u64[laneId] = S0.i64 >= S1.i64',
  VOP3Op.V_CMPX_LT_U64_E64: 'EXEC.u64[laneId] = S0.u64 < S1.u64',
  VOP3Op.V_CMPX_EQ_U64_E64: 'EXEC.u64[laneId] = S0.u64 == S1.u64',
  VOP3Op.V_CMPX_LE_U64_E64: 'EXEC.u64[laneId] = S0.u64 <= S1.u64',
  VOP3Op.V_CMPX_GT_U64_E64: 'EXEC.u64[laneId] = S0.u64 > S1.u64',
  VOP3Op.V_CMPX_NE_U64_E64: 'EXEC.u64[laneId] = S0.u64 <> S1.u64',
  VOP3Op.V_CMPX_GE_U64_E64: 'EXEC.u64[laneId] = S0.u64 >= S1.u64',
  VOP3Op.V_CMPX_CLASS_F16_E64: "declare result : 1'U;\nif isSignalNAN(64'F(S0.f16)) then\nresult = S1.u32[0]\nelsif isQuietNAN(64'F(S0.f16)) then\nresult = S1.u32[1]\nelsif exponent(S0.f16) == 31 then\n// +-INF\nresult = S1.u32[sign(S0.f16) ? 2 : 9]\nelsif exponent(S0.f16) > 0 then\n// +-normal value\nresult = S1.u32[sign(S0.f16) ? 3 : 8]\nelsif 64'F(abs(S0.f16)) > 0.0 then\n// +-denormal value\nresult = S1.u32[sign(S0.f16) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u32[sign(S0.f16) ? 5 : 6]\nendif;\nEXEC.u64[laneId] = result",
  VOP3Op.V_CMPX_CLASS_F32_E64: "declare result : 1'U;\nif isSignalNAN(64'F(S0.f32)) then\nresult = S1.u32[0]\nelsif isQuietNAN(64'F(S0.f32)) then\nresult = S1.u32[1]\nelsif exponent(S0.f32) == 255 then\n// +-INF\nresult = S1.u32[sign(S0.f32) ? 2 : 9]\nelsif exponent(S0.f32) > 0 then\n// +-normal value\nresult = S1.u32[sign(S0.f32) ? 3 : 8]\nelsif 64'F(abs(S0.f32)) > 0.0 then\n// +-denormal value\nresult = S1.u32[sign(S0.f32) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u32[sign(S0.f32) ? 5 : 6]\nendif;\nEXEC.u64[laneId] = result",
  VOP3Op.V_CMPX_CLASS_F64_E64: "declare result : 1'U;\nif isSignalNAN(S0.f64) then\nresult = S1.u32[0]\nelsif isQuietNAN(S0.f64) then\nresult = S1.u32[1]\nelsif exponent(S0.f64) == 2047 then\n// +-INF\nresult = S1.u32[sign(S0.f64) ? 2 : 9]\nelsif exponent(S0.f64) > 0 then\n// +-normal value\nresult = S1.u32[sign(S0.f64) ? 3 : 8]\nelsif abs(S0.f64) > 0.0 then\n// +-denormal value\nresult = S1.u32[sign(S0.f64) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u32[sign(S0.f64) ? 5 : 6]\nendif;\nEXEC.u64[laneId] = result",
  VOP3Op.V_CNDMASK_B32_E64: 'D0.u32 = VCC.u64[laneId] ? S1.u32 : S0.u32',
  VOP3Op.V_ADD_F64_E64: 'D0.f64 = S0.f64 + S1.f64',
  VOP3Op.V_ADD_F32_E64: 'D0.f32 = S0.f32 + S1.f32',
  VOP3Op.V_SUB_F32_E64: 'D0.f32 = S0.f32 - S1.f32',
  VOP3Op.V_SUBREV_F32_E64: 'D0.f32 = S1.f32 - S0.f32',
  VOP3Op.V_MUL_F64_E64: 'D0.f64 = S0.f64 * S1.f64',
  VOP3Op.V_MUL_DX9_ZERO_F32_E64: "if ((64'F(S0.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then\n// DX9 rules, 0.0 * x = 0.0\nD0.f32 = 0.0F\nelse\nD0.f32 = S0.f32 * S1.f32\nendif",
  VOP3Op.V_MUL_F32_E64: 'D0.f32 = S0.f32 * S1.f32',
  VOP3Op.V_MUL_I32_I24_E64: "D0.i32 = 32'I(S0.i24) * 32'I(S1.i24)",
  VOP3Op.V_MUL_HI_I32_I24_E64: "D0.i32 = 32'I((64'I(S0.i24) * 64'I(S1.i24)) >> 32U)",
  VOP3Op.V_MUL_U32_U24_E64: "D0.u32 = 32'U(S0.u24) * 32'U(S1.u24)",
  VOP3Op.V_MUL_HI_U32_U24_E64: "D0.u32 = 32'U((64'U(S0.u24) * 64'U(S1.u24)) >> 32U)",
  VOP3Op.V_MIN_NUM_F64_E64: 'if (isSignalNAN(S0.f64) || isSignalNAN(S1.f64)) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(S0.f64) && isNAN(S1.f64)) then\nD0.f64 = cvtToQuietNAN(S0.f64)\nelsif isNAN(S0.f64) then\nD0.f64 = S1.f64\nelsif isNAN(S1.f64) then\nD0.f64 = S0.f64\nelsif ((S0.f64 < S1.f64) || ((abs(S0.f64) == 0.0) && (abs(S1.f64) == 0.0) && sign(S0.f64) &&\n!sign(S1.f64))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f64 = S0.f64\nelse\nD0.f64 = S1.f64\nendif',
  VOP3Op.V_MAX_NUM_F64_E64: 'if (isSignalNAN(S0.f64) || isSignalNAN(S1.f64)) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(S0.f64) && isNAN(S1.f64)) then\nD0.f64 = cvtToQuietNAN(S0.f64)\nelsif isNAN(S0.f64) then\nD0.f64 = S1.f64\nelsif isNAN(S1.f64) then\nD0.f64 = S0.f64\nelsif ((S0.f64 > S1.f64) || ((abs(S0.f64) == 0.0) && (abs(S1.f64) == 0.0) && !sign(S0.f64) &&\nsign(S1.f64))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f64 = S0.f64\nelse\nD0.f64 = S1.f64\nendif',
  VOP3Op.V_MIN_I32_E64: 'D0.i32 = S0.i32 < S1.i32 ? S0.i32 : S1.i32',
  VOP3Op.V_MAX_I32_E64: 'D0.i32 = S0.i32 >= S1.i32 ? S0.i32 : S1.i32',
  VOP3Op.V_MIN_U32_E64: 'D0.u32 = S0.u32 < S1.u32 ? S0.u32 : S1.u32',
  VOP3Op.V_MAX_U32_E64: 'D0.u32 = S0.u32 >= S1.u32 ? S0.u32 : S1.u32',
  VOP3Op.V_MIN_NUM_F32_E64: "if (isSignalNAN(64'F(S0.f32)) || isSignalNAN(64'F(S1.f32))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f32)) && isNAN(64'F(S1.f32))) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nelsif isNAN(64'F(S0.f32)) then\nD0.f32 = S1.f32\nelsif isNAN(64'F(S1.f32)) then\nD0.f32 = S0.f32\nelsif ((S0.f32 < S1.f32) || ((abs(S0.f32) == 0.0F) && (abs(S1.f32) == 0.0F) && sign(S0.f32) &&\n!sign(S1.f32))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f32 = S0.f32\nelse\nD0.f32 = S1.f32\nendif",
  VOP3Op.V_MAX_NUM_F32_E64: "if (isSignalNAN(64'F(S0.f32)) || isSignalNAN(64'F(S1.f32))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f32)) && isNAN(64'F(S1.f32))) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nelsif isNAN(64'F(S0.f32)) then\nD0.f32 = S1.f32\nelsif isNAN(64'F(S1.f32)) then\nD0.f32 = S0.f32\nelsif ((S0.f32 > S1.f32) || ((abs(S0.f32) == 0.0F) && (abs(S1.f32) == 0.0F) && !sign(S0.f32) &&\nsign(S1.f32))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f32 = S0.f32\nelse\nD0.f32 = S1.f32\nendif",
  VOP3Op.V_LSHLREV_B32_E64: 'D0.u32 = (S1.u32 << S0[4 : 0].u32)',
  VOP3Op.V_LSHRREV_B32_E64: 'D0.u32 = (S1.u32 >> S0[4 : 0].u32)',
  VOP3Op.V_ASHRREV_I32_E64: 'D0.i32 = (S1.i32 >> S0[4 : 0].u32)',
  VOP3Op.V_AND_B32_E64: 'D0.u32 = (S0.u32 & S1.u32)',
  VOP3Op.V_OR_B32_E64: 'D0.u32 = (S0.u32 | S1.u32)',
  VOP3Op.V_XOR_B32_E64: 'D0.u32 = (S0.u32 ^ S1.u32)',
  VOP3Op.V_XNOR_B32_E64: 'D0.u32 = ~(S0.u32 ^ S1.u32)',
  VOP3Op.V_LSHLREV_B64_E64: 'D0.u64 = (S1.u64 << S0[5 : 0].u32)',
  VOP3Op.V_ADD_NC_U32_E64: 'D0.u32 = S0.u32 + S1.u32',
  VOP3Op.V_SUB_NC_U32_E64: 'D0.u32 = S0.u32 - S1.u32',
  VOP3Op.V_SUBREV_NC_U32_E64: 'D0.u32 = S1.u32 - S0.u32',
  VOP3Op.V_FMAC_F32_E64: 'D0.f32 = fma(S0.f32, S1.f32, D0.f32)',
  VOP3Op.V_CVT_PK_RTZ_F16_F32_E64: 'prev_mode = ROUND_MODE;\nROUND_MODE = ROUND_TOWARD_ZERO;\ntmp[15 : 0].f16 = f32_to_f16(S0.f32);\ntmp[31 : 16].f16 = f32_to_f16(S1.f32);\nD0 = tmp.b32;\nROUND_MODE = prev_mode;\n// Round-toward-zero regardless of current round mode setting in hardware.',
  VOP3Op.V_MIN_NUM_F16_E64: "if (isSignalNAN(64'F(S0.f16)) || isSignalNAN(64'F(S1.f16))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f16)) && isNAN(64'F(S1.f16))) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nelsif isNAN(64'F(S0.f16)) then\nD0.f16 = S1.f16\nelsif isNAN(64'F(S1.f16)) then\nD0.f16 = S0.f16\nelsif ((S0.f16 < S1.f16) || ((abs(S0.f16) == 16'0.0) && (abs(S1.f16) == 16'0.0) && sign(S0.f16) &&\n!sign(S1.f16))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif",
  VOP3Op.V_MAX_NUM_F16_E64: "if (isSignalNAN(64'F(S0.f16)) || isSignalNAN(64'F(S1.f16))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f16)) && isNAN(64'F(S1.f16))) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nelsif isNAN(64'F(S0.f16)) then\nD0.f16 = S1.f16\nelsif isNAN(64'F(S1.f16)) then\nD0.f16 = S0.f16\nelsif ((S0.f16 > S1.f16) || ((abs(S0.f16) == 16'0.0) && (abs(S1.f16) == 16'0.0) && !sign(S0.f16) &&\nsign(S1.f16))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif",
  VOP3Op.V_ADD_F16_E64: 'D0.f16 = S0.f16 + S1.f16',
  VOP3Op.V_SUB_F16_E64: 'D0.f16 = S0.f16 - S1.f16',
  VOP3Op.V_SUBREV_F16_E64: 'D0.f16 = S1.f16 - S0.f16',
  VOP3Op.V_MUL_F16_E64: 'D0.f16 = S0.f16 * S1.f16',
  VOP3Op.V_FMAC_F16_E64: 'D0.f16 = fma(S0.f16, S1.f16, D0.f16)',
  VOP3Op.V_LDEXP_F16_E64: "D0.f16 = S0.f16 * 16'F(2.0F ** 32'I(S1.i16))",
  VOP3Op.V_MOV_B32_E64: 'D0.b32 = S0.b32',
  VOP3Op.V_READFIRSTLANE_B32_E64: "declare lane : 32'U;\nif WAVE64 then\n// 64 lanes\nif EXEC == 0x0LL then\nlane = 0U;\n// Force lane 0 if all lanes are disabled\nelse\nlane = 32'U(s_ff1_i32_b64(EXEC));\n// Lowest active lane\nendif\nelse\n// 32 lanes\nif EXEC_LO.i32 == 0 then\nlane = 0U;\n// Force lane 0 if all lanes are disabled\nelse\nlane = 32'U(s_ff1_i32_b32(EXEC_LO));\n// Lowest active lane\nendif\nendif;\nD0.b32 = VGPR[lane][SRC0.u32]",
  VOP3Op.V_CVT_I32_F64_E64: 'D0.i32 = f64_to_i32(S0.f64)',
  VOP3Op.V_CVT_F64_I32_E64: 'D0.f64 = i32_to_f64(S0.i32)',
  VOP3Op.V_CVT_F32_I32_E64: 'D0.f32 = i32_to_f32(S0.i32)',
  VOP3Op.V_CVT_F32_U32_E64: 'D0.f32 = u32_to_f32(S0.u32)',
  VOP3Op.V_CVT_U32_F32_E64: 'D0.u32 = f32_to_u32(S0.f32)',
  VOP3Op.V_CVT_I32_F32_E64: 'D0.i32 = f32_to_i32(S0.f32)',
  VOP3Op.V_CVT_F16_F32_E64: 'D0.f16 = f32_to_f16(S0.f32)',
  VOP3Op.V_CVT_F32_F16_E64: 'D0.f32 = f16_to_f32(S0.f16)',
  VOP3Op.V_CVT_NEAREST_I32_F32_E64: 'D0.i32 = f32_to_i32(floor(S0.f32 + 0.5F))',
  VOP3Op.V_CVT_FLOOR_I32_F32_E64: 'D0.i32 = f32_to_i32(floor(S0.f32))',
  VOP3Op.V_CVT_OFF_F32_I4_E64: "declare CVT_OFF_TABLE : 32'F[16];\nD0.f32 = CVT_OFF_TABLE[S0.u32[3 : 0]]",
  VOP3Op.V_CVT_F32_F64_E64: 'D0.f32 = f64_to_f32(S0.f64)',
  VOP3Op.V_CVT_F64_F32_E64: 'D0.f64 = f32_to_f64(S0.f32)',
  VOP3Op.V_CVT_F32_UBYTE0_E64: 'D0.f32 = u32_to_f32(S0[7 : 0].u32)',
  VOP3Op.V_CVT_F32_UBYTE1_E64: 'D0.f32 = u32_to_f32(S0[15 : 8].u32)',
  VOP3Op.V_CVT_F32_UBYTE2_E64: 'D0.f32 = u32_to_f32(S0[23 : 16].u32)',
  VOP3Op.V_CVT_F32_UBYTE3_E64: 'D0.f32 = u32_to_f32(S0[31 : 24].u32)',
  VOP3Op.V_CVT_U32_F64_E64: 'D0.u32 = f64_to_u32(S0.f64)',
  VOP3Op.V_CVT_F64_U32_E64: 'D0.f64 = u32_to_f64(S0.u32)',
  VOP3Op.V_TRUNC_F64_E64: 'D0.f64 = trunc(S0.f64)',
  VOP3Op.V_CEIL_F64_E64: 'D0.f64 = trunc(S0.f64);\nif ((S0.f64 > 0.0) && (S0.f64 != D0.f64)) then\nD0.f64 += 1.0\nendif',
  VOP3Op.V_RNDNE_F64_E64: 'D0.f64 = floor(S0.f64 + 0.5);\nif (isEven(floor(S0.f64)) && (fract(S0.f64) == 0.5)) then\nD0.f64 -= 1.0\nendif',
  VOP3Op.V_FLOOR_F64_E64: 'D0.f64 = trunc(S0.f64);\nif ((S0.f64 < 0.0) && (S0.f64 != D0.f64)) then\nD0.f64 += -1.0\nendif',
  VOP3Op.V_MOV_B16_E64: 'D0.b16 = S0.b16',
  VOP3Op.V_FRACT_F32_E64: 'D0.f32 = S0.f32 + -floor(S0.f32)',
  VOP3Op.V_TRUNC_F32_E64: 'D0.f32 = trunc(S0.f32)',
  VOP3Op.V_CEIL_F32_E64: 'D0.f32 = trunc(S0.f32);\nif ((S0.f32 > 0.0F) && (S0.f32 != D0.f32)) then\nD0.f32 += 1.0F\nendif',
  VOP3Op.V_RNDNE_F32_E64: "D0.f32 = floor(S0.f32 + 0.5F);\nif (isEven(64'F(floor(S0.f32))) && (fract(S0.f32) == 0.5F)) then\nD0.f32 -= 1.0F\nendif",
  VOP3Op.V_FLOOR_F32_E64: 'D0.f32 = trunc(S0.f32);\nif ((S0.f32 < 0.0F) && (S0.f32 != D0.f32)) then\nD0.f32 += -1.0F\nendif',
  VOP3Op.V_EXP_F32_E64: 'D0.f32 = pow(2.0F, S0.f32)',
  VOP3Op.V_LOG_F32_E64: 'D0.f32 = log2(S0.f32)',
  VOP3Op.V_RCP_F32_E64: 'D0.f32 = 1.0F / S0.f32',
  VOP3Op.V_RCP_IFLAG_F32_E64: 'D0.f32 = 1.0F / S0.f32;\n// Can only raise integer DIV_BY_ZERO exception',
  VOP3Op.V_RSQ_F32_E64: 'D0.f32 = 1.0F / sqrt(S0.f32)',
  VOP3Op.V_RCP_F64_E64: 'D0.f64 = 1.0 / S0.f64',
  VOP3Op.V_RSQ_F64_E64: 'D0.f64 = 1.0 / sqrt(S0.f64)',
  VOP3Op.V_SQRT_F32_E64: 'D0.f32 = sqrt(S0.f32)',
  VOP3Op.V_SQRT_F64_E64: 'D0.f64 = sqrt(S0.f64)',
  VOP3Op.V_SIN_F32_E64: "D0.f32 = sin(S0.f32 * 32'F(PI * 2.0))",
  VOP3Op.V_COS_F32_E64: "D0.f32 = cos(S0.f32 * 32'F(PI * 2.0))",
  VOP3Op.V_NOT_B32_E64: 'D0.u32 = ~S0.u32',
  VOP3Op.V_BFREV_B32_E64: 'D0.u32[31 : 0] = S0.u32[0 : 31]',
  VOP3Op.V_CLZ_I32_U32_E64: "D0.i32 = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\n// Search from MSB\nif S0.u32[31 - i] == 1'1U then\nD0.i32 = i;\nbreak\nendif\nendfor",
  VOP3Op.V_CTZ_I32_B32_E64: "D0.i32 = -1;\n// Set if no ones are found\nfor i in 0 : 31 do\n// Search from LSB\nif S0.u32[i] == 1'1U then\nD0.i32 = i;\nbreak\nendif\nendfor",
  VOP3Op.V_CLS_I32_E64: 'D0.i32 = -1;\n// Set if all bits are the same\nfor i in 1 : 31 do\n// Search from MSB\nif S0.i32[31 - i] != S0.i32[31] then\nD0.i32 = i;\nbreak\nendif\nendfor',
  VOP3Op.V_FREXP_EXP_I32_F64_E64: 'if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then\nD0.i32 = 0\nelse\nD0.i32 = exponent(S0.f64) - 1023 + 1\nendif',
  VOP3Op.V_FREXP_MANT_F64_E64: 'if ((S0.f64 == +INF) || (S0.f64 == -INF) || isNAN(S0.f64)) then\nD0.f64 = S0.f64\nelse\nD0.f64 = mantissa(S0.f64)\nendif',
  VOP3Op.V_FRACT_F64_E64: 'D0.f64 = S0.f64 + -floor(S0.f64)',
  VOP3Op.V_FREXP_EXP_I32_F32_E64: "if ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then\nD0.i32 = 0\nelse\nD0.i32 = exponent(S0.f32) - 127 + 1\nendif",
  VOP3Op.V_FREXP_MANT_F32_E64: "if ((64'F(S0.f32) == +INF) || (64'F(S0.f32) == -INF) || isNAN(64'F(S0.f32))) then\nD0.f32 = S0.f32\nelse\nD0.f32 = mantissa(S0.f32)\nendif",
  VOP3Op.V_MOVRELD_B32_E64: 'addr = DST.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nVGPR[laneId][addr].b32 = S0.b32',
  VOP3Op.V_MOVRELS_B32_E64: 'addr = SRC0.u32;\n// Raw value from instruction\naddr += M0.u32[31 : 0];\nD0.b32 = VGPR[laneId][addr].b32',
  VOP3Op.V_MOVRELSD_B32_E64: 'addrs = SRC0.u32;\n// Raw value from instruction\naddrd = DST.u32;\n// Raw value from instruction\naddrs += M0.u32[31 : 0];\naddrd += M0.u32[31 : 0];\nVGPR[laneId][addrd].b32 = VGPR[laneId][addrs].b32',
  VOP3Op.V_MOVRELSD_2_B32_E64: 'addrs = SRC0.u32;\n// Raw value from instruction\naddrd = DST.u32;\n// Raw value from instruction\naddrs += M0.u32[9 : 0].u32;\naddrd += M0.u32[25 : 16].u32;\nVGPR[laneId][addrd].b32 = VGPR[laneId][addrs].b32',
  VOP3Op.V_CVT_F16_U16_E64: 'D0.f16 = u16_to_f16(S0.u16)',
  VOP3Op.V_CVT_F16_I16_E64: 'D0.f16 = i16_to_f16(S0.i16)',
  VOP3Op.V_CVT_U16_F16_E64: 'D0.u16 = f16_to_u16(S0.f16)',
  VOP3Op.V_CVT_I16_F16_E64: 'D0.i16 = f16_to_i16(S0.f16)',
  VOP3Op.V_RCP_F16_E64: "D0.f16 = 16'1.0 / S0.f16",
  VOP3Op.V_SQRT_F16_E64: 'D0.f16 = sqrt(S0.f16)',
  VOP3Op.V_RSQ_F16_E64: "D0.f16 = 16'1.0 / sqrt(S0.f16)",
  VOP3Op.V_LOG_F16_E64: 'D0.f16 = log2(S0.f16)',
  VOP3Op.V_EXP_F16_E64: "D0.f16 = pow(16'2.0, S0.f16)",
  VOP3Op.V_FREXP_MANT_F16_E64: "if ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then\nD0.f16 = S0.f16\nelse\nD0.f16 = mantissa(S0.f16)\nendif",
  VOP3Op.V_FREXP_EXP_I16_F16_E64: "if ((64'F(S0.f16) == +INF) || (64'F(S0.f16) == -INF) || isNAN(64'F(S0.f16))) then\nD0.i16 = 16'0\nelse\nD0.i16 = 16'I(exponent(S0.f16) - 15 + 1)\nendif",
  VOP3Op.V_FLOOR_F16_E64: "D0.f16 = trunc(S0.f16);\nif ((S0.f16 < 16'0.0) && (S0.f16 != D0.f16)) then\nD0.f16 += -16'1.0\nendif",
  VOP3Op.V_CEIL_F16_E64: "D0.f16 = trunc(S0.f16);\nif ((S0.f16 > 16'0.0) && (S0.f16 != D0.f16)) then\nD0.f16 += 16'1.0\nendif",
  VOP3Op.V_TRUNC_F16_E64: 'D0.f16 = trunc(S0.f16)',
  VOP3Op.V_RNDNE_F16_E64: "D0.f16 = floor(S0.f16 + 16'0.5);\nif (isEven(64'F(floor(S0.f16))) && (fract(S0.f16) == 16'0.5)) then\nD0.f16 -= 16'1.0\nendif",
  VOP3Op.V_FRACT_F16_E64: 'D0.f16 = S0.f16 + -floor(S0.f16)',
  VOP3Op.V_SIN_F16_E64: "D0.f16 = sin(S0.f16 * 16'F(PI * 2.0))",
  VOP3Op.V_COS_F16_E64: "D0.f16 = cos(S0.f16 * 16'F(PI * 2.0))",
  VOP3Op.V_SAT_PK_U8_I16_E64: "SAT8 = lambda(n) (\nif n <= 16'0 then\nreturn 8'0U\nelsif n >= 16'255 then\nreturn 8'255U\nelse\nreturn n[7 : 0].u8\nendif);\ntmp = 16'0;\ntmp[7 : 0].u8 = SAT8(S0[15 : 0].i16);\ntmp[15 : 8].u8 = SAT8(S0[31 : 16].i16);\nD0.b16 = tmp.b16",
  VOP3Op.V_CVT_NORM_I16_F16_E64: 'D0.i16 = f16_to_snorm(S0.f16)',
  VOP3Op.V_CVT_NORM_U16_F16_E64: 'D0.u16 = f16_to_unorm(S0.f16)',
  VOP3Op.V_NOT_B16_E64: 'D0.u16 = ~S0.u16',
  VOP3Op.V_CVT_I32_I16_E64: "D0.i32 = 32'I(signext(S0.i16))",
  VOP3Op.V_CVT_U32_U16_E64: "D0 = { 16'0, S0.u16 }",
  VOP3Op.V_CVT_F32_FP8_E64: "if OPSEL[1 : 0].u2 == 2'0U then\nD0.f32 = fp8_to_f32(VGPR[laneId][SRC0.u32][7 : 0].fp8)\nelsif OPSEL[1 : 0].u2 == 2'2U then\n// Byte select bits are reversed\nD0.f32 = fp8_to_f32(VGPR[laneId][SRC0.u32][15 : 8].fp8)\nelsif OPSEL[1 : 0].u2 == 2'1U then\nD0.f32 = fp8_to_f32(VGPR[laneId][SRC0.u32][23 : 16].fp8)\nelse\nD0.f32 = fp8_to_f32(VGPR[laneId][SRC0.u32][31 : 24].fp8)\nendif",
  VOP3Op.V_CVT_F32_BF8_E64: "if OPSEL[1 : 0].u2 == 2'0U then\nD0.f32 = bf8_to_f32(VGPR[laneId][SRC0.u32][7 : 0].bf8)\nelsif OPSEL[1 : 0].u2 == 2'2U then\n// Byte select bits are reversed\nD0.f32 = bf8_to_f32(VGPR[laneId][SRC0.u32][15 : 8].bf8)\nelsif OPSEL[1 : 0].u2 == 2'1U then\nD0.f32 = bf8_to_f32(VGPR[laneId][SRC0.u32][23 : 16].bf8)\nelse\nD0.f32 = bf8_to_f32(VGPR[laneId][SRC0.u32][31 : 24].bf8)\nendif",
  VOP3Op.V_CVT_PK_F32_FP8_E64: 'tmp = OPSEL[0].u1 ? VGPR[laneId][SRC0.u32][31 : 16] : VGPR[laneId][SRC0.u32][15 : 0];\nD0[31 : 0].f32 = fp8_to_f32(tmp[7 : 0].fp8);\nD0[63 : 32].f32 = fp8_to_f32(tmp[15 : 8].fp8)',
  VOP3Op.V_CVT_PK_F32_BF8_E64: 'tmp = OPSEL[0].u1 ? VGPR[laneId][SRC0.u32][31 : 16] : VGPR[laneId][SRC0.u32][15 : 0];\nD0[31 : 0].f32 = bf8_to_f32(tmp[7 : 0].bf8);\nD0[63 : 32].f32 = bf8_to_f32(tmp[15 : 8].bf8)',
  VOP3Op.V_FMA_DX9_ZERO_F32: "if ((64'F(S0.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then\n// DX9 rules, 0.0 * x = 0.0\nD0.f32 = S2.f32\nelse\nD0.f32 = fma(S0.f32, S1.f32, S2.f32)\nendif",
  VOP3Op.V_MAD_I32_I24: "D0.i32 = 32'I(S0.i24) * 32'I(S1.i24) + S2.i32",
  VOP3Op.V_MAD_U32_U24: "D0.u32 = 32'U(S0.u24) * 32'U(S1.u24) + S2.u32",
  VOP3Op.V_CUBEID_F32: '// Set D0.f = cubemap face ID ({0.0, 1.0, ..., 5.0}).\n// XYZ coordinate is given in (S0.f, S1.f, S2.f).\n// S0.f = x\n// S1.f = y\n// S2.f = z\nif ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then\nif S2.f32 < 0.0F then\nD0.f32 = 5.0F\nelse\nD0.f32 = 4.0F\nendif\nelsif abs(S1.f32) >= abs(S0.f32) then\nif S1.f32 < 0.0F then\nD0.f32 = 3.0F\nelse\nD0.f32 = 2.0F\nendif\nelse\nif S0.f32 < 0.0F then\nD0.f32 = 1.0F\nelse\nD0.f32 = 0.0F\nendif\nendif',
  VOP3Op.V_CUBESC_F32: '// D0.f = cubemap S coordinate.\n// XYZ coordinate is given in (S0.f, S1.f, S2.f).\n// S0.f = x\n// S1.f = y\n// S2.f = z\nif ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then\nif S2.f32 < 0.0F then\nD0.f32 = -S0.f32\nelse\nD0.f32 = S0.f32\nendif\nelsif abs(S1.f32) >= abs(S0.f32) then\nD0.f32 = S0.f32\nelse\nif S0.f32 < 0.0F then\nD0.f32 = S2.f32\nelse\nD0.f32 = -S2.f32\nendif\nendif',
  VOP3Op.V_CUBETC_F32: '// D0.f = cubemap T coordinate.\n// XYZ coordinate is given in (S0.f, S1.f, S2.f).\n// S0.f = x\n// S1.f = y\n// S2.f = z\nif ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then\nD0.f32 = -S1.f32\nelsif abs(S1.f32) >= abs(S0.f32) then\nif S1.f32 < 0.0F then\nD0.f32 = -S2.f32\nelse\nD0.f32 = S2.f32\nendif\nelse\nD0.f32 = -S1.f32\nendif',
  VOP3Op.V_CUBEMA_F32: '// D0.f = 2.0 * cubemap major axis.\n// XYZ coordinate is given in (S0.f, S1.f, S2.f).\n// S0.f = x\n// S1.f = y\n// S2.f = z\nif ((abs(S2.f32) >= abs(S0.f32)) && (abs(S2.f32) >= abs(S1.f32))) then\nD0.f32 = S2.f32 * 2.0F\nelsif abs(S1.f32) >= abs(S0.f32) then\nD0.f32 = S1.f32 * 2.0F\nelse\nD0.f32 = S0.f32 * 2.0F\nendif',
  VOP3Op.V_BFE_U32: 'D0.u32 = ((S0.u32 >> S1[4 : 0].u32) & ((1U << S2[4 : 0].u32) - 1U))',
  VOP3Op.V_BFE_I32: 'tmp.i32 = ((S0.i32 >> S1[4 : 0].u32) & ((1 << S2[4 : 0].u32) - 1));\nD0.i32 = signext_from_bit(tmp.i32, S2[4 : 0].u32)',
  VOP3Op.V_BFI_B32: 'D0.u32 = ((S0.u32 & S1.u32) | (~S0.u32 & S2.u32))',
  VOP3Op.V_FMA_F32: 'D0.f32 = fma(S0.f32, S1.f32, S2.f32)',
  VOP3Op.V_FMA_F64: 'D0.f64 = fma(S0.f64, S1.f64, S2.f64)',
  VOP3Op.V_LERP_U8: 'tmp = ((S0.u32[31 : 24] + S1.u32[31 : 24] + S2.u32[24].u8) >> 1U << 24U);\ntmp += ((S0.u32[23 : 16] + S1.u32[23 : 16] + S2.u32[16].u8) >> 1U << 16U);\ntmp += ((S0.u32[15 : 8] + S1.u32[15 : 8] + S2.u32[8].u8) >> 1U << 8U);\ntmp += ((S0.u32[7 : 0] + S1.u32[7 : 0] + S2.u32[0].u8) >> 1U);\nD0.u32 = tmp.u32',
  VOP3Op.V_ALIGNBIT_B32: "D0.u32 = 32'U(({ S0.u32, S1.u32 } >> S2.u32[4 : 0]) & 0xffffffffLL)",
  VOP3Op.V_ALIGNBYTE_B32: "D0.u32 = 32'U(({ S0.u32, S1.u32 } >> (S2.u32[1 : 0] * 8U)) & 0xffffffffLL)",
  VOP3Op.V_MULLIT_F32: "if ((S1.f32 == -MAX_FLOAT_F32) || (64'F(S1.f32) == -INF) || isNAN(64'F(S1.f32)) || (S2.f32 <= 0.0F) ||\nisNAN(64'F(S2.f32))) then\nD0.f32 = -MAX_FLOAT_F32\nelse\nD0.f32 = S0.f32 * S1.f32\nendif",
  VOP3Op.V_MIN3_I32: 'D0.i32 = v_min_i32(v_min_i32(S0.i32, S1.i32), S2.i32)',
  VOP3Op.V_MIN3_U32: 'D0.u32 = v_min_u32(v_min_u32(S0.u32, S1.u32), S2.u32)',
  VOP3Op.V_MAX3_I32: 'D0.i32 = v_max_i32(v_max_i32(S0.i32, S1.i32), S2.i32)',
  VOP3Op.V_MAX3_U32: 'D0.u32 = v_max_u32(v_max_u32(S0.u32, S1.u32), S2.u32)',
  VOP3Op.V_MED3_I32: 'if v_max3_i32(S0.i32, S1.i32, S2.i32) == S0.i32 then\nD0.i32 = v_max_i32(S1.i32, S2.i32)\nelsif v_max3_i32(S0.i32, S1.i32, S2.i32) == S1.i32 then\nD0.i32 = v_max_i32(S0.i32, S2.i32)\nelse\nD0.i32 = v_max_i32(S0.i32, S1.i32)\nendif',
  VOP3Op.V_MED3_U32: 'if v_max3_u32(S0.u32, S1.u32, S2.u32) == S0.u32 then\nD0.u32 = v_max_u32(S1.u32, S2.u32)\nelsif v_max3_u32(S0.u32, S1.u32, S2.u32) == S1.u32 then\nD0.u32 = v_max_u32(S0.u32, S2.u32)\nelse\nD0.u32 = v_max_u32(S0.u32, S1.u32)\nendif',
  VOP3Op.V_SAD_U8: "ABSDIFF = lambda(x, y) (\nx > y ? x - y : y - x);\n// UNSIGNED comparison\ntmp = S2.u32;\ntmp += 32'U(ABSDIFF(S0.u32[7 : 0], S1.u32[7 : 0]));\ntmp += 32'U(ABSDIFF(S0.u32[15 : 8], S1.u32[15 : 8]));\ntmp += 32'U(ABSDIFF(S0.u32[23 : 16], S1.u32[23 : 16]));\ntmp += 32'U(ABSDIFF(S0.u32[31 : 24], S1.u32[31 : 24]));\nD0.u32 = tmp",
  VOP3Op.V_SAD_HI_U8: "D0.u32 = (32'U(v_sad_u8(S0, S1, 0U)) << 16U) + S2.u32",
  VOP3Op.V_SAD_U16: 'ABSDIFF = lambda(x, y) (\nx > y ? x - y : y - x);\n// UNSIGNED comparison\ntmp = S2.u32;\ntmp += ABSDIFF(S0[15 : 0].u16, S1[15 : 0].u16);\ntmp += ABSDIFF(S0[31 : 16].u16, S1[31 : 16].u16);\nD0.u32 = tmp',
  VOP3Op.V_SAD_U32: 'ABSDIFF = lambda(x, y) (\nx > y ? x - y : y - x);\n// UNSIGNED comparison\nD0.u32 = ABSDIFF(S0.u32, S1.u32) + S2.u32',
  VOP3Op.V_CVT_PK_U8_F32: "tmp = (S2.u32 & 32'U(~(0xff << (S1.u32[1 : 0].u32 * 8U))));\ntmp = (tmp | ((32'U(f32_to_u8(S0.f32)) & 255U) << (S1.u32[1 : 0].u32 * 8U)));\nD0.u32 = tmp",
  VOP3Op.V_DIV_FIXUP_F32: "sign_out = (sign(S1.f32) ^ sign(S2.f32));\nif isNAN(64'F(S2.f32)) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S2.f32)))\nelsif isNAN(64'F(S1.f32)) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))\nelsif ((64'F(S1.f32) == 0.0) && (64'F(S2.f32) == 0.0)) then\n// 0/0\nD0.f32 = 32'F(0xffc00000)\nelsif ((64'F(abs(S1.f32)) == +INF) && (64'F(abs(S2.f32)) == +INF)) then\n// inf/inf\nD0.f32 = 32'F(0xffc00000)\nelsif ((64'F(S1.f32) == 0.0) || (64'F(abs(S2.f32)) == +INF)) then\n// x/0, or inf/y\nD0.f32 = sign_out ? -INF.f32 : +INF.f32\nelsif ((64'F(abs(S1.f32)) == +INF) || (64'F(S2.f32) == 0.0)) then\n// x/inf, 0/y\nD0.f32 = sign_out ? -0.0F : 0.0F\nelsif exponent(S2.f32) - exponent(S1.f32) < -150 then\nD0.f32 = sign_out ? -UNDERFLOW_F32 : UNDERFLOW_F32\nelsif exponent(S1.f32) == 255 then\nD0.f32 = sign_out ? -OVERFLOW_F32 : OVERFLOW_F32\nelse\nD0.f32 = sign_out ? -abs(S0.f32) : abs(S0.f32)\nendif",
  VOP3Op.V_DIV_FIXUP_F64: "sign_out = (sign(S1.f64) ^ sign(S2.f64));\nif isNAN(S2.f64) then\nD0.f64 = cvtToQuietNAN(S2.f64)\nelsif isNAN(S1.f64) then\nD0.f64 = cvtToQuietNAN(S1.f64)\nelsif ((S1.f64 == 0.0) && (S2.f64 == 0.0)) then\n// 0/0\nD0.f64 = 64'F(0xfff8000000000000LL)\nelsif ((abs(S1.f64) == +INF) && (abs(S2.f64) == +INF)) then\n// inf/inf\nD0.f64 = 64'F(0xfff8000000000000LL)\nelsif ((S1.f64 == 0.0) || (abs(S2.f64) == +INF)) then\n// x/0, or inf/y\nD0.f64 = sign_out ? -INF : +INF\nelsif ((abs(S1.f64) == +INF) || (S2.f64 == 0.0)) then\n// x/inf, 0/y\nD0.f64 = sign_out ? -0.0 : 0.0\nelsif exponent(S2.f64) - exponent(S1.f64) < -1075 then\nD0.f64 = sign_out ? -UNDERFLOW_F64 : UNDERFLOW_F64\nelsif exponent(S1.f64) == 2047 then\nD0.f64 = sign_out ? -OVERFLOW_F64 : OVERFLOW_F64\nelse\nD0.f64 = sign_out ? -abs(S0.f64) : abs(S0.f64)\nendif",
  VOP3Op.V_MIN3_NUM_F32: 'D0.f32 = v_min_num_f32(v_min_num_f32(S0.f32, S1.f32), S2.f32)',
  VOP3Op.V_MAX3_NUM_F32: 'D0.f32 = v_max_num_f32(v_max_num_f32(S0.f32, S1.f32), S2.f32)',
  VOP3Op.V_MIN3_NUM_F16: 'D0.f16 = v_min_num_f16(v_min_num_f16(S0.f16, S1.f16), S2.f16)',
  VOP3Op.V_MAX3_NUM_F16: 'D0.f16 = v_max_num_f16(v_max_num_f16(S0.f16, S1.f16), S2.f16)',
  VOP3Op.V_MINIMUM3_F32: 'D0.f32 = v_minimum_f32(v_minimum_f32(S0.f32, S1.f32), S2.f32)',
  VOP3Op.V_MAXIMUM3_F32: 'D0.f32 = v_maximum_f32(v_maximum_f32(S0.f32, S1.f32), S2.f32)',
  VOP3Op.V_MINIMUM3_F16: 'D0.f16 = v_minimum_f16(v_minimum_f16(S0.f16, S1.f16), S2.f16)',
  VOP3Op.V_MAXIMUM3_F16: 'D0.f16 = v_maximum_f16(v_maximum_f16(S0.f16, S1.f16), S2.f16)',
  VOP3Op.V_MED3_NUM_F32: "if (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)) || isNAN(64'F(S2.f32))) then\nD0.f32 = v_min3_num_f32(S0.f32, S1.f32, S2.f32)\nelsif v_max3_num_f32(S0.f32, S1.f32, S2.f32) == S0.f32 then\nD0.f32 = v_max_num_f32(S1.f32, S2.f32)\nelsif v_max3_num_f32(S0.f32, S1.f32, S2.f32) == S1.f32 then\nD0.f32 = v_max_num_f32(S0.f32, S2.f32)\nelse\nD0.f32 = v_max_num_f32(S0.f32, S1.f32)\nendif",
  VOP3Op.V_MED3_NUM_F16: "if (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)) || isNAN(64'F(S2.f16))) then\nD0.f16 = v_min3_num_f16(S0.f16, S1.f16, S2.f16)\nelsif v_max3_num_f16(S0.f16, S1.f16, S2.f16) == S0.f16 then\nD0.f16 = v_max_num_f16(S1.f16, S2.f16)\nelsif v_max3_num_f16(S0.f16, S1.f16, S2.f16) == S1.f16 then\nD0.f16 = v_max_num_f16(S0.f16, S2.f16)\nelse\nD0.f16 = v_max_num_f16(S0.f16, S1.f16)\nendif",
  VOP3Op.V_DIV_FMAS_F32: 'if VCC.u64[laneId] then\nD0.f32 = 2.0F ** 32 * fma(S0.f32, S1.f32, S2.f32)\nelse\nD0.f32 = fma(S0.f32, S1.f32, S2.f32)\nendif',
  VOP3Op.V_DIV_FMAS_F64: 'if VCC.u64[laneId] then\nD0.f64 = 2.0 ** 64 * fma(S0.f64, S1.f64, S2.f64)\nelse\nD0.f64 = fma(S0.f64, S1.f64, S2.f64)\nendif',
  VOP3Op.V_MSAD_U8: "ABSDIFF = lambda(x, y) (\nx > y ? x - y : y - x);\n// UNSIGNED comparison\ntmp = S2.u32;\ntmp += S1.u32[7 : 0] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[7 : 0], S1.u32[7 : 0]));\ntmp += S1.u32[15 : 8] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[15 : 8], S1.u32[15 : 8]));\ntmp += S1.u32[23 : 16] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[23 : 16], S1.u32[23 : 16]));\ntmp += S1.u32[31 : 24] == 8'0U ? 0U : 32'U(ABSDIFF(S0.u32[31 : 24], S1.u32[31 : 24]));\nD0.u32 = tmp",
  VOP3Op.V_QSAD_PK_U16_U8: "tmp[63 : 48] = 16'B(v_sad_u8(S0[55 : 24], S1[31 : 0], S2[63 : 48].u32));\ntmp[47 : 32] = 16'B(v_sad_u8(S0[47 : 16], S1[31 : 0], S2[47 : 32].u32));\ntmp[31 : 16] = 16'B(v_sad_u8(S0[39 : 8], S1[31 : 0], S2[31 : 16].u32));\ntmp[15 : 0] = 16'B(v_sad_u8(S0[31 : 0], S1[31 : 0], S2[15 : 0].u32));\nD0.b64 = tmp.b64",
  VOP3Op.V_MQSAD_PK_U16_U8: "tmp[63 : 48] = 16'B(v_msad_u8(S0[55 : 24], S1[31 : 0], S2[63 : 48].u32));\ntmp[47 : 32] = 16'B(v_msad_u8(S0[47 : 16], S1[31 : 0], S2[47 : 32].u32));\ntmp[31 : 16] = 16'B(v_msad_u8(S0[39 : 8], S1[31 : 0], S2[31 : 16].u32));\ntmp[15 : 0] = 16'B(v_msad_u8(S0[31 : 0], S1[31 : 0], S2[15 : 0].u32));\nD0.b64 = tmp.b64",
  VOP3Op.V_MQSAD_U32_U8: "tmp[127 : 96] = 32'B(v_msad_u8(S0[55 : 24], S1[31 : 0], S2[127 : 96].u32));\ntmp[95 : 64] = 32'B(v_msad_u8(S0[47 : 16], S1[31 : 0], S2[95 : 64].u32));\ntmp[63 : 32] = 32'B(v_msad_u8(S0[39 : 8], S1[31 : 0], S2[63 : 32].u32));\ntmp[31 : 0] = 32'B(v_msad_u8(S0[31 : 0], S1[31 : 0], S2[31 : 0].u32));\nD0.b128 = tmp.b128",
  VOP3Op.V_XOR3_B32: 'D0.u32 = (S0.u32 ^ S1.u32 ^ S2.u32)',
  VOP3Op.V_MAD_U16: 'D0.u16 = S0.u16 * S1.u16 + S2.u16',
  VOP3Op.V_PERM_B32: "BYTE_PERMUTE = lambda(data, sel) (\ndeclare in : 8'B[8];\nfor i in 0 : 7 do\nin[i] = data[i * 8 + 7 : i * 8].b8\nendfor;\nif sel.u32 >= 13U then\nreturn 8'0xff\nelsif sel.u32 == 12U then\nreturn 8'0x0\nelsif sel.u32 == 11U then\nreturn in[7][7].b8 * 8'0xff\nelsif sel.u32 == 10U then\nreturn in[5][7].b8 * 8'0xff\nelsif sel.u32 == 9U then\nreturn in[3][7].b8 * 8'0xff\nelsif sel.u32 == 8U then\nreturn in[1][7].b8 * 8'0xff\nelse\nreturn in[sel]\nendif);\nD0[31 : 24] = BYTE_PERMUTE({ S0.u32, S1.u32 }, S2.u32[31 : 24]);\nD0[23 : 16] = BYTE_PERMUTE({ S0.u32, S1.u32 }, S2.u32[23 : 16]);\nD0[15 : 8] = BYTE_PERMUTE({ S0.u32, S1.u32 }, S2.u32[15 : 8]);\nD0[7 : 0] = BYTE_PERMUTE({ S0.u32, S1.u32 }, S2.u32[7 : 0])",
  VOP3Op.V_XAD_U32: 'D0.u32 = (S0.u32 ^ S1.u32) + S2.u32',
  VOP3Op.V_LSHL_ADD_U32: 'D0.u32 = (S0.u32 << S1.u32[4 : 0].u32) + S2.u32',
  VOP3Op.V_ADD_LSHL_U32: 'D0.u32 = ((S0.u32 + S1.u32) << S2.u32[4 : 0].u32)',
  VOP3Op.V_FMA_F16: 'D0.f16 = fma(S0.f16, S1.f16, S2.f16)',
  VOP3Op.V_MIN3_I16: 'D0.i16 = v_min_i16(v_min_i16(S0.i16, S1.i16), S2.i16)',
  VOP3Op.V_MIN3_U16: 'D0.u16 = v_min_u16(v_min_u16(S0.u16, S1.u16), S2.u16)',
  VOP3Op.V_MAX3_I16: 'D0.i16 = v_max_i16(v_max_i16(S0.i16, S1.i16), S2.i16)',
  VOP3Op.V_MAX3_U16: 'D0.u16 = v_max_u16(v_max_u16(S0.u16, S1.u16), S2.u16)',
  VOP3Op.V_MED3_I16: 'if v_max3_i16(S0.i16, S1.i16, S2.i16) == S0.i16 then\nD0.i16 = v_max_i16(S1.i16, S2.i16)\nelsif v_max3_i16(S0.i16, S1.i16, S2.i16) == S1.i16 then\nD0.i16 = v_max_i16(S0.i16, S2.i16)\nelse\nD0.i16 = v_max_i16(S0.i16, S1.i16)\nendif',
  VOP3Op.V_MED3_U16: 'if v_max3_u16(S0.u16, S1.u16, S2.u16) == S0.u16 then\nD0.u16 = v_max_u16(S1.u16, S2.u16)\nelsif v_max3_u16(S0.u16, S1.u16, S2.u16) == S1.u16 then\nD0.u16 = v_max_u16(S0.u16, S2.u16)\nelse\nD0.u16 = v_max_u16(S0.u16, S1.u16)\nendif',
  VOP3Op.V_MAD_I16: 'D0.i16 = S0.i16 * S1.i16 + S2.i16',
  VOP3Op.V_DIV_FIXUP_F16: "sign_out = (sign(S1.f16) ^ sign(S2.f16));\nif isNAN(64'F(S2.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S2.f16)))\nelsif isNAN(64'F(S1.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nelsif ((64'F(S1.f16) == 0.0) && (64'F(S2.f16) == 0.0)) then\n// 0/0\nD0.f16 = 16'F(0xfe00)\nelsif ((64'F(abs(S1.f16)) == +INF) && (64'F(abs(S2.f16)) == +INF)) then\n// inf/inf\nD0.f16 = 16'F(0xfe00)\nelsif ((64'F(S1.f16) == 0.0) || (64'F(abs(S2.f16)) == +INF)) then\n// x/0, or inf/y\nD0.f16 = sign_out ? -INF.f16 : +INF.f16\nelsif ((64'F(abs(S1.f16)) == +INF) || (64'F(S2.f16) == 0.0)) then\n// x/inf, 0/y\nD0.f16 = sign_out ? -16'0.0 : 16'0.0\nelse\nD0.f16 = sign_out ? -abs(S0.f16) : abs(S0.f16)\nendif",
  VOP3Op.V_ADD3_U32: 'D0.u32 = S0.u32 + S1.u32 + S2.u32',
  VOP3Op.V_LSHL_OR_B32: 'D0.u32 = ((S0.u32 << S1.u32[4 : 0].u32) | S2.u32)',
  VOP3Op.V_AND_OR_B32: 'D0.u32 = ((S0.u32 & S1.u32) | S2.u32)',
  VOP3Op.V_OR3_B32: 'D0.u32 = (S0.u32 | S1.u32 | S2.u32)',
  VOP3Op.V_MAD_U32_U16: "D0.u32 = 32'U(S0.u16) * 32'U(S1.u16) + S2.u32",
  VOP3Op.V_MAD_I32_I16: "D0.i32 = 32'I(S0.i16) * 32'I(S1.i16) + S2.i32",
  VOP3Op.V_PERMLANE16_B32: "declare tmp : 32'B[64];\nlanesel = { S2.u32, S1.u32 };\n// Concatenate lane select bits\nfor i in 0 : WAVE32 ? 31 : 63 do\n// Copy original S0 in case D==S0\ntmp[i] = VGPR[i][SRC0.u32]\nendfor;\nfor row in 0 : WAVE32 ? 1 : 3 do\n// Implement arbitrary swizzle within each row\nfor i in 0 : 15 do\nif EXEC[row * 16 + i].u1 then\nVGPR[row * 16 + i][VDST.u32] = tmp[64'B(row * 16) + lanesel[i * 4 + 3 : i * 4]]\nendif\nendfor\nendfor",
  VOP3Op.V_PERMLANEX16_B32: "declare tmp : 32'B[64];\nlanesel = { S2.u32, S1.u32 };\n// Concatenate lane select bits\nfor i in 0 : WAVE32 ? 31 : 63 do\n// Copy original S0 in case D==S0\ntmp[i] = VGPR[i][SRC0.u32]\nendfor;\nfor row in 0 : WAVE32 ? 1 : 3 do\n// Implement arbitrary swizzle across two rows\naltrow = { row[1], ~row[0] };\n// 1<->0, 3<->2\nfor i in 0 : 15 do\nif EXEC[row * 16 + i].u1 then\nVGPR[row * 16 + i][VDST.u32] = tmp[64'B(altrow.i32 * 16) + lanesel[i * 4 + 3 : i * 4]]\nendif\nendfor\nendfor",
  VOP3Op.V_CNDMASK_B16: 'D0.u16 = VCC.u64[laneId] ? S1.u16 : S0.u16',
  VOP3Op.V_MAXMIN_U32: 'D0.u32 = v_min_u32(v_max_u32(S0.u32, S1.u32), S2.u32)',
  VOP3Op.V_MINMAX_U32: 'D0.u32 = v_max_u32(v_min_u32(S0.u32, S1.u32), S2.u32)',
  VOP3Op.V_MAXMIN_I32: 'D0.i32 = v_min_i32(v_max_i32(S0.i32, S1.i32), S2.i32)',
  VOP3Op.V_MINMAX_I32: 'D0.i32 = v_max_i32(v_min_i32(S0.i32, S1.i32), S2.i32)',
  VOP3Op.V_DOT2_F16_F16: 'tmp = S2.f16;\ntmp += S0[15 : 0].f16 * S1[15 : 0].f16;\ntmp += S0[31 : 16].f16 * S1[31 : 16].f16;\nD0.f16 = tmp',
  VOP3Op.V_DOT2_BF16_BF16: 'tmp = S2.bf16;\ntmp += S0[15 : 0].bf16 * S1[15 : 0].bf16;\ntmp += S0[31 : 16].bf16 * S1[31 : 16].bf16;\nD0.bf16 = tmp',
  VOP3Op.V_MINMAX_NUM_F32: 'D0.f32 = v_max_num_f32(v_min_num_f32(S0.f32, S1.f32), S2.f32)',
  VOP3Op.V_MAXMIN_NUM_F32: 'D0.f32 = v_min_num_f32(v_max_num_f32(S0.f32, S1.f32), S2.f32)',
  VOP3Op.V_MINMAX_NUM_F16: 'D0.f16 = v_max_num_f16(v_min_num_f16(S0.f16, S1.f16), S2.f16)',
  VOP3Op.V_MAXMIN_NUM_F16: 'D0.f16 = v_min_num_f16(v_max_num_f16(S0.f16, S1.f16), S2.f16)',
  VOP3Op.V_MINIMUMMAXIMUM_F32: 'D0.f32 = v_maximum_f32(v_minimum_f32(S0.f32, S1.f32), S2.f32)',
  VOP3Op.V_MAXIMUMMINIMUM_F32: 'D0.f32 = v_minimum_f32(v_maximum_f32(S0.f32, S1.f32), S2.f32)',
  VOP3Op.V_MINIMUMMAXIMUM_F16: 'D0.f16 = v_maximum_f16(v_minimum_f16(S0.f16, S1.f16), S2.f16)',
  VOP3Op.V_MAXIMUMMINIMUM_F16: 'D0.f16 = v_minimum_f16(v_maximum_f16(S0.f16, S1.f16), S2.f16)',
  VOP3Op.V_S_EXP_F32: 'D0.f32 = pow(2.0F, S0.f32)',
  VOP3Op.V_S_EXP_F16: "D0.f16 = pow(16'2.0, S0.f16);\nD0[31 : 16] = 16'0x0",
  VOP3Op.V_S_LOG_F32: 'D0.f32 = log2(S0.f32)',
  VOP3Op.V_S_LOG_F16: "D0.f16 = log2(S0.f16);\nD0[31 : 16] = 16'0x0",
  VOP3Op.V_S_RCP_F32: 'D0.f32 = 1.0F / S0.f32',
  VOP3Op.V_S_RCP_F16: "D0.f16 = 16'1.0 / S0.f16;\nD0[31 : 16] = 16'0x0",
  VOP3Op.V_S_RSQ_F32: 'D0.f32 = 1.0F / sqrt(S0.f32)',
  VOP3Op.V_S_RSQ_F16: "D0.f16 = 16'1.0 / sqrt(S0.f16);\nD0[31 : 16] = 16'0x0",
  VOP3Op.V_S_SQRT_F32: 'D0.f32 = sqrt(S0.f32)',
  VOP3Op.V_S_SQRT_F16: "D0.f16 = sqrt(S0.f16);\nD0[31 : 16] = 16'0x0",
  VOP3Op.V_ADD_NC_U16: 'D0.u16 = S0.u16 + S1.u16',
  VOP3Op.V_SUB_NC_U16: 'D0.u16 = S0.u16 - S1.u16',
  VOP3Op.V_MUL_LO_U16: 'D0.u16 = S0.u16 * S1.u16',
  VOP3Op.V_CVT_PK_I16_F32: "declare tmp : 32'B;\ntmp[31 : 16] = 16'B(v_cvt_i16_f32(S1.f32));\ntmp[15 : 0] = 16'B(v_cvt_i16_f32(S0.f32));\nD0 = tmp.b32",
  VOP3Op.V_CVT_PK_U16_F32: "declare tmp : 32'B;\ntmp[31 : 16] = 16'B(v_cvt_u16_f32(S1.f32));\ntmp[15 : 0] = 16'B(v_cvt_u16_f32(S0.f32));\nD0 = tmp.b32",
  VOP3Op.V_MAX_U16: 'D0.u16 = S0.u16 >= S1.u16 ? S0.u16 : S1.u16',
  VOP3Op.V_MAX_I16: 'D0.i16 = S0.i16 >= S1.i16 ? S0.i16 : S1.i16',
  VOP3Op.V_MIN_U16: 'D0.u16 = S0.u16 < S1.u16 ? S0.u16 : S1.u16',
  VOP3Op.V_MIN_I16: 'D0.i16 = S0.i16 < S1.i16 ? S0.i16 : S1.i16',
  VOP3Op.V_ADD_NC_I16: 'D0.i16 = S0.i16 + S1.i16',
  VOP3Op.V_SUB_NC_I16: 'D0.i16 = S0.i16 - S1.i16',
  VOP3Op.V_PERMLANE16_VAR_B32: "declare tmp : 32'B[64];\nfor i in 0 : WAVE32 ? 31 : 63 do\n// Copy original S0 in case D==S0\ntmp[i] = VGPR[i][SRC0.u32]\nendfor;\nfor row in 0 : wave32.u1 ? 1 : 3 do\n// Implement arbitrary swizzle within each row\nfor i in 0 : 15 do\nlane = row * 16 + i;\nif EXEC[lane].u1 then\nVGPR[lane][VDST.u32] = tmp[row * 16 + VGPR[lane][SRC1.u32][3 : 0].i32]\nendif\nendfor\nendfor",
  VOP3Op.V_PERMLANEX16_VAR_B32: "declare tmp : 32'B[64];\nfor i in 0 : WAVE32 ? 31 : 63 do\n// Copy original S0 in case D==S0\ntmp[i] = VGPR[i][SRC0.u32]\nendfor;\nfor row in 0 : wave32.u1 ? 1 : 3 do\n// Implement arbitrary swizzle across two rows\naltrow = { row[1], ~row[0] };\n// 1<->0, 3<->2\nfor i in 0 : 15 do\nlane = row * 16 + i;\nif EXEC[lane].u1 then\nVGPR[lane][VDST.u32] = tmp[altrow.i32 * 16 + VGPR[lane][SRC1.u32][3 : 0].i32]\nendif\nendfor\nendfor",
  VOP3Op.V_PACK_B32_F16: 'D0[31 : 16].f16 = S1.f16;\nD0[15 : 0].f16 = S0.f16',
  VOP3Op.V_CVT_PK_NORM_I16_F16: "declare tmp : 32'B;\ntmp[15 : 0].i16 = f16_to_snorm(S0.f16);\ntmp[31 : 16].i16 = f16_to_snorm(S1.f16);\nD0 = tmp.b32",
  VOP3Op.V_CVT_PK_NORM_U16_F16: "declare tmp : 32'B;\ntmp[15 : 0].u16 = f16_to_unorm(S0.f16);\ntmp[31 : 16].u16 = f16_to_unorm(S1.f16);\nD0 = tmp.b32",
  VOP3Op.V_LDEXP_F32: 'D0.f32 = S0.f32 * 2.0F ** S1.i32',
  VOP3Op.V_BFM_B32: 'D0.u32 = (((1U << S0[4 : 0].u32) - 1U) << S1[4 : 0].u32)',
  VOP3Op.V_BCNT_U32_B32: "tmp = S1.u32;\nfor i in 0 : 31 do\ntmp += S0[i].u32;\n// count i'th bit\nendfor;\nD0.u32 = tmp",
  VOP3Op.V_MBCNT_LO_U32_B32: "ThreadMask = (1LL << laneId.u32) - 1LL;\nMaskedValue = (S0.u32 & ThreadMask[31 : 0].u32);\ntmp = S1.u32;\nfor i in 0 : 31 do\ntmp += MaskedValue[i] == 1'1U ? 1U : 0U\nendfor;\nD0.u32 = tmp",
  VOP3Op.V_MBCNT_HI_U32_B32: "ThreadMask = (1LL << laneId.u32) - 1LL;\nMaskedValue = (S0.u32 & ThreadMask[63 : 32].u32);\ntmp = S1.u32;\nfor i in 0 : 31 do\ntmp += MaskedValue[i] == 1'1U ? 1U : 0U\nendfor;\nD0.u32 = tmp",
  VOP3Op.V_CVT_PK_NORM_I16_F32: "declare tmp : 32'B;\ntmp[15 : 0].i16 = f32_to_snorm(S0.f32);\ntmp[31 : 16].i16 = f32_to_snorm(S1.f32);\nD0 = tmp.b32",
  VOP3Op.V_CVT_PK_NORM_U16_F32: "declare tmp : 32'B;\ntmp[15 : 0].u16 = f32_to_unorm(S0.f32);\ntmp[31 : 16].u16 = f32_to_unorm(S1.f32);\nD0 = tmp.b32",
  VOP3Op.V_CVT_PK_U16_U32: "declare tmp : 32'B;\ntmp[15 : 0].u16 = u32_to_u16(S0.u32);\ntmp[31 : 16].u16 = u32_to_u16(S1.u32);\nD0 = tmp.b32",
  VOP3Op.V_CVT_PK_I16_I32: "declare tmp : 32'B;\ntmp[15 : 0].i16 = i32_to_i16(S0.i32);\ntmp[31 : 16].i16 = i32_to_i16(S1.i32);\nD0 = tmp.b32",
  VOP3Op.V_SUB_NC_I32: 'D0.i32 = S0.i32 - S1.i32',
  VOP3Op.V_ADD_NC_I32: 'D0.i32 = S0.i32 + S1.i32',
  VOP3Op.V_LDEXP_F64: 'D0.f64 = S0.f64 * 2.0 ** S1.i32',
  VOP3Op.V_MUL_LO_U32: 'D0.u32 = S0.u32 * S1.u32',
  VOP3Op.V_MUL_HI_U32: "D0.u32 = 32'U((64'U(S0.u32) * 64'U(S1.u32)) >> 32U)",
  VOP3Op.V_MUL_HI_I32: "D0.i32 = 32'I((64'I(S0.i32) * 64'I(S1.i32)) >> 32U)",
  VOP3Op.V_TRIG_PREOP_F64: "shift = 32'I(S1[4 : 0].u32) * 53;\nif exponent(S0.f64) > 1077 then\nshift += exponent(S0.f64) - 1077\nendif;\n// (2.0/PI) == 0.{b_1200, b_1199, b_1198, ..., b_1, b_0}\n// b_1200 is the MSB of the fractional part of 2.0/PI\n// Left shift operation indicates which bits are brought\n// into the whole part of the number.\n// Only whole part of result is kept.\nresult = 64'F((1201'B(2.0 / PI)[1200 : 0] << shift.u32) & 1201'0x1fffffffffffff);\nscale = -53 - shift;\nif exponent(S0.f64) >= 1968 then\nscale += 128\nendif;\nD0.f64 = ldexp(result, scale)",
  VOP3Op.V_LSHLREV_B16: 'D0.u16 = (S1.u16 << S0[3 : 0].u32)',
  VOP3Op.V_LSHRREV_B16: 'D0.u16 = (S1.u16 >> S0[3 : 0].u32)',
  VOP3Op.V_ASHRREV_I16: 'D0.i16 = (S1.i16 >> S0[3 : 0].u32)',
  VOP3Op.V_LSHRREV_B64: 'D0.u64 = (S1.u64 >> S0[5 : 0].u32)',
  VOP3Op.V_ASHRREV_I64: 'D0.i64 = (S1.i64 >> S0[5 : 0].u32)',
  VOP3Op.V_MINIMUM_F64: 'if (isSignalNAN(S0.f64) || isSignalNAN(S1.f64)) then\nTRAPSTS.INVALID = 1\nendif;\nif isSignalNAN(S0.f64) then\nD0.f64 = cvtToQuietNAN(S0.f64)\nelsif isSignalNAN(S1.f64) then\nD0.f64 = cvtToQuietNAN(S1.f64)\nelsif isQuietNAN(S0.f64) then\nD0.f64 = S0.f64\nelsif isQuietNAN(S1.f64) then\nD0.f64 = S1.f64\nelsif ((S0.f64 < S1.f64) || ((abs(S0.f64) == 0.0) && (abs(S1.f64) == 0.0) && sign(S0.f64) &&\n!sign(S1.f64))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f64 = S0.f64\nelse\nD0.f64 = S1.f64\nendif',
  VOP3Op.V_MAXIMUM_F64: 'if (isSignalNAN(S0.f64) || isSignalNAN(S1.f64)) then\nTRAPSTS.INVALID = 1\nendif;\nif isSignalNAN(S0.f64) then\nD0.f64 = cvtToQuietNAN(S0.f64)\nelsif isSignalNAN(S1.f64) then\nD0.f64 = cvtToQuietNAN(S1.f64)\nelsif isQuietNAN(S0.f64) then\nD0.f64 = S0.f64\nelsif isQuietNAN(S1.f64) then\nD0.f64 = S1.f64\nelsif ((S0.f64 > S1.f64) || ((abs(S0.f64) == 0.0) && (abs(S1.f64) == 0.0) && !sign(S0.f64) &&\nsign(S1.f64))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f64 = S0.f64\nelse\nD0.f64 = S1.f64\nendif',
  VOP3Op.V_READLANE_B32: "declare lane : 32'U;\nif WAVE32 then\nlane = S1.u32[4 : 0].u32;\n// Lane select for wave32\nelse\nlane = S1.u32[5 : 0].u32;\n// Lane select for wave64\nendif;\nD0.b32 = VGPR[lane][SRC0.u32]",
  VOP3Op.V_WRITELANE_B32: "declare lane : 32'U;\nif WAVE32 then\nlane = S1.u32[4 : 0].u32;\n// Lane select for wave32\nelse\nlane = S1.u32[5 : 0].u32;\n// Lane select for wave64\nendif;\nVGPR[lane][VDST.u32] = S0.b32",
  VOP3Op.V_AND_B16: 'D0.u16 = (S0.u16 & S1.u16)',
  VOP3Op.V_OR_B16: 'D0.u16 = (S0.u16 | S1.u16)',
  VOP3Op.V_XOR_B16: 'D0.u16 = (S0.u16 ^ S1.u16)',
  VOP3Op.V_MINIMUM_F32: "if (isSignalNAN(64'F(S0.f32)) || isSignalNAN(64'F(S1.f32))) then\nTRAPSTS.INVALID = 1\nendif;\nif isSignalNAN(64'F(S0.f32)) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nelsif isSignalNAN(64'F(S1.f32)) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))\nelsif isQuietNAN(64'F(S0.f32)) then\nD0.f32 = S0.f32\nelsif isQuietNAN(64'F(S1.f32)) then\nD0.f32 = S1.f32\nelsif ((S0.f32 < S1.f32) || ((abs(S0.f32) == 0.0F) && (abs(S1.f32) == 0.0F) && sign(S0.f32) &&\n!sign(S1.f32))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f32 = S0.f32\nelse\nD0.f32 = S1.f32\nendif",
  VOP3Op.V_MAXIMUM_F32: "if (isSignalNAN(64'F(S0.f32)) || isSignalNAN(64'F(S1.f32))) then\nTRAPSTS.INVALID = 1\nendif;\nif isSignalNAN(64'F(S0.f32)) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nelsif isSignalNAN(64'F(S1.f32)) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S1.f32)))\nelsif isQuietNAN(64'F(S0.f32)) then\nD0.f32 = S0.f32\nelsif isQuietNAN(64'F(S1.f32)) then\nD0.f32 = S1.f32\nelsif ((S0.f32 > S1.f32) || ((abs(S0.f32) == 0.0F) && (abs(S1.f32) == 0.0F) && !sign(S0.f32) &&\nsign(S1.f32))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f32 = S0.f32\nelse\nD0.f32 = S1.f32\nendif",
  VOP3Op.V_MINIMUM_F16: "if (isSignalNAN(64'F(S0.f16)) || isSignalNAN(64'F(S1.f16))) then\nTRAPSTS.INVALID = 1\nendif;\nif isSignalNAN(64'F(S0.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nelsif isSignalNAN(64'F(S1.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nelsif isQuietNAN(64'F(S0.f16)) then\nD0.f16 = S0.f16\nelsif isQuietNAN(64'F(S1.f16)) then\nD0.f16 = S1.f16\nelsif ((S0.f16 < S1.f16) || ((abs(S0.f16) == 16'0.0) && (abs(S1.f16) == 16'0.0) && sign(S0.f16) &&\n!sign(S1.f16))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif",
  VOP3Op.V_MAXIMUM_F16: "if (isSignalNAN(64'F(S0.f16)) || isSignalNAN(64'F(S1.f16))) then\nTRAPSTS.INVALID = 1\nendif;\nif isSignalNAN(64'F(S0.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S0.f16)))\nelsif isSignalNAN(64'F(S1.f16)) then\nD0.f16 = 16'F(cvtToQuietNAN(64'F(S1.f16)))\nelsif isQuietNAN(64'F(S0.f16)) then\nD0.f16 = S0.f16\nelsif isQuietNAN(64'F(S1.f16)) then\nD0.f16 = S1.f16\nelsif ((S0.f16 > S1.f16) || ((abs(S0.f16) == 16'0.0) && (abs(S1.f16) == 16'0.0) && !sign(S0.f16) &&\nsign(S1.f16))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f16 = S0.f16\nelse\nD0.f16 = S1.f16\nendif",
  VOP3Op.V_CVT_PK_FP8_F32: 'prev_mode = ROUND_MODE;\nROUND_MODE = ROUND_NEAREST_EVEN;\nif OPSEL[3].u32 == 0U then\nVGPR[laneId][VDST.u32][15 : 0].b16 = { f32_to_fp8(S1.f32), f32_to_fp8(S0.f32) };\n// D0[31:16] are preserved\nelse\nVGPR[laneId][VDST.u32][31 : 16].b16 = { f32_to_fp8(S1.f32), f32_to_fp8(S0.f32) };\n// D0[15:0] are preserved\nendif;\nROUND_MODE = prev_mode',
  VOP3Op.V_CVT_PK_BF8_F32: 'prev_mode = ROUND_MODE;\nROUND_MODE = ROUND_NEAREST_EVEN;\nif OPSEL[3].u32 == 0U then\nVGPR[laneId][VDST.u32][15 : 0].b16 = { f32_to_bf8(S1.f32), f32_to_bf8(S0.f32) };\n// D0[31:16] are preserved\nelse\nVGPR[laneId][VDST.u32][31 : 16].b16 = { f32_to_bf8(S1.f32), f32_to_bf8(S0.f32) };\n// D0[15:0] are preserved\nendif;\nROUND_MODE = prev_mode',
  VOP3Op.V_CVT_SR_FP8_F32: "prev_mode = ROUND_MODE;\nROUND_MODE = ROUND_NEAREST_EVEN;\ns = sign(S0.f32);\ne = exponent(S0.f32);\nm = 23'U(32'U(23'B(mantissa(S0.f32))) + S1[31 : 12].u32);\ntmp = float32(s, e, m);\n// Add stochastic value to mantissa, wrap around on overflow\nif OPSEL[3 : 2].u2 == 2'0U then\nVGPR[laneId][VDST.u32][7 : 0].fp8 = f32_to_fp8(tmp.f32)\nelsif OPSEL[3 : 2].u2 == 2'1U then\nVGPR[laneId][VDST.u32][15 : 8].fp8 = f32_to_fp8(tmp.f32)\nelsif OPSEL[3 : 2].u2 == 2'2U then\nVGPR[laneId][VDST.u32][23 : 16].fp8 = f32_to_fp8(tmp.f32)\nelse\nVGPR[laneId][VDST.u32][31 : 24].fp8 = f32_to_fp8(tmp.f32)\nendif;\n// Unwritten bytes of D are preserved.\nROUND_MODE = prev_mode",
  VOP3Op.V_CVT_SR_BF8_F32: "prev_mode = ROUND_MODE;\nROUND_MODE = ROUND_NEAREST_EVEN;\ns = sign(S0.f32);\ne = exponent(S0.f32);\nm = 23'U(32'U(23'B(mantissa(S0.f32))) + S1[31 : 11].u32);\ntmp = float32(s, e, m);\n// Add stochastic value to mantissa, wrap around on overflow\nif OPSEL[3 : 2].u2 == 2'0U then\nVGPR[laneId][VDST.u32][7 : 0].bf8 = f32_to_bf8(tmp.f32)\nelsif OPSEL[3 : 2].u2 == 2'1U then\nVGPR[laneId][VDST.u32][15 : 8].bf8 = f32_to_bf8(tmp.f32)\nelsif OPSEL[3 : 2].u2 == 2'2U then\nVGPR[laneId][VDST.u32][23 : 16].bf8 = f32_to_bf8(tmp.f32)\nelse\nVGPR[laneId][VDST.u32][31 : 24].bf8 = f32_to_bf8(tmp.f32)\nendif;\n// Unwritten bytes of D are preserved.\nROUND_MODE = prev_mode",
  VOP3POp.V_PK_MAD_I16: "declare tmp : 32'B;\ntmp[15 : 0].i16 = S0[15 : 0].i16 * S1[15 : 0].i16 + S2[15 : 0].i16;\ntmp[31 : 16].i16 = S0[31 : 16].i16 * S1[31 : 16].i16 + S2[31 : 16].i16;\nD0.b32 = tmp",
  VOP3POp.V_PK_MUL_LO_U16: 'tmp[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16;\ntmp[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16;\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_ADD_I16: "declare tmp : 32'B;\ntmp[15 : 0].i16 = S0[15 : 0].i16 + S1[15 : 0].i16;\ntmp[31 : 16].i16 = S0[31 : 16].i16 + S1[31 : 16].i16;\nD0.b32 = tmp",
  VOP3POp.V_PK_SUB_I16: "declare tmp : 32'B;\ntmp[15 : 0].i16 = S0[15 : 0].i16 - S1[15 : 0].i16;\ntmp[31 : 16].i16 = S0[31 : 16].i16 - S1[31 : 16].i16;\nD0.b32 = tmp",
  VOP3POp.V_PK_LSHLREV_B16: 'tmp[31 : 16].u16 = (S1[31 : 16].u16 << S0.u32[19 : 16].u32);\ntmp[15 : 0].u16 = (S1[15 : 0].u16 << S0.u32[3 : 0].u32);\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_LSHRREV_B16: 'tmp[31 : 16].u16 = (S1[31 : 16].u16 >> S0.u32[19 : 16].u32);\ntmp[15 : 0].u16 = (S1[15 : 0].u16 >> S0.u32[3 : 0].u32);\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_ASHRREV_I16: 'tmp[31 : 16].i16 = (S1[31 : 16].i16 >> S0.u32[19 : 16].u32);\ntmp[15 : 0].i16 = (S1[15 : 0].i16 >> S0.u32[3 : 0].u32);\nD0.b32 = tmp.b32',
  VOP3POp.V_PK_MAX_I16: "declare tmp : 32'B;\ntmp[15 : 0].i16 = S0[15 : 0].i16 >= S1[15 : 0].i16 ? S0[15 : 0].i16 : S1[15 : 0].i16;\ntmp[31 : 16].i16 = S0[31 : 16].i16 >= S1[31 : 16].i16 ? S0[31 : 16].i16 : S1[31 : 16].i16;\nD0.b32 = tmp",
  VOP3POp.V_PK_MIN_I16: "declare tmp : 32'B;\ntmp[15 : 0].i16 = S0[15 : 0].i16 < S1[15 : 0].i16 ? S0[15 : 0].i16 : S1[15 : 0].i16;\ntmp[31 : 16].i16 = S0[31 : 16].i16 < S1[31 : 16].i16 ? S0[31 : 16].i16 : S1[31 : 16].i16;\nD0.b32 = tmp",
  VOP3POp.V_PK_MAD_U16: "declare tmp : 32'B;\ntmp[15 : 0].u16 = S0[15 : 0].u16 * S1[15 : 0].u16 + S2[15 : 0].u16;\ntmp[31 : 16].u16 = S0[31 : 16].u16 * S1[31 : 16].u16 + S2[31 : 16].u16;\nD0.b32 = tmp",
  VOP3POp.V_PK_ADD_U16: "declare tmp : 32'B;\ntmp[15 : 0].u16 = S0[15 : 0].u16 + S1[15 : 0].u16;\ntmp[31 : 16].u16 = S0[31 : 16].u16 + S1[31 : 16].u16;\nD0.b32 = tmp",
  VOP3POp.V_PK_SUB_U16: "declare tmp : 32'B;\ntmp[15 : 0].u16 = S0[15 : 0].u16 - S1[15 : 0].u16;\ntmp[31 : 16].u16 = S0[31 : 16].u16 - S1[31 : 16].u16;\nD0.b32 = tmp",
  VOP3POp.V_PK_MAX_U16: "declare tmp : 32'B;\ntmp[15 : 0].u16 = S0[15 : 0].u16 >= S1[15 : 0].u16 ? S0[15 : 0].u16 : S1[15 : 0].u16;\ntmp[31 : 16].u16 = S0[31 : 16].u16 >= S1[31 : 16].u16 ? S0[31 : 16].u16 : S1[31 : 16].u16;\nD0.b32 = tmp",
  VOP3POp.V_PK_MIN_U16: "declare tmp : 32'B;\ntmp[15 : 0].u16 = S0[15 : 0].u16 < S1[15 : 0].u16 ? S0[15 : 0].u16 : S1[15 : 0].u16;\ntmp[31 : 16].u16 = S0[31 : 16].u16 < S1[31 : 16].u16 ? S0[31 : 16].u16 : S1[31 : 16].u16;\nD0.b32 = tmp",
  VOP3POp.V_PK_FMA_F16: "declare tmp : 32'B;\ntmp[15 : 0].f16 = fma(S0[15 : 0].f16, S1[15 : 0].f16, S2[15 : 0].f16);\ntmp[31 : 16].f16 = fma(S0[31 : 16].f16, S1[31 : 16].f16, S2[31 : 16].f16);\nD0.b32 = tmp",
  VOP3POp.V_PK_ADD_F16: "declare tmp : 32'B;\ntmp[15 : 0].f16 = S0[15 : 0].f16 + S1[15 : 0].f16;\ntmp[31 : 16].f16 = S0[31 : 16].f16 + S1[31 : 16].f16;\nD0.b32 = tmp",
  VOP3POp.V_PK_MUL_F16: "declare tmp : 32'B;\ntmp[15 : 0].f16 = S0[15 : 0].f16 * S1[15 : 0].f16;\ntmp[31 : 16].f16 = S0[31 : 16].f16 * S1[31 : 16].f16;\nD0.b32 = tmp",
  VOP3POp.V_DOT2_F32_F16: 'tmp = S2.f32;\ntmp += f16_to_f32(S0[15 : 0].f16) * f16_to_f32(S1[15 : 0].f16);\ntmp += f16_to_f32(S0[31 : 16].f16) * f16_to_f32(S1[31 : 16].f16);\nD0.f32 = tmp',
  VOP3POp.V_DOT4_I32_IU8: "declare A : 32'I[4];\ndeclare B : 32'I[4];\n// Figure out whether inputs are signed/unsigned.\nfor i in 0 : 3 do\nA8 = S0[i * 8 + 7 : i * 8];\nB8 = S1[i * 8 + 7 : i * 8];\nA[i] = NEG[0].u1 ? 32'I(signext(A8.i8)) : 32'I(32'U(A8.u8));\nB[i] = NEG[1].u1 ? 32'I(signext(B8.i8)) : 32'I(32'U(B8.u8))\nendfor;\nC = S2.i32;\n// Signed multiplier/adder. Extend unsigned inputs with leading 0.\ntmp = C.i32;\ntmp += A[0] * B[0];\ntmp += A[1] * B[1];\ntmp += A[2] * B[2];\ntmp += A[3] * B[3];\nD0.i32 = tmp",
  VOP3POp.V_DOT4_U32_U8: 'tmp = S2.u32;\ntmp += u8_to_u32(S0[7 : 0].u8) * u8_to_u32(S1[7 : 0].u8);\ntmp += u8_to_u32(S0[15 : 8].u8) * u8_to_u32(S1[15 : 8].u8);\ntmp += u8_to_u32(S0[23 : 16].u8) * u8_to_u32(S1[23 : 16].u8);\ntmp += u8_to_u32(S0[31 : 24].u8) * u8_to_u32(S1[31 : 24].u8);\nD0.u32 = tmp',
  VOP3POp.V_DOT8_I32_IU4: "declare A : 32'I[8];\ndeclare B : 32'I[8];\n// Figure out whether inputs are signed/unsigned.\nfor i in 0 : 7 do\nA4 = S0[i * 4 + 3 : i * 4];\nB4 = S1[i * 4 + 3 : i * 4];\nA[i] = NEG[0].u1 ? 32'I(signext(A4.i4)) : 32'I(32'U(A4.u4));\nB[i] = NEG[1].u1 ? 32'I(signext(B4.i4)) : 32'I(32'U(B4.u4))\nendfor;\nC = S2.i32;\n// Signed multiplier/adder. Extend unsigned inputs with leading 0.\ntmp = C.i32;\ntmp += A[0] * B[0];\ntmp += A[1] * B[1];\ntmp += A[2] * B[2];\ntmp += A[3] * B[3];\ntmp += A[4] * B[4];\ntmp += A[5] * B[5];\ntmp += A[6] * B[6];\ntmp += A[7] * B[7];\nD0.i32 = tmp",
  VOP3POp.V_DOT8_U32_U4: 'tmp = S2.u32;\ntmp += u4_to_u32(S0[3 : 0].u4) * u4_to_u32(S1[3 : 0].u4);\ntmp += u4_to_u32(S0[7 : 4].u4) * u4_to_u32(S1[7 : 4].u4);\ntmp += u4_to_u32(S0[11 : 8].u4) * u4_to_u32(S1[11 : 8].u4);\ntmp += u4_to_u32(S0[15 : 12].u4) * u4_to_u32(S1[15 : 12].u4);\ntmp += u4_to_u32(S0[19 : 16].u4) * u4_to_u32(S1[19 : 16].u4);\ntmp += u4_to_u32(S0[23 : 20].u4) * u4_to_u32(S1[23 : 20].u4);\ntmp += u4_to_u32(S0[27 : 24].u4) * u4_to_u32(S1[27 : 24].u4);\ntmp += u4_to_u32(S0[31 : 28].u4) * u4_to_u32(S1[31 : 28].u4);\nD0.u32 = tmp',
  VOP3POp.V_DOT2_F32_BF16: 'tmp = S2.f32;\ntmp += bf16_to_f32(S0[15 : 0].bf16) * bf16_to_f32(S1[15 : 0].bf16);\ntmp += bf16_to_f32(S0[31 : 16].bf16) * bf16_to_f32(S1[31 : 16].bf16);\nD0.f32 = tmp',
  VOP3POp.V_PK_MIN_NUM_F16: "declare tmp : 32'B;\ntmp[15 : 0].f16 = v_min_num_f16(S0[15 : 0].f16, S1[15 : 0].f16);\ntmp[31 : 16].f16 = v_min_num_f16(S0[31 : 16].f16, S1[31 : 16].f16);\nD0.b32 = tmp",
  VOP3POp.V_PK_MAX_NUM_F16: "declare tmp : 32'B;\ntmp[15 : 0].f16 = v_max_num_f16(S0[15 : 0].f16, S1[15 : 0].f16);\ntmp[31 : 16].f16 = v_max_num_f16(S0[31 : 16].f16, S1[31 : 16].f16);\nD0.b32 = tmp",
  VOP3POp.V_PK_MINIMUM_F16: "declare tmp : 32'B;\ntmp[15 : 0].f16 = v_minimum_f16(S0[15 : 0].f16, S1[15 : 0].f16);\ntmp[31 : 16].f16 = v_minimum_f16(S0[31 : 16].f16, S1[31 : 16].f16);\nD0.b32 = tmp",
  VOP3POp.V_PK_MAXIMUM_F16: "declare tmp : 32'B;\ntmp[15 : 0].f16 = v_maximum_f16(S0[15 : 0].f16, S1[15 : 0].f16);\ntmp[31 : 16].f16 = v_maximum_f16(S0[31 : 16].f16, S1[31 : 16].f16);\nD0.b32 = tmp",
  VOP3POp.V_FMA_MIX_F32: "declare in : 32'F[3];\ndeclare S : 32'B[3];\nfor i in 0 : 2 do\nif !OPSEL_HI.u3[i] then\nin[i] = S[i].f32\nelsif OPSEL.u3[i] then\nin[i] = f16_to_f32(S[i][31 : 16].f16)\nelse\nin[i] = f16_to_f32(S[i][15 : 0].f16)\nendif\nendfor;\nD0[31 : 0].f32 = fma(in[0], in[1], in[2])",
  VOP3POp.V_FMA_MIXLO_F16: "declare in : 32'F[3];\ndeclare S : 32'B[3];\nfor i in 0 : 2 do\nif !OPSEL_HI.u3[i] then\nin[i] = S[i].f32\nelsif OPSEL.u3[i] then\nin[i] = f16_to_f32(S[i][31 : 16].f16)\nelse\nin[i] = f16_to_f32(S[i][15 : 0].f16)\nendif\nendfor;\nD0[15 : 0].f16 = f32_to_f16(fma(in[0], in[1], in[2]))",
  VOP3POp.V_FMA_MIXHI_F16: "declare in : 32'F[3];\ndeclare S : 32'B[3];\nfor i in 0 : 2 do\nif !OPSEL_HI.u3[i] then\nin[i] = S[i].f32\nelsif OPSEL.u3[i] then\nin[i] = f16_to_f32(S[i][31 : 16].f16)\nelse\nin[i] = f16_to_f32(S[i][15 : 0].f16)\nendif\nendfor;\nD0[31 : 16].f16 = f32_to_f16(fma(in[0], in[1], in[2]))",
  VOP3POp.V_DOT4_F32_FP8_BF8: "tmp = S2.f32;\ntmp += 32'F(S0[7 : 0].fp8) * 32'F(S1[7 : 0].bf8);\ntmp += 32'F(S0[15 : 8].fp8) * 32'F(S1[15 : 8].bf8);\ntmp += 32'F(S0[23 : 16].fp8) * 32'F(S1[23 : 16].bf8);\ntmp += 32'F(S0[31 : 24].fp8) * 32'F(S1[31 : 24].bf8);\nD0.f32 = tmp",
  VOP3POp.V_DOT4_F32_BF8_FP8: "tmp = S2.f32;\ntmp += 32'F(S0[7 : 0].bf8) * 32'F(S1[7 : 0].fp8);\ntmp += 32'F(S0[15 : 8].bf8) * 32'F(S1[15 : 8].fp8);\ntmp += 32'F(S0[23 : 16].bf8) * 32'F(S1[23 : 16].fp8);\ntmp += 32'F(S0[31 : 24].bf8) * 32'F(S1[31 : 24].fp8);\nD0.f32 = tmp",
  VOP3POp.V_DOT4_F32_FP8_FP8: "tmp = S2.f32;\ntmp += 32'F(S0[7 : 0].fp8) * 32'F(S1[7 : 0].fp8);\ntmp += 32'F(S0[15 : 8].fp8) * 32'F(S1[15 : 8].fp8);\ntmp += 32'F(S0[23 : 16].fp8) * 32'F(S1[23 : 16].fp8);\ntmp += 32'F(S0[31 : 24].fp8) * 32'F(S1[31 : 24].fp8);\nD0.f32 = tmp",
  VOP3POp.V_DOT4_F32_BF8_BF8: "tmp = S2.f32;\ntmp += 32'F(S0[7 : 0].bf8) * 32'F(S1[7 : 0].bf8);\ntmp += 32'F(S0[15 : 8].bf8) * 32'F(S1[15 : 8].bf8);\ntmp += 32'F(S0[23 : 16].bf8) * 32'F(S1[23 : 16].bf8);\ntmp += 32'F(S0[31 : 24].bf8) * 32'F(S1[31 : 24].bf8);\nD0.f32 = tmp",
  VOP3POp.V_WMMA_F32_16X16X16_F16: 'D = A (16x16) * B (16x16) + C (16x16)',
  VOP3POp.V_WMMA_F32_16X16X16_BF16: 'D = A (16x16) * B (16x16) + C (16x16)',
  VOP3POp.V_WMMA_F16_16X16X16_F16: 'D = A (16x16) * B (16x16) + C (16x16)',
  VOP3POp.V_WMMA_BF16_16X16X16_BF16: 'D = A (16x16) * B (16x16) + C (16x16)',
  VOP3POp.V_WMMA_I32_16X16X16_IU8: 'D = A (16x16) * B (16x16) + C (16x16)',
  VOP3POp.V_WMMA_I32_16X16X16_IU4: 'D = A (16x16) * B (16x16) + C (16x16)',
  VOP3POp.V_WMMA_F32_16X16X16_FP8_FP8: 'D = A (16x16) * B (16x16) + C (16x16)',
  VOP3POp.V_WMMA_F32_16X16X16_FP8_BF8: 'D = A (16x16) * B (16x16) + C (16x16)',
  VOP3POp.V_WMMA_F32_16X16X16_BF8_FP8: 'D = A (16x16) * B (16x16) + C (16x16)',
  VOP3POp.V_WMMA_F32_16X16X16_BF8_BF8: 'D = A (16x16) * B (16x16) + C (16x16)',
  VOP3POp.V_WMMA_I32_16X16X32_IU4: 'D = A (16x32) * B (32x16) + C (16x16)',
  VOP3POp.V_SWMMAC_F32_16X16X32_F16: 'D = A (sparse 16x32) * B (32x16) + D (16x16)',
  VOP3POp.V_SWMMAC_F32_16X16X32_BF16: 'D = A (sparse 16x32) * B (32x16) + D (16x16)',
  VOP3POp.V_SWMMAC_F16_16X16X32_F16: 'D = A (sparse 16x32) * B (32x16) + D (16x16)',
  VOP3POp.V_SWMMAC_BF16_16X16X32_BF16: 'D = A (sparse 16x32) * B (32x16) + D (16x16)',
  VOP3POp.V_SWMMAC_I32_16X16X32_IU8: 'D = A (sparse 16x32) * B (32x16) + D (16x16)',
  VOP3POp.V_SWMMAC_I32_16X16X32_IU4: 'D = A (sparse 16x32) * B (32x16) + D (16x16)',
  VOP3POp.V_SWMMAC_I32_16X16X64_IU4: 'D = A (sparse 16x64) * B (64x16) + D (16x16)',
  VOP3POp.V_SWMMAC_F32_16X16X32_FP8_FP8: 'D = A (sparse 16x32) * B (32x16) + D (16x16)',
  VOP3POp.V_SWMMAC_F32_16X16X32_FP8_BF8: 'D = A (sparse 16x32) * B (32x16) + D (16x16)',
  VOP3POp.V_SWMMAC_F32_16X16X32_BF8_FP8: 'D = A (sparse 16x32) * B (32x16) + D (16x16)',
  VOP3POp.V_SWMMAC_F32_16X16X32_BF8_BF8: 'D = A (sparse 16x32) * B (32x16) + D (16x16)',
  VOP3SDOp.V_ADD_CO_CI_U32: "tmp = 64'U(S0.u32) + 64'U(S1.u32) + VCC.u64[laneId].u64;\nVCC.u64[laneId] = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_ADD_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP3SDOp.V_SUB_CO_CI_U32: "tmp = S0.u32 - S1.u32 - VCC.u64[laneId].u32;\nVCC.u64[laneId] = 64'U(S1.u32) + VCC.u64[laneId].u64 > 64'U(S0.u32) ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP3SDOp.V_SUBREV_CO_CI_U32: "tmp = S1.u32 - S0.u32 - VCC.u64[laneId].u32;\nVCC.u64[laneId] = 64'U(S0.u32) + VCC.u64[laneId].u64 > 64'U(S1.u32) ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP3SDOp.V_DIV_SCALE_F32: "VCC = 0x0LL;\nif ((64'F(S2.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then\nD0.f32 = NAN.f32\nelsif exponent(S2.f32) - exponent(S1.f32) >= 96 then\n// N/D near MAX_FLOAT_F32\nVCC = 0x1LL;\nif S0.f32 == S1.f32 then\n// Only scale the denominator\nD0.f32 = ldexp(S0.f32, 64)\nendif\nelsif S1.f32 == DENORM.f32 then\nD0.f32 = ldexp(S0.f32, 64)\nelsif ((1.0 / 64'F(S1.f32) == DENORM.f64) && (S2.f32 / S1.f32 == DENORM.f32)) then\nVCC = 0x1LL;\nif S0.f32 == S1.f32 then\n// Only scale the denominator\nD0.f32 = ldexp(S0.f32, 64)\nendif\nelsif 1.0 / 64'F(S1.f32) == DENORM.f64 then\nD0.f32 = ldexp(S0.f32, -64)\nelsif S2.f32 / S1.f32 == DENORM.f32 then\nVCC = 0x1LL;\nif S0.f32 == S2.f32 then\n// Only scale the numerator\nD0.f32 = ldexp(S0.f32, 64)\nendif\nelsif exponent(S2.f32) <= 23 then\n// Numerator is tiny\nD0.f32 = ldexp(S0.f32, 64)\nendif",
  VOP3SDOp.V_DIV_SCALE_F64: 'VCC = 0x0LL;\nif ((S2.f64 == 0.0) || (S1.f64 == 0.0)) then\nD0.f64 = NAN.f64\nelsif exponent(S2.f64) - exponent(S1.f64) >= 768 then\n// N/D near MAX_FLOAT_F64\nVCC = 0x1LL;\nif S0.f64 == S1.f64 then\n// Only scale the denominator\nD0.f64 = ldexp(S0.f64, 128)\nendif\nelsif S1.f64 == DENORM.f64 then\nD0.f64 = ldexp(S0.f64, 128)\nelsif ((1.0 / S1.f64 == DENORM.f64) && (S2.f64 / S1.f64 == DENORM.f64)) then\nVCC = 0x1LL;\nif S0.f64 == S1.f64 then\n// Only scale the denominator\nD0.f64 = ldexp(S0.f64, 128)\nendif\nelsif 1.0 / S1.f64 == DENORM.f64 then\nD0.f64 = ldexp(S0.f64, -128)\nelsif S2.f64 / S1.f64 == DENORM.f64 then\nVCC = 0x1LL;\nif S0.f64 == S2.f64 then\n// Only scale the numerator\nD0.f64 = ldexp(S0.f64, 128)\nendif\nelsif exponent(S2.f64) <= 53 then\n// Numerator is tiny\nD0.f64 = ldexp(S0.f64, 128)\nendif',
  VOP3SDOp.V_MAD_CO_U64_U32: "{ D1.u1, D0.u64 } = 65'B(65'U(S0.u32) * 65'U(S1.u32) + 65'U(S2.u64))",
  VOP3SDOp.V_MAD_CO_I64_I32: "{ D1.i1, D0.i64 } = 65'B(65'I(S0.i32) * 65'I(S1.i32) + 65'I(S2.i64))",
  VOP3SDOp.V_ADD_CO_U32: "tmp = 64'U(S0.u32) + 64'U(S1.u32);\nVCC.u64[laneId] = tmp >= 0x100000000ULL ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_ADD_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP3SDOp.V_SUB_CO_U32: "tmp = S0.u32 - S1.u32;\nVCC.u64[laneId] = S1.u32 > S0.u32 ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOP3SDOp.V_SUBREV_CO_U32: "tmp = S1.u32 - S0.u32;\nVCC.u64[laneId] = S0.u32 > S1.u32 ? 1'1U : 1'0U;\n// VCC is an UNSIGNED overflow/carry-out for V_SUB_CO_CI_U32.\nD0.u32 = tmp.u32",
  VOPCOp.V_CMP_LT_F16_E32: 'D0.u64[laneId] = S0.f16 < S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_EQ_F16_E32: 'D0.u64[laneId] = S0.f16 == S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LE_F16_E32: 'D0.u64[laneId] = S0.f16 <= S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GT_F16_E32: 'D0.u64[laneId] = S0.f16 > S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LG_F16_E32: 'D0.u64[laneId] = S0.f16 <> S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GE_F16_E32: 'D0.u64[laneId] = S0.f16 >= S1.f16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_O_F16_E32: "D0.u64[laneId] = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)));\n// D0 = VCC in VOPC encoding.",
  VOPCOp.V_CMP_U_F16_E32: "D0.u64[laneId] = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)));\n// D0 = VCC in VOPC encoding.",
  VOPCOp.V_CMP_NGE_F16_E32: 'D0.u64[laneId] = !(S0.f16 >= S1.f16);\n// With NAN inputs this is not the same operation as <\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NLG_F16_E32: 'D0.u64[laneId] = !(S0.f16 <> S1.f16);\n// With NAN inputs this is not the same operation as ==\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NGT_F16_E32: 'D0.u64[laneId] = !(S0.f16 > S1.f16);\n// With NAN inputs this is not the same operation as <=\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NLE_F16_E32: 'D0.u64[laneId] = !(S0.f16 <= S1.f16);\n// With NAN inputs this is not the same operation as >\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NEQ_F16_E32: 'D0.u64[laneId] = !(S0.f16 == S1.f16);\n// With NAN inputs this is not the same operation as !=\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NLT_F16_E32: 'D0.u64[laneId] = !(S0.f16 < S1.f16);\n// With NAN inputs this is not the same operation as >=\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LT_F32_E32: 'D0.u64[laneId] = S0.f32 < S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_EQ_F32_E32: 'D0.u64[laneId] = S0.f32 == S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LE_F32_E32: 'D0.u64[laneId] = S0.f32 <= S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GT_F32_E32: 'D0.u64[laneId] = S0.f32 > S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LG_F32_E32: 'D0.u64[laneId] = S0.f32 <> S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GE_F32_E32: 'D0.u64[laneId] = S0.f32 >= S1.f32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_O_F32_E32: "D0.u64[laneId] = (!isNAN(64'F(S0.f32)) && !isNAN(64'F(S1.f32)));\n// D0 = VCC in VOPC encoding.",
  VOPCOp.V_CMP_U_F32_E32: "D0.u64[laneId] = (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)));\n// D0 = VCC in VOPC encoding.",
  VOPCOp.V_CMP_NGE_F32_E32: 'D0.u64[laneId] = !(S0.f32 >= S1.f32);\n// With NAN inputs this is not the same operation as <\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NLG_F32_E32: 'D0.u64[laneId] = !(S0.f32 <> S1.f32);\n// With NAN inputs this is not the same operation as ==\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NGT_F32_E32: 'D0.u64[laneId] = !(S0.f32 > S1.f32);\n// With NAN inputs this is not the same operation as <=\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NLE_F32_E32: 'D0.u64[laneId] = !(S0.f32 <= S1.f32);\n// With NAN inputs this is not the same operation as >\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NEQ_F32_E32: 'D0.u64[laneId] = !(S0.f32 == S1.f32);\n// With NAN inputs this is not the same operation as !=\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NLT_F32_E32: 'D0.u64[laneId] = !(S0.f32 < S1.f32);\n// With NAN inputs this is not the same operation as >=\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LT_F64_E32: 'D0.u64[laneId] = S0.f64 < S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_EQ_F64_E32: 'D0.u64[laneId] = S0.f64 == S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LE_F64_E32: 'D0.u64[laneId] = S0.f64 <= S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GT_F64_E32: 'D0.u64[laneId] = S0.f64 > S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LG_F64_E32: 'D0.u64[laneId] = S0.f64 <> S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GE_F64_E32: 'D0.u64[laneId] = S0.f64 >= S1.f64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_O_F64_E32: 'D0.u64[laneId] = (!isNAN(S0.f64) && !isNAN(S1.f64));\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_U_F64_E32: 'D0.u64[laneId] = (isNAN(S0.f64) || isNAN(S1.f64));\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NGE_F64_E32: 'D0.u64[laneId] = !(S0.f64 >= S1.f64);\n// With NAN inputs this is not the same operation as <\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NLG_F64_E32: 'D0.u64[laneId] = !(S0.f64 <> S1.f64);\n// With NAN inputs this is not the same operation as ==\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NGT_F64_E32: 'D0.u64[laneId] = !(S0.f64 > S1.f64);\n// With NAN inputs this is not the same operation as <=\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NLE_F64_E32: 'D0.u64[laneId] = !(S0.f64 <= S1.f64);\n// With NAN inputs this is not the same operation as >\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NEQ_F64_E32: 'D0.u64[laneId] = !(S0.f64 == S1.f64);\n// With NAN inputs this is not the same operation as !=\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NLT_F64_E32: 'D0.u64[laneId] = !(S0.f64 < S1.f64);\n// With NAN inputs this is not the same operation as >=\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LT_I16_E32: 'D0.u64[laneId] = S0.i16 < S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_EQ_I16_E32: 'D0.u64[laneId] = S0.i16 == S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LE_I16_E32: 'D0.u64[laneId] = S0.i16 <= S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GT_I16_E32: 'D0.u64[laneId] = S0.i16 > S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NE_I16_E32: 'D0.u64[laneId] = S0.i16 <> S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GE_I16_E32: 'D0.u64[laneId] = S0.i16 >= S1.i16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LT_U16_E32: 'D0.u64[laneId] = S0.u16 < S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_EQ_U16_E32: 'D0.u64[laneId] = S0.u16 == S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LE_U16_E32: 'D0.u64[laneId] = S0.u16 <= S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GT_U16_E32: 'D0.u64[laneId] = S0.u16 > S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NE_U16_E32: 'D0.u64[laneId] = S0.u16 <> S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GE_U16_E32: 'D0.u64[laneId] = S0.u16 >= S1.u16;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LT_I32_E32: 'D0.u64[laneId] = S0.i32 < S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_EQ_I32_E32: 'D0.u64[laneId] = S0.i32 == S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LE_I32_E32: 'D0.u64[laneId] = S0.i32 <= S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GT_I32_E32: 'D0.u64[laneId] = S0.i32 > S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NE_I32_E32: 'D0.u64[laneId] = S0.i32 <> S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GE_I32_E32: 'D0.u64[laneId] = S0.i32 >= S1.i32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LT_U32_E32: 'D0.u64[laneId] = S0.u32 < S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_EQ_U32_E32: 'D0.u64[laneId] = S0.u32 == S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LE_U32_E32: 'D0.u64[laneId] = S0.u32 <= S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GT_U32_E32: 'D0.u64[laneId] = S0.u32 > S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NE_U32_E32: 'D0.u64[laneId] = S0.u32 <> S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GE_U32_E32: 'D0.u64[laneId] = S0.u32 >= S1.u32;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LT_I64_E32: 'D0.u64[laneId] = S0.i64 < S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_EQ_I64_E32: 'D0.u64[laneId] = S0.i64 == S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LE_I64_E32: 'D0.u64[laneId] = S0.i64 <= S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GT_I64_E32: 'D0.u64[laneId] = S0.i64 > S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NE_I64_E32: 'D0.u64[laneId] = S0.i64 <> S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GE_I64_E32: 'D0.u64[laneId] = S0.i64 >= S1.i64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LT_U64_E32: 'D0.u64[laneId] = S0.u64 < S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_EQ_U64_E32: 'D0.u64[laneId] = S0.u64 == S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_LE_U64_E32: 'D0.u64[laneId] = S0.u64 <= S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GT_U64_E32: 'D0.u64[laneId] = S0.u64 > S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_NE_U64_E32: 'D0.u64[laneId] = S0.u64 <> S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_GE_U64_E32: 'D0.u64[laneId] = S0.u64 >= S1.u64;\n// D0 = VCC in VOPC encoding.',
  VOPCOp.V_CMP_CLASS_F16_E32: "declare result : 1'U;\nif isSignalNAN(64'F(S0.f16)) then\nresult = S1.u32[0]\nelsif isQuietNAN(64'F(S0.f16)) then\nresult = S1.u32[1]\nelsif exponent(S0.f16) == 31 then\n// +-INF\nresult = S1.u32[sign(S0.f16) ? 2 : 9]\nelsif exponent(S0.f16) > 0 then\n// +-normal value\nresult = S1.u32[sign(S0.f16) ? 3 : 8]\nelsif 64'F(abs(S0.f16)) > 0.0 then\n// +-denormal value\nresult = S1.u32[sign(S0.f16) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u32[sign(S0.f16) ? 5 : 6]\nendif;\nD0.u64[laneId] = result;\n// D0 = VCC in VOPC encoding.",
  VOPCOp.V_CMP_CLASS_F32_E32: "declare result : 1'U;\nif isSignalNAN(64'F(S0.f32)) then\nresult = S1.u32[0]\nelsif isQuietNAN(64'F(S0.f32)) then\nresult = S1.u32[1]\nelsif exponent(S0.f32) == 255 then\n// +-INF\nresult = S1.u32[sign(S0.f32) ? 2 : 9]\nelsif exponent(S0.f32) > 0 then\n// +-normal value\nresult = S1.u32[sign(S0.f32) ? 3 : 8]\nelsif 64'F(abs(S0.f32)) > 0.0 then\n// +-denormal value\nresult = S1.u32[sign(S0.f32) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u32[sign(S0.f32) ? 5 : 6]\nendif;\nD0.u64[laneId] = result;\n// D0 = VCC in VOPC encoding.",
  VOPCOp.V_CMP_CLASS_F64_E32: "declare result : 1'U;\nif isSignalNAN(S0.f64) then\nresult = S1.u32[0]\nelsif isQuietNAN(S0.f64) then\nresult = S1.u32[1]\nelsif exponent(S0.f64) == 2047 then\n// +-INF\nresult = S1.u32[sign(S0.f64) ? 2 : 9]\nelsif exponent(S0.f64) > 0 then\n// +-normal value\nresult = S1.u32[sign(S0.f64) ? 3 : 8]\nelsif abs(S0.f64) > 0.0 then\n// +-denormal value\nresult = S1.u32[sign(S0.f64) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u32[sign(S0.f64) ? 5 : 6]\nendif;\nD0.u64[laneId] = result;\n// D0 = VCC in VOPC encoding.",
  VOPCOp.V_CMPX_LT_F16_E32: 'EXEC.u64[laneId] = S0.f16 < S1.f16',
  VOPCOp.V_CMPX_EQ_F16_E32: 'EXEC.u64[laneId] = S0.f16 == S1.f16',
  VOPCOp.V_CMPX_LE_F16_E32: 'EXEC.u64[laneId] = S0.f16 <= S1.f16',
  VOPCOp.V_CMPX_GT_F16_E32: 'EXEC.u64[laneId] = S0.f16 > S1.f16',
  VOPCOp.V_CMPX_LG_F16_E32: 'EXEC.u64[laneId] = S0.f16 <> S1.f16',
  VOPCOp.V_CMPX_GE_F16_E32: 'EXEC.u64[laneId] = S0.f16 >= S1.f16',
  VOPCOp.V_CMPX_O_F16_E32: "EXEC.u64[laneId] = (!isNAN(64'F(S0.f16)) && !isNAN(64'F(S1.f16)))",
  VOPCOp.V_CMPX_U_F16_E32: "EXEC.u64[laneId] = (isNAN(64'F(S0.f16)) || isNAN(64'F(S1.f16)))",
  VOPCOp.V_CMPX_NGE_F16_E32: 'EXEC.u64[laneId] = !(S0.f16 >= S1.f16);\n// With NAN inputs this is not the same operation as <',
  VOPCOp.V_CMPX_NLG_F16_E32: 'EXEC.u64[laneId] = !(S0.f16 <> S1.f16);\n// With NAN inputs this is not the same operation as ==',
  VOPCOp.V_CMPX_NGT_F16_E32: 'EXEC.u64[laneId] = !(S0.f16 > S1.f16);\n// With NAN inputs this is not the same operation as <=',
  VOPCOp.V_CMPX_NLE_F16_E32: 'EXEC.u64[laneId] = !(S0.f16 <= S1.f16);\n// With NAN inputs this is not the same operation as >',
  VOPCOp.V_CMPX_NEQ_F16_E32: 'EXEC.u64[laneId] = !(S0.f16 == S1.f16);\n// With NAN inputs this is not the same operation as !=',
  VOPCOp.V_CMPX_NLT_F16_E32: 'EXEC.u64[laneId] = !(S0.f16 < S1.f16);\n// With NAN inputs this is not the same operation as >=',
  VOPCOp.V_CMPX_LT_F32_E32: 'EXEC.u64[laneId] = S0.f32 < S1.f32',
  VOPCOp.V_CMPX_EQ_F32_E32: 'EXEC.u64[laneId] = S0.f32 == S1.f32',
  VOPCOp.V_CMPX_LE_F32_E32: 'EXEC.u64[laneId] = S0.f32 <= S1.f32',
  VOPCOp.V_CMPX_GT_F32_E32: 'EXEC.u64[laneId] = S0.f32 > S1.f32',
  VOPCOp.V_CMPX_LG_F32_E32: 'EXEC.u64[laneId] = S0.f32 <> S1.f32',
  VOPCOp.V_CMPX_GE_F32_E32: 'EXEC.u64[laneId] = S0.f32 >= S1.f32',
  VOPCOp.V_CMPX_O_F32_E32: "EXEC.u64[laneId] = (!isNAN(64'F(S0.f32)) && !isNAN(64'F(S1.f32)))",
  VOPCOp.V_CMPX_U_F32_E32: "EXEC.u64[laneId] = (isNAN(64'F(S0.f32)) || isNAN(64'F(S1.f32)))",
  VOPCOp.V_CMPX_NGE_F32_E32: 'EXEC.u64[laneId] = !(S0.f32 >= S1.f32);\n// With NAN inputs this is not the same operation as <',
  VOPCOp.V_CMPX_NLG_F32_E32: 'EXEC.u64[laneId] = !(S0.f32 <> S1.f32);\n// With NAN inputs this is not the same operation as ==',
  VOPCOp.V_CMPX_NGT_F32_E32: 'EXEC.u64[laneId] = !(S0.f32 > S1.f32);\n// With NAN inputs this is not the same operation as <=',
  VOPCOp.V_CMPX_NLE_F32_E32: 'EXEC.u64[laneId] = !(S0.f32 <= S1.f32);\n// With NAN inputs this is not the same operation as >',
  VOPCOp.V_CMPX_NEQ_F32_E32: 'EXEC.u64[laneId] = !(S0.f32 == S1.f32);\n// With NAN inputs this is not the same operation as !=',
  VOPCOp.V_CMPX_NLT_F32_E32: 'EXEC.u64[laneId] = !(S0.f32 < S1.f32);\n// With NAN inputs this is not the same operation as >=',
  VOPCOp.V_CMPX_LT_F64_E32: 'EXEC.u64[laneId] = S0.f64 < S1.f64',
  VOPCOp.V_CMPX_EQ_F64_E32: 'EXEC.u64[laneId] = S0.f64 == S1.f64',
  VOPCOp.V_CMPX_LE_F64_E32: 'EXEC.u64[laneId] = S0.f64 <= S1.f64',
  VOPCOp.V_CMPX_GT_F64_E32: 'EXEC.u64[laneId] = S0.f64 > S1.f64',
  VOPCOp.V_CMPX_LG_F64_E32: 'EXEC.u64[laneId] = S0.f64 <> S1.f64',
  VOPCOp.V_CMPX_GE_F64_E32: 'EXEC.u64[laneId] = S0.f64 >= S1.f64',
  VOPCOp.V_CMPX_O_F64_E32: 'EXEC.u64[laneId] = (!isNAN(S0.f64) && !isNAN(S1.f64))',
  VOPCOp.V_CMPX_U_F64_E32: 'EXEC.u64[laneId] = (isNAN(S0.f64) || isNAN(S1.f64))',
  VOPCOp.V_CMPX_NGE_F64_E32: 'EXEC.u64[laneId] = !(S0.f64 >= S1.f64);\n// With NAN inputs this is not the same operation as <',
  VOPCOp.V_CMPX_NLG_F64_E32: 'EXEC.u64[laneId] = !(S0.f64 <> S1.f64);\n// With NAN inputs this is not the same operation as ==',
  VOPCOp.V_CMPX_NGT_F64_E32: 'EXEC.u64[laneId] = !(S0.f64 > S1.f64);\n// With NAN inputs this is not the same operation as <=',
  VOPCOp.V_CMPX_NLE_F64_E32: 'EXEC.u64[laneId] = !(S0.f64 <= S1.f64);\n// With NAN inputs this is not the same operation as >',
  VOPCOp.V_CMPX_NEQ_F64_E32: 'EXEC.u64[laneId] = !(S0.f64 == S1.f64);\n// With NAN inputs this is not the same operation as !=',
  VOPCOp.V_CMPX_NLT_F64_E32: 'EXEC.u64[laneId] = !(S0.f64 < S1.f64);\n// With NAN inputs this is not the same operation as >=',
  VOPCOp.V_CMPX_LT_I16_E32: 'EXEC.u64[laneId] = S0.i16 < S1.i16',
  VOPCOp.V_CMPX_EQ_I16_E32: 'EXEC.u64[laneId] = S0.i16 == S1.i16',
  VOPCOp.V_CMPX_LE_I16_E32: 'EXEC.u64[laneId] = S0.i16 <= S1.i16',
  VOPCOp.V_CMPX_GT_I16_E32: 'EXEC.u64[laneId] = S0.i16 > S1.i16',
  VOPCOp.V_CMPX_NE_I16_E32: 'EXEC.u64[laneId] = S0.i16 <> S1.i16',
  VOPCOp.V_CMPX_GE_I16_E32: 'EXEC.u64[laneId] = S0.i16 >= S1.i16',
  VOPCOp.V_CMPX_LT_U16_E32: 'EXEC.u64[laneId] = S0.u16 < S1.u16',
  VOPCOp.V_CMPX_EQ_U16_E32: 'EXEC.u64[laneId] = S0.u16 == S1.u16',
  VOPCOp.V_CMPX_LE_U16_E32: 'EXEC.u64[laneId] = S0.u16 <= S1.u16',
  VOPCOp.V_CMPX_GT_U16_E32: 'EXEC.u64[laneId] = S0.u16 > S1.u16',
  VOPCOp.V_CMPX_NE_U16_E32: 'EXEC.u64[laneId] = S0.u16 <> S1.u16',
  VOPCOp.V_CMPX_GE_U16_E32: 'EXEC.u64[laneId] = S0.u16 >= S1.u16',
  VOPCOp.V_CMPX_LT_I32_E32: 'EXEC.u64[laneId] = S0.i32 < S1.i32',
  VOPCOp.V_CMPX_EQ_I32_E32: 'EXEC.u64[laneId] = S0.i32 == S1.i32',
  VOPCOp.V_CMPX_LE_I32_E32: 'EXEC.u64[laneId] = S0.i32 <= S1.i32',
  VOPCOp.V_CMPX_GT_I32_E32: 'EXEC.u64[laneId] = S0.i32 > S1.i32',
  VOPCOp.V_CMPX_NE_I32_E32: 'EXEC.u64[laneId] = S0.i32 <> S1.i32',
  VOPCOp.V_CMPX_GE_I32_E32: 'EXEC.u64[laneId] = S0.i32 >= S1.i32',
  VOPCOp.V_CMPX_LT_U32_E32: 'EXEC.u64[laneId] = S0.u32 < S1.u32',
  VOPCOp.V_CMPX_EQ_U32_E32: 'EXEC.u64[laneId] = S0.u32 == S1.u32',
  VOPCOp.V_CMPX_LE_U32_E32: 'EXEC.u64[laneId] = S0.u32 <= S1.u32',
  VOPCOp.V_CMPX_GT_U32_E32: 'EXEC.u64[laneId] = S0.u32 > S1.u32',
  VOPCOp.V_CMPX_NE_U32_E32: 'EXEC.u64[laneId] = S0.u32 <> S1.u32',
  VOPCOp.V_CMPX_GE_U32_E32: 'EXEC.u64[laneId] = S0.u32 >= S1.u32',
  VOPCOp.V_CMPX_LT_I64_E32: 'EXEC.u64[laneId] = S0.i64 < S1.i64',
  VOPCOp.V_CMPX_EQ_I64_E32: 'EXEC.u64[laneId] = S0.i64 == S1.i64',
  VOPCOp.V_CMPX_LE_I64_E32: 'EXEC.u64[laneId] = S0.i64 <= S1.i64',
  VOPCOp.V_CMPX_GT_I64_E32: 'EXEC.u64[laneId] = S0.i64 > S1.i64',
  VOPCOp.V_CMPX_NE_I64_E32: 'EXEC.u64[laneId] = S0.i64 <> S1.i64',
  VOPCOp.V_CMPX_GE_I64_E32: 'EXEC.u64[laneId] = S0.i64 >= S1.i64',
  VOPCOp.V_CMPX_LT_U64_E32: 'EXEC.u64[laneId] = S0.u64 < S1.u64',
  VOPCOp.V_CMPX_EQ_U64_E32: 'EXEC.u64[laneId] = S0.u64 == S1.u64',
  VOPCOp.V_CMPX_LE_U64_E32: 'EXEC.u64[laneId] = S0.u64 <= S1.u64',
  VOPCOp.V_CMPX_GT_U64_E32: 'EXEC.u64[laneId] = S0.u64 > S1.u64',
  VOPCOp.V_CMPX_NE_U64_E32: 'EXEC.u64[laneId] = S0.u64 <> S1.u64',
  VOPCOp.V_CMPX_GE_U64_E32: 'EXEC.u64[laneId] = S0.u64 >= S1.u64',
  VOPCOp.V_CMPX_CLASS_F16_E32: "declare result : 1'U;\nif isSignalNAN(64'F(S0.f16)) then\nresult = S1.u32[0]\nelsif isQuietNAN(64'F(S0.f16)) then\nresult = S1.u32[1]\nelsif exponent(S0.f16) == 31 then\n// +-INF\nresult = S1.u32[sign(S0.f16) ? 2 : 9]\nelsif exponent(S0.f16) > 0 then\n// +-normal value\nresult = S1.u32[sign(S0.f16) ? 3 : 8]\nelsif 64'F(abs(S0.f16)) > 0.0 then\n// +-denormal value\nresult = S1.u32[sign(S0.f16) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u32[sign(S0.f16) ? 5 : 6]\nendif;\nEXEC.u64[laneId] = result",
  VOPCOp.V_CMPX_CLASS_F32_E32: "declare result : 1'U;\nif isSignalNAN(64'F(S0.f32)) then\nresult = S1.u32[0]\nelsif isQuietNAN(64'F(S0.f32)) then\nresult = S1.u32[1]\nelsif exponent(S0.f32) == 255 then\n// +-INF\nresult = S1.u32[sign(S0.f32) ? 2 : 9]\nelsif exponent(S0.f32) > 0 then\n// +-normal value\nresult = S1.u32[sign(S0.f32) ? 3 : 8]\nelsif 64'F(abs(S0.f32)) > 0.0 then\n// +-denormal value\nresult = S1.u32[sign(S0.f32) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u32[sign(S0.f32) ? 5 : 6]\nendif;\nEXEC.u64[laneId] = result",
  VOPCOp.V_CMPX_CLASS_F64_E32: "declare result : 1'U;\nif isSignalNAN(S0.f64) then\nresult = S1.u32[0]\nelsif isQuietNAN(S0.f64) then\nresult = S1.u32[1]\nelsif exponent(S0.f64) == 2047 then\n// +-INF\nresult = S1.u32[sign(S0.f64) ? 2 : 9]\nelsif exponent(S0.f64) > 0 then\n// +-normal value\nresult = S1.u32[sign(S0.f64) ? 3 : 8]\nelsif abs(S0.f64) > 0.0 then\n// +-denormal value\nresult = S1.u32[sign(S0.f64) ? 4 : 7]\nelse\n// +-0.0\nresult = S1.u32[sign(S0.f64) ? 5 : 6]\nendif;\nEXEC.u64[laneId] = result",
  VOPDOp.V_DUAL_FMAC_F32: 'D0.f32 = fma(S0.f32, S1.f32, D0.f32)',
  VOPDOp.V_DUAL_FMAAK_F32: 'D0.f32 = fma(S0.f32, S1.f32, SIMM32.f32)',
  VOPDOp.V_DUAL_FMAMK_F32: 'D0.f32 = fma(S0.f32, SIMM32.f32, S1.f32)',
  VOPDOp.V_DUAL_MUL_F32: 'D0.f32 = S0.f32 * S1.f32',
  VOPDOp.V_DUAL_ADD_F32: 'D0.f32 = S0.f32 + S1.f32',
  VOPDOp.V_DUAL_SUB_F32: 'D0.f32 = S0.f32 - S1.f32',
  VOPDOp.V_DUAL_SUBREV_F32: 'D0.f32 = S1.f32 - S0.f32',
  VOPDOp.V_DUAL_MUL_DX9_ZERO_F32: "if ((64'F(S0.f32) == 0.0) || (64'F(S1.f32) == 0.0)) then\n// DX9 rules, 0.0 * x = 0.0\nD0.f32 = 0.0F\nelse\nD0.f32 = S0.f32 * S1.f32\nendif",
  VOPDOp.V_DUAL_MOV_B32: 'D0.b32 = S0.b32',
  VOPDOp.V_DUAL_CNDMASK_B32: 'D0.u32 = VCC.u64[laneId] ? S1.u32 : S0.u32',
  VOPDOp.V_DUAL_MAX_NUM_F32: "if (isSignalNAN(64'F(S0.f32)) || isSignalNAN(64'F(S1.f32))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f32)) && isNAN(64'F(S1.f32))) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nelsif isNAN(64'F(S0.f32)) then\nD0.f32 = S1.f32\nelsif isNAN(64'F(S1.f32)) then\nD0.f32 = S0.f32\nelsif ((S0.f32 > S1.f32) || ((abs(S0.f32) == 0.0F) && (abs(S1.f32) == 0.0F) && !sign(S0.f32) &&\nsign(S1.f32))) then\n// NOTE: +0>-0 is TRUE in this comparison\nD0.f32 = S0.f32\nelse\nD0.f32 = S1.f32\nendif",
  VOPDOp.V_DUAL_MIN_NUM_F32: "if (isSignalNAN(64'F(S0.f32)) || isSignalNAN(64'F(S1.f32))) then\nTRAPSTS.INVALID = 1\nendif;\nif (isNAN(64'F(S0.f32)) && isNAN(64'F(S1.f32))) then\nD0.f32 = 32'F(cvtToQuietNAN(64'F(S0.f32)))\nelsif isNAN(64'F(S0.f32)) then\nD0.f32 = S1.f32\nelsif isNAN(64'F(S1.f32)) then\nD0.f32 = S0.f32\nelsif ((S0.f32 < S1.f32) || ((abs(S0.f32) == 0.0F) && (abs(S1.f32) == 0.0F) && sign(S0.f32) &&\n!sign(S1.f32))) then\n// NOTE: -0<+0 is TRUE in this comparison\nD0.f32 = S0.f32\nelse\nD0.f32 = S1.f32\nendif",
  VOPDOp.V_DUAL_DOT2ACC_F32_F16: 'tmp = D0.f32;\ntmp += f16_to_f32(S0[15 : 0].f16) * f16_to_f32(S1[15 : 0].f16);\ntmp += f16_to_f32(S0[31 : 16].f16) * f16_to_f32(S1[31 : 16].f16);\nD0.f32 = tmp',
  VOPDOp.V_DUAL_DOT2ACC_F32_BF16: 'tmp = D0.f32;\ntmp += bf16_to_f32(S0[15 : 0].bf16) * bf16_to_f32(S1[15 : 0].bf16);\ntmp += bf16_to_f32(S0[31 : 16].bf16) * bf16_to_f32(S1[31 : 16].bf16);\nD0.f32 = tmp',
  VOPDOp.V_DUAL_ADD_NC_U32: 'D0.u32 = S0.u32 + S1.u32',
  VOPDOp.V_DUAL_LSHLREV_B32: 'D0.u32 = (S1.u32 << S0[4 : 0].u32)',
  VOPDOp.V_DUAL_AND_B32: 'D0.u32 = (S0.u32 & S1.u32)',
  VSAMPLEOp.IMAGE_GET_LOD: 'VDATA[0] = clampedLOD;\nVDATA[1] = rawLOD.',
  VSCRATCHOp.SCRATCH_LOAD_U8: "addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA.u32 = 32'U({ 24'0U, MEM[addr].u8 })",
  VSCRATCHOp.SCRATCH_LOAD_I8: "addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA.i32 = 32'I(signext(MEM[addr].i8))",
  VSCRATCHOp.SCRATCH_LOAD_U16: "addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA.u32 = 32'U({ 16'0U, MEM[addr].u16 })",
  VSCRATCHOp.SCRATCH_LOAD_I16: "addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA.i32 = 32'I(signext(MEM[addr].i16))",
  VSCRATCHOp.SCRATCH_LOAD_B32: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA[31 : 0] = MEM[addr].b32',
  VSCRATCHOp.SCRATCH_LOAD_B64: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA[31 : 0] = MEM[addr].b32;\nVDATA[63 : 32] = MEM[addr + 4U].b32',
  VSCRATCHOp.SCRATCH_LOAD_B96: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA[31 : 0] = MEM[addr].b32;\nVDATA[63 : 32] = MEM[addr + 4U].b32;\nVDATA[95 : 64] = MEM[addr + 8U].b32',
  VSCRATCHOp.SCRATCH_LOAD_B128: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA[31 : 0] = MEM[addr].b32;\nVDATA[63 : 32] = MEM[addr + 4U].b32;\nVDATA[95 : 64] = MEM[addr + 8U].b32;\nVDATA[127 : 96] = MEM[addr + 12U].b32',
  VSCRATCHOp.SCRATCH_STORE_B8: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nMEM[addr].b8 = VDATA[7 : 0]',
  VSCRATCHOp.SCRATCH_STORE_B16: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nMEM[addr].b16 = VDATA[15 : 0]',
  VSCRATCHOp.SCRATCH_STORE_B32: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nMEM[addr].b32 = VDATA[31 : 0]',
  VSCRATCHOp.SCRATCH_STORE_B64: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nMEM[addr].b32 = VDATA[31 : 0];\nMEM[addr + 4U].b32 = VDATA[63 : 32]',
  VSCRATCHOp.SCRATCH_STORE_B96: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nMEM[addr].b32 = VDATA[31 : 0];\nMEM[addr + 4U].b32 = VDATA[63 : 32];\nMEM[addr + 8U].b32 = VDATA[95 : 64]',
  VSCRATCHOp.SCRATCH_STORE_B128: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nMEM[addr].b32 = VDATA[31 : 0];\nMEM[addr + 4U].b32 = VDATA[63 : 32];\nMEM[addr + 8U].b32 = VDATA[95 : 64];\nMEM[addr + 12U].b32 = VDATA[127 : 96]',
  VSCRATCHOp.SCRATCH_LOAD_D16_U8: "addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA[15 : 0].u16 = 16'U({ 8'0U, MEM[addr].u8 });\n// VDATA[31:16] is preserved.",
  VSCRATCHOp.SCRATCH_LOAD_D16_I8: "addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA[15 : 0].i16 = 16'I(signext(MEM[addr].i8));\n// VDATA[31:16] is preserved.",
  VSCRATCHOp.SCRATCH_LOAD_D16_B16: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA[15 : 0].b16 = MEM[addr].b16;\n// VDATA[31:16] is preserved.',
  VSCRATCHOp.SCRATCH_LOAD_D16_HI_U8: "addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA[31 : 16].u16 = 16'U({ 8'0U, MEM[addr].u8 });\n// VDATA[15:0] is preserved.",
  VSCRATCHOp.SCRATCH_LOAD_D16_HI_I8: "addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA[31 : 16].i16 = 16'I(signext(MEM[addr].i8));\n// VDATA[15:0] is preserved.",
  VSCRATCHOp.SCRATCH_LOAD_D16_HI_B16: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nVDATA[31 : 16].b16 = MEM[addr].b16;\n// VDATA[15:0] is preserved.',
  VSCRATCHOp.SCRATCH_STORE_D16_HI_B8: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nMEM[addr].b8 = VDATA[23 : 16]',
  VSCRATCHOp.SCRATCH_STORE_D16_HI_B16: 'addr = CalcScratchAddr(v_addr_off.b64, s_saddr_off.b64);\nMEM[addr].b16 = VDATA[31 : 16]',
  VSCRATCHOp.SCRATCH_LOAD_BLOCK: 'for i in 0 : 31 do\n// Algorithm can skip over "holes" both in the memory block and VGPR block.\nif M0[i].u1 then\nVGPR[laneId][VDST.u32 + i.u32] = MEM[VGPR[laneId][ADDR].i32 + i * 4].b32\nendif\nendfor',
  VSCRATCHOp.SCRATCH_STORE_BLOCK: 'for i in 0 : 31 do\n// Algorithm can skip over "holes" both in the memory block and VGPR block.\nif M0[i].u1 then\nMEM[VGPR[laneId][ADDR].i32 + i * 4] = VGPR[laneId][VDATA.u32 + i.u32].b32\nendif\nendfor',
}